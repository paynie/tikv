// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `graph_rpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.EasyGraphConfig)
pub struct EasyGraphConfig {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.EasyGraphConfig.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.EasyGraphConfig.user)
    pub user: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.EasyGraphConfig.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.EasyGraphConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EasyGraphConfig {
    fn default() -> &'a EasyGraphConfig {
        <EasyGraphConfig as ::protobuf::Message>::default_instance()
    }
}

impl EasyGraphConfig {
    pub fn new() -> EasyGraphConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &EasyGraphConfig| { &m.address },
            |m: &mut EasyGraphConfig| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user",
            |m: &EasyGraphConfig| { &m.user },
            |m: &mut EasyGraphConfig| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &EasyGraphConfig| { &m.password },
            |m: &mut EasyGraphConfig| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EasyGraphConfig>(
            "EasyGraphConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EasyGraphConfig {
    const NAME: &'static str = "EasyGraphConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.user = is.read_string()?;
                },
                26 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.user.is_empty() {
            os.write_string(2, &self.user)?;
        }
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EasyGraphConfig {
        EasyGraphConfig::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.user.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EasyGraphConfig {
        static instance: EasyGraphConfig = EasyGraphConfig {
            address: ::std::string::String::new(),
            user: ::std::string::String::new(),
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EasyGraphConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EasyGraphConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EasyGraphConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyGraphConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.FrontVertex)
pub struct FrontVertex {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.FrontVertex.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.FrontVertex.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.FrontVertex.properties)
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.FrontVertex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FrontVertex {
    fn default() -> &'a FrontVertex {
        <FrontVertex as ::protobuf::Message>::default_instance()
    }
}

impl FrontVertex {
    pub fn new() -> FrontVertex {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &FrontVertex| { &m.label },
            |m: &mut FrontVertex| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FrontVertex| { &m.id },
            |m: &mut FrontVertex| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "properties",
            |m: &FrontVertex| { &m.properties },
            |m: &mut FrontVertex| { &mut m.properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FrontVertex>(
            "FrontVertex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FrontVertex {
    const NAME: &'static str = "FrontVertex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.label = is.read_string()?;
                },
                26 => {
                    self.id = is.read_string()?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.properties.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FrontVertex {
        FrontVertex::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.id.clear();
        self.properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FrontVertex {
        static instance: ::protobuf::rt::Lazy<FrontVertex> = ::protobuf::rt::Lazy::new();
        instance.get(FrontVertex::new)
    }
}

impl ::protobuf::MessageFull for FrontVertex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FrontVertex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FrontVertex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrontVertex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.FrontEdge)
pub struct FrontEdge {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.FrontEdge.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.FrontEdge.srcId)
    pub srcId: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.FrontEdge.dstId)
    pub dstId: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.FrontEdge.direction)
    pub direction: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.FrontEdge.properties)
    pub properties: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.FrontEdge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FrontEdge {
    fn default() -> &'a FrontEdge {
        <FrontEdge as ::protobuf::Message>::default_instance()
    }
}

impl FrontEdge {
    pub fn new() -> FrontEdge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &FrontEdge| { &m.label },
            |m: &mut FrontEdge| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "srcId",
            |m: &FrontEdge| { &m.srcId },
            |m: &mut FrontEdge| { &mut m.srcId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dstId",
            |m: &FrontEdge| { &m.dstId },
            |m: &mut FrontEdge| { &mut m.dstId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &FrontEdge| { &m.direction },
            |m: &mut FrontEdge| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "properties",
            |m: &FrontEdge| { &m.properties },
            |m: &mut FrontEdge| { &mut m.properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FrontEdge>(
            "FrontEdge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FrontEdge {
    const NAME: &'static str = "FrontEdge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.label = is.read_string()?;
                },
                26 => {
                    self.srcId = is.read_string()?;
                },
                34 => {
                    self.dstId = is.read_string()?;
                },
                40 => {
                    self.direction = is.read_int32()?;
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.properties.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if !self.srcId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.srcId);
        }
        if !self.dstId.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dstId);
        }
        if self.direction != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.direction);
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if !self.srcId.is_empty() {
            os.write_string(3, &self.srcId)?;
        }
        if !self.dstId.is_empty() {
            os.write_string(4, &self.dstId)?;
        }
        if self.direction != 0 {
            os.write_int32(5, self.direction)?;
        }
        for (k, v) in &self.properties {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FrontEdge {
        FrontEdge::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.srcId.clear();
        self.dstId.clear();
        self.direction = 0;
        self.properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FrontEdge {
        static instance: ::protobuf::rt::Lazy<FrontEdge> = ::protobuf::rt::Lazy::new();
        instance.get(FrontEdge::new)
    }
}

impl ::protobuf::MessageFull for FrontEdge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FrontEdge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FrontEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrontEdge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.AddVertexRequest)
pub struct AddVertexRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AddVertexRequest.graph)
    pub graph: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AddVertexRequest.batch)
    pub batch: ::std::vec::Vec<FrontVertex>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.AddVertexRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddVertexRequest {
    fn default() -> &'a AddVertexRequest {
        <AddVertexRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddVertexRequest {
    pub fn new() -> AddVertexRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph",
            |m: &AddVertexRequest| { &m.graph },
            |m: &mut AddVertexRequest| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "batch",
            |m: &AddVertexRequest| { &m.batch },
            |m: &mut AddVertexRequest| { &mut m.batch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddVertexRequest>(
            "AddVertexRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddVertexRequest {
    const NAME: &'static str = "AddVertexRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graph = is.read_string()?;
                },
                18 => {
                    self.batch.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graph.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph);
        }
        for value in &self.batch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graph.is_empty() {
            os.write_string(1, &self.graph)?;
        }
        for v in &self.batch {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddVertexRequest {
        AddVertexRequest::new()
    }

    fn clear(&mut self) {
        self.graph.clear();
        self.batch.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddVertexRequest {
        static instance: AddVertexRequest = AddVertexRequest {
            graph: ::std::string::String::new(),
            batch: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddVertexRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddVertexRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddVertexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddVertexRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.AddVertexResponse)
pub struct AddVertexResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AddVertexResponse.code)
    pub code: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AddVertexResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.AddVertexResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddVertexResponse {
    fn default() -> &'a AddVertexResponse {
        <AddVertexResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddVertexResponse {
    pub fn new() -> AddVertexResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &AddVertexResponse| { &m.code },
            |m: &mut AddVertexResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &AddVertexResponse| { &m.message },
            |m: &mut AddVertexResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddVertexResponse>(
            "AddVertexResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddVertexResponse {
    const NAME: &'static str = "AddVertexResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddVertexResponse {
        AddVertexResponse::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddVertexResponse {
        static instance: AddVertexResponse = AddVertexResponse {
            code: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddVertexResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddVertexResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddVertexResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddVertexResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.DropVertexRequest)
pub struct DropVertexRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.DropVertexRequest.graph)
    pub graph: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.DropVertexRequest.batch)
    pub batch: ::std::vec::Vec<FrontVertex>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.DropVertexRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropVertexRequest {
    fn default() -> &'a DropVertexRequest {
        <DropVertexRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropVertexRequest {
    pub fn new() -> DropVertexRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph",
            |m: &DropVertexRequest| { &m.graph },
            |m: &mut DropVertexRequest| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "batch",
            |m: &DropVertexRequest| { &m.batch },
            |m: &mut DropVertexRequest| { &mut m.batch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropVertexRequest>(
            "DropVertexRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropVertexRequest {
    const NAME: &'static str = "DropVertexRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graph = is.read_string()?;
                },
                18 => {
                    self.batch.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graph.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph);
        }
        for value in &self.batch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graph.is_empty() {
            os.write_string(1, &self.graph)?;
        }
        for v in &self.batch {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropVertexRequest {
        DropVertexRequest::new()
    }

    fn clear(&mut self) {
        self.graph.clear();
        self.batch.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropVertexRequest {
        static instance: DropVertexRequest = DropVertexRequest {
            graph: ::std::string::String::new(),
            batch: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropVertexRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropVertexRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropVertexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropVertexRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.DropVertexResponse)
pub struct DropVertexResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.DropVertexResponse.code)
    pub code: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.DropVertexResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.DropVertexResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropVertexResponse {
    fn default() -> &'a DropVertexResponse {
        <DropVertexResponse as ::protobuf::Message>::default_instance()
    }
}

impl DropVertexResponse {
    pub fn new() -> DropVertexResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &DropVertexResponse| { &m.code },
            |m: &mut DropVertexResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &DropVertexResponse| { &m.message },
            |m: &mut DropVertexResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropVertexResponse>(
            "DropVertexResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropVertexResponse {
    const NAME: &'static str = "DropVertexResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropVertexResponse {
        DropVertexResponse::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropVertexResponse {
        static instance: DropVertexResponse = DropVertexResponse {
            code: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropVertexResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropVertexResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropVertexResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropVertexResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.AddEdgeRequest)
pub struct AddEdgeRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AddEdgeRequest.graph)
    pub graph: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AddEdgeRequest.batch)
    pub batch: ::std::vec::Vec<FrontEdge>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.AddEdgeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddEdgeRequest {
    fn default() -> &'a AddEdgeRequest {
        <AddEdgeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddEdgeRequest {
    pub fn new() -> AddEdgeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph",
            |m: &AddEdgeRequest| { &m.graph },
            |m: &mut AddEdgeRequest| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "batch",
            |m: &AddEdgeRequest| { &m.batch },
            |m: &mut AddEdgeRequest| { &mut m.batch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddEdgeRequest>(
            "AddEdgeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddEdgeRequest {
    const NAME: &'static str = "AddEdgeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graph = is.read_string()?;
                },
                18 => {
                    self.batch.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graph.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph);
        }
        for value in &self.batch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graph.is_empty() {
            os.write_string(1, &self.graph)?;
        }
        for v in &self.batch {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddEdgeRequest {
        AddEdgeRequest::new()
    }

    fn clear(&mut self) {
        self.graph.clear();
        self.batch.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddEdgeRequest {
        static instance: AddEdgeRequest = AddEdgeRequest {
            graph: ::std::string::String::new(),
            batch: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddEdgeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddEdgeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddEdgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddEdgeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.AddEdgeResponse)
pub struct AddEdgeResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AddEdgeResponse.code)
    pub code: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AddEdgeResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.AddEdgeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddEdgeResponse {
    fn default() -> &'a AddEdgeResponse {
        <AddEdgeResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddEdgeResponse {
    pub fn new() -> AddEdgeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &AddEdgeResponse| { &m.code },
            |m: &mut AddEdgeResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &AddEdgeResponse| { &m.message },
            |m: &mut AddEdgeResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddEdgeResponse>(
            "AddEdgeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddEdgeResponse {
    const NAME: &'static str = "AddEdgeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddEdgeResponse {
        AddEdgeResponse::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddEdgeResponse {
        static instance: AddEdgeResponse = AddEdgeResponse {
            code: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddEdgeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddEdgeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddEdgeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddEdgeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.DropEdgeRequest)
pub struct DropEdgeRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.DropEdgeRequest.graph)
    pub graph: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.DropEdgeRequest.batch)
    pub batch: ::std::vec::Vec<FrontEdge>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.DropEdgeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropEdgeRequest {
    fn default() -> &'a DropEdgeRequest {
        <DropEdgeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropEdgeRequest {
    pub fn new() -> DropEdgeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph",
            |m: &DropEdgeRequest| { &m.graph },
            |m: &mut DropEdgeRequest| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "batch",
            |m: &DropEdgeRequest| { &m.batch },
            |m: &mut DropEdgeRequest| { &mut m.batch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropEdgeRequest>(
            "DropEdgeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropEdgeRequest {
    const NAME: &'static str = "DropEdgeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graph = is.read_string()?;
                },
                18 => {
                    self.batch.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graph.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph);
        }
        for value in &self.batch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graph.is_empty() {
            os.write_string(1, &self.graph)?;
        }
        for v in &self.batch {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropEdgeRequest {
        DropEdgeRequest::new()
    }

    fn clear(&mut self) {
        self.graph.clear();
        self.batch.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropEdgeRequest {
        static instance: DropEdgeRequest = DropEdgeRequest {
            graph: ::std::string::String::new(),
            batch: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropEdgeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropEdgeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropEdgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropEdgeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.DropEdgeResponse)
pub struct DropEdgeResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.DropEdgeResponse.code)
    pub code: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.DropEdgeResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.DropEdgeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropEdgeResponse {
    fn default() -> &'a DropEdgeResponse {
        <DropEdgeResponse as ::protobuf::Message>::default_instance()
    }
}

impl DropEdgeResponse {
    pub fn new() -> DropEdgeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &DropEdgeResponse| { &m.code },
            |m: &mut DropEdgeResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &DropEdgeResponse| { &m.message },
            |m: &mut DropEdgeResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropEdgeResponse>(
            "DropEdgeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropEdgeResponse {
    const NAME: &'static str = "DropEdgeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropEdgeResponse {
        DropEdgeResponse::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropEdgeResponse {
        static instance: DropEdgeResponse = DropEdgeResponse {
            code: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropEdgeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropEdgeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropEdgeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropEdgeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.GetGraphMetaRequest)
pub struct GetGraphMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetGraphMetaRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.GetGraphMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetGraphMetaRequest {
    fn default() -> &'a GetGraphMetaRequest {
        <GetGraphMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetGraphMetaRequest {
    pub fn new() -> GetGraphMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GetGraphMetaRequest| { &m.name },
            |m: &mut GetGraphMetaRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetGraphMetaRequest>(
            "GetGraphMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetGraphMetaRequest {
    const NAME: &'static str = "GetGraphMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetGraphMetaRequest {
        GetGraphMetaRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetGraphMetaRequest {
        static instance: GetGraphMetaRequest = GetGraphMetaRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetGraphMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetGraphMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetGraphMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetGraphMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.GetGraphMetaResponse)
pub struct GetGraphMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetGraphMetaResponse.code)
    pub code: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetGraphMetaResponse.meta)
    pub meta: ::protobuf::MessageField<super::meta::GraphMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.GetGraphMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetGraphMetaResponse {
    fn default() -> &'a GetGraphMetaResponse {
        <GetGraphMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetGraphMetaResponse {
    pub fn new() -> GetGraphMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &GetGraphMetaResponse| { &m.code },
            |m: &mut GetGraphMetaResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::meta::GraphMeta>(
            "meta",
            |m: &GetGraphMetaResponse| { &m.meta },
            |m: &mut GetGraphMetaResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetGraphMetaResponse>(
            "GetGraphMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetGraphMetaResponse {
    const NAME: &'static str = "GetGraphMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetGraphMetaResponse {
        GetGraphMetaResponse::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetGraphMetaResponse {
        static instance: GetGraphMetaResponse = GetGraphMetaResponse {
            code: 0,
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetGraphMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetGraphMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetGraphMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetGraphMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.AuthRequest)
pub struct AuthRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AuthRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.AuthRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthRequest {
    fn default() -> &'a AuthRequest {
        <AuthRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRequest {
    pub fn new() -> AuthRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AuthRequest| { &m.name },
            |m: &mut AuthRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthRequest>(
            "AuthRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuthRequest {
    const NAME: &'static str = "AuthRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthRequest {
        AuthRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthRequest {
        static instance: AuthRequest = AuthRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuthRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuthRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuthRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.AuthResponse)
pub struct AuthResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.AuthResponse.success)
    pub success: bool,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.AuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthResponse {
    fn default() -> &'a AuthResponse {
        <AuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthResponse {
    pub fn new() -> AuthResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &AuthResponse| { &m.success },
            |m: &mut AuthResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthResponse>(
            "AuthResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuthResponse {
    const NAME: &'static str = "AuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthResponse {
        AuthResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthResponse {
        static instance: AuthResponse = AuthResponse {
            success: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuthResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.TaskRequest)
pub struct TaskRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.TaskRequest.graph)
    pub graph: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.TaskRequest.task)
    pub task: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.TaskRequest.clazz)
    pub clazz: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.TaskRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskRequest {
    fn default() -> &'a TaskRequest {
        <TaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl TaskRequest {
    pub fn new() -> TaskRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph",
            |m: &TaskRequest| { &m.graph },
            |m: &mut TaskRequest| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task",
            |m: &TaskRequest| { &m.task },
            |m: &mut TaskRequest| { &mut m.task },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "clazz",
            |m: &TaskRequest| { &m.clazz },
            |m: &mut TaskRequest| { &mut m.clazz },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskRequest>(
            "TaskRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskRequest {
    const NAME: &'static str = "TaskRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graph = is.read_string()?;
                },
                18 => {
                    self.task = is.read_string()?;
                },
                26 => {
                    self.clazz = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graph.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph);
        }
        if !self.task.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task);
        }
        if !self.clazz.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.clazz);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graph.is_empty() {
            os.write_string(1, &self.graph)?;
        }
        if !self.task.is_empty() {
            os.write_string(2, &self.task)?;
        }
        if !self.clazz.is_empty() {
            os.write_string(3, &self.clazz)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskRequest {
        TaskRequest::new()
    }

    fn clear(&mut self) {
        self.graph.clear();
        self.task.clear();
        self.clazz.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskRequest {
        static instance: TaskRequest = TaskRequest {
            graph: ::std::string::String::new(),
            task: ::std::string::String::new(),
            clazz: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.TaskResponse)
pub struct TaskResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.TaskResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.TaskResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.TaskResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskResponse {
    fn default() -> &'a TaskResponse {
        <TaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl TaskResponse {
    pub fn new() -> TaskResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &TaskResponse| { &m.success },
            |m: &mut TaskResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &TaskResponse| { &m.message },
            |m: &mut TaskResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskResponse>(
            "TaskResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskResponse {
    const NAME: &'static str = "TaskResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskResponse {
        TaskResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskResponse {
        static instance: TaskResponse = TaskResponse {
            success: false,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto)
pub struct GetFullGraphRequestProto {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.vertexId)
    pub vertexId: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.steps)
    pub steps: ::std::vec::Vec<StepConfigProto>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.filterName)
    pub filterName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.filterDef)
    pub filterDef: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.resultLimit)
    pub resultLimit: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.execeptResultLimit)
    pub execeptResultLimit: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.pushDownFilter)
    pub pushDownFilter: bool,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.graphName)
    pub graphName: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.GetFullGraphRequestProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFullGraphRequestProto {
    fn default() -> &'a GetFullGraphRequestProto {
        <GetFullGraphRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFullGraphRequestProto {
    pub fn new() -> GetFullGraphRequestProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vertexId",
            |m: &GetFullGraphRequestProto| { &m.vertexId },
            |m: &mut GetFullGraphRequestProto| { &mut m.vertexId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &GetFullGraphRequestProto| { &m.steps },
            |m: &mut GetFullGraphRequestProto| { &mut m.steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filterName",
            |m: &GetFullGraphRequestProto| { &m.filterName },
            |m: &mut GetFullGraphRequestProto| { &mut m.filterName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filterDef",
            |m: &GetFullGraphRequestProto| { &m.filterDef },
            |m: &mut GetFullGraphRequestProto| { &mut m.filterDef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resultLimit",
            |m: &GetFullGraphRequestProto| { &m.resultLimit },
            |m: &mut GetFullGraphRequestProto| { &mut m.resultLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "execeptResultLimit",
            |m: &GetFullGraphRequestProto| { &m.execeptResultLimit },
            |m: &mut GetFullGraphRequestProto| { &mut m.execeptResultLimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pushDownFilter",
            |m: &GetFullGraphRequestProto| { &m.pushDownFilter },
            |m: &mut GetFullGraphRequestProto| { &mut m.pushDownFilter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &GetFullGraphRequestProto| { &m.graphName },
            |m: &mut GetFullGraphRequestProto| { &mut m.graphName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFullGraphRequestProto>(
            "GetFullGraphRequestProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFullGraphRequestProto {
    const NAME: &'static str = "GetFullGraphRequestProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vertexId = is.read_string()?;
                },
                18 => {
                    self.steps.push(is.read_message()?);
                },
                26 => {
                    self.filterName = is.read_string()?;
                },
                34 => {
                    self.filterDef = is.read_string()?;
                },
                40 => {
                    self.resultLimit = is.read_int32()?;
                },
                48 => {
                    self.execeptResultLimit = is.read_int32()?;
                },
                56 => {
                    self.pushDownFilter = is.read_bool()?;
                },
                66 => {
                    self.graphName = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.vertexId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.vertexId);
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.filterName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.filterName);
        }
        if !self.filterDef.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filterDef);
        }
        if self.resultLimit != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.resultLimit);
        }
        if self.execeptResultLimit != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.execeptResultLimit);
        }
        if self.pushDownFilter != false {
            my_size += 1 + 1;
        }
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.graphName);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.vertexId.is_empty() {
            os.write_string(1, &self.vertexId)?;
        }
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.filterName.is_empty() {
            os.write_string(3, &self.filterName)?;
        }
        if !self.filterDef.is_empty() {
            os.write_string(4, &self.filterDef)?;
        }
        if self.resultLimit != 0 {
            os.write_int32(5, self.resultLimit)?;
        }
        if self.execeptResultLimit != 0 {
            os.write_int32(6, self.execeptResultLimit)?;
        }
        if self.pushDownFilter != false {
            os.write_bool(7, self.pushDownFilter)?;
        }
        if !self.graphName.is_empty() {
            os.write_string(8, &self.graphName)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFullGraphRequestProto {
        GetFullGraphRequestProto::new()
    }

    fn clear(&mut self) {
        self.vertexId.clear();
        self.steps.clear();
        self.filterName.clear();
        self.filterDef.clear();
        self.resultLimit = 0;
        self.execeptResultLimit = 0;
        self.pushDownFilter = false;
        self.graphName.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFullGraphRequestProto {
        static instance: GetFullGraphRequestProto = GetFullGraphRequestProto {
            vertexId: ::std::string::String::new(),
            steps: ::std::vec::Vec::new(),
            filterName: ::std::string::String::new(),
            filterDef: ::std::string::String::new(),
            resultLimit: 0,
            execeptResultLimit: 0,
            pushDownFilter: false,
            graphName: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFullGraphRequestProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFullGraphRequestProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFullGraphRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFullGraphRequestProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.GetFullGraphResponseProto)
pub struct GetFullGraphResponseProto {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphResponseProto.code)
    pub code: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphResponseProto.vertices)
    pub vertices: ::std::vec::Vec<FrontVertex>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.GetFullGraphResponseProto.edges)
    pub edges: ::std::vec::Vec<FrontEdge>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.GetFullGraphResponseProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFullGraphResponseProto {
    fn default() -> &'a GetFullGraphResponseProto {
        <GetFullGraphResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFullGraphResponseProto {
    pub fn new() -> GetFullGraphResponseProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &GetFullGraphResponseProto| { &m.code },
            |m: &mut GetFullGraphResponseProto| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vertices",
            |m: &GetFullGraphResponseProto| { &m.vertices },
            |m: &mut GetFullGraphResponseProto| { &mut m.vertices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edges",
            |m: &GetFullGraphResponseProto| { &m.edges },
            |m: &mut GetFullGraphResponseProto| { &mut m.edges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFullGraphResponseProto>(
            "GetFullGraphResponseProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFullGraphResponseProto {
    const NAME: &'static str = "GetFullGraphResponseProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.vertices.push(is.read_message()?);
                },
                26 => {
                    self.edges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        for value in &self.vertices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        for v in &self.vertices {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.edges {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFullGraphResponseProto {
        GetFullGraphResponseProto::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.vertices.clear();
        self.edges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFullGraphResponseProto {
        static instance: GetFullGraphResponseProto = GetFullGraphResponseProto {
            code: 0,
            vertices: ::std::vec::Vec::new(),
            edges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFullGraphResponseProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFullGraphResponseProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFullGraphResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFullGraphResponseProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.StepConfigProto)
pub struct StepConfigProto {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.StepConfigProto.labelConfigs)
    pub labelConfigs: ::std::vec::Vec<LabelConfigProto>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.StepConfigProto.direction)
    pub direction: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.StepConfigProto.limit)
    pub limit: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.StepConfigProto.distinctHint)
    pub distinctHint: bool,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.StepConfigProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StepConfigProto {
    fn default() -> &'a StepConfigProto {
        <StepConfigProto as ::protobuf::Message>::default_instance()
    }
}

impl StepConfigProto {
    pub fn new() -> StepConfigProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labelConfigs",
            |m: &StepConfigProto| { &m.labelConfigs },
            |m: &mut StepConfigProto| { &mut m.labelConfigs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &StepConfigProto| { &m.direction },
            |m: &mut StepConfigProto| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &StepConfigProto| { &m.limit },
            |m: &mut StepConfigProto| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "distinctHint",
            |m: &StepConfigProto| { &m.distinctHint },
            |m: &mut StepConfigProto| { &mut m.distinctHint },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepConfigProto>(
            "StepConfigProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StepConfigProto {
    const NAME: &'static str = "StepConfigProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.labelConfigs.push(is.read_message()?);
                },
                16 => {
                    self.direction = is.read_int32()?;
                },
                24 => {
                    self.limit = is.read_int32()?;
                },
                32 => {
                    self.distinctHint = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.labelConfigs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.direction != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.direction);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.limit);
        }
        if self.distinctHint != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.labelConfigs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.direction != 0 {
            os.write_int32(2, self.direction)?;
        }
        if self.limit != 0 {
            os.write_int32(3, self.limit)?;
        }
        if self.distinctHint != false {
            os.write_bool(4, self.distinctHint)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StepConfigProto {
        StepConfigProto::new()
    }

    fn clear(&mut self) {
        self.labelConfigs.clear();
        self.direction = 0;
        self.limit = 0;
        self.distinctHint = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StepConfigProto {
        static instance: StepConfigProto = StepConfigProto {
            labelConfigs: ::std::vec::Vec::new(),
            direction: 0,
            limit: 0,
            distinctHint: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StepConfigProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StepConfigProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StepConfigProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepConfigProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.LabelConfigProto)
pub struct LabelConfigProto {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.LabelConfigProto.labelName)
    pub labelName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.LabelConfigProto.direction)
    pub direction: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.LabelConfigProto.limit)
    pub limit: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.LabelConfigProto.distinctHint)
    pub distinctHint: bool,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.LabelConfigProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelConfigProto {
    fn default() -> &'a LabelConfigProto {
        <LabelConfigProto as ::protobuf::Message>::default_instance()
    }
}

impl LabelConfigProto {
    pub fn new() -> LabelConfigProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "labelName",
            |m: &LabelConfigProto| { &m.labelName },
            |m: &mut LabelConfigProto| { &mut m.labelName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &LabelConfigProto| { &m.direction },
            |m: &mut LabelConfigProto| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &LabelConfigProto| { &m.limit },
            |m: &mut LabelConfigProto| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "distinctHint",
            |m: &LabelConfigProto| { &m.distinctHint },
            |m: &mut LabelConfigProto| { &mut m.distinctHint },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelConfigProto>(
            "LabelConfigProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelConfigProto {
    const NAME: &'static str = "LabelConfigProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.labelName = is.read_string()?;
                },
                16 => {
                    self.direction = is.read_int32()?;
                },
                24 => {
                    self.limit = is.read_int32()?;
                },
                32 => {
                    self.distinctHint = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.labelName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.labelName);
        }
        if self.direction != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.direction);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.limit);
        }
        if self.distinctHint != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.labelName.is_empty() {
            os.write_string(1, &self.labelName)?;
        }
        if self.direction != 0 {
            os.write_int32(2, self.direction)?;
        }
        if self.limit != 0 {
            os.write_int32(3, self.limit)?;
        }
        if self.distinctHint != false {
            os.write_bool(4, self.distinctHint)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelConfigProto {
        LabelConfigProto::new()
    }

    fn clear(&mut self) {
        self.labelName.clear();
        self.direction = 0;
        self.limit = 0;
        self.distinctHint = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelConfigProto {
        static instance: LabelConfigProto = LabelConfigProto {
            labelName: ::std::string::String::new(),
            direction: 0,
            limit: 0,
            distinctHint: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelConfigProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelConfigProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelConfigProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelConfigProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.SampleRequestProto)
pub struct SampleRequestProto {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.SampleRequestProto.vertexId)
    pub vertexId: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.SampleRequestProto.steps)
    pub steps: ::std::vec::Vec<StepConfigProto>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.SampleRequestProto.graphName)
    pub graphName: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.SampleRequestProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SampleRequestProto {
    fn default() -> &'a SampleRequestProto {
        <SampleRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SampleRequestProto {
    pub fn new() -> SampleRequestProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vertexId",
            |m: &SampleRequestProto| { &m.vertexId },
            |m: &mut SampleRequestProto| { &mut m.vertexId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &SampleRequestProto| { &m.steps },
            |m: &mut SampleRequestProto| { &mut m.steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &SampleRequestProto| { &m.graphName },
            |m: &mut SampleRequestProto| { &mut m.graphName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SampleRequestProto>(
            "SampleRequestProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SampleRequestProto {
    const NAME: &'static str = "SampleRequestProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vertexId = is.read_string()?;
                },
                18 => {
                    self.steps.push(is.read_message()?);
                },
                26 => {
                    self.graphName = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.vertexId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.vertexId);
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.graphName);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.vertexId.is_empty() {
            os.write_string(1, &self.vertexId)?;
        }
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.graphName.is_empty() {
            os.write_string(3, &self.graphName)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SampleRequestProto {
        SampleRequestProto::new()
    }

    fn clear(&mut self) {
        self.vertexId.clear();
        self.steps.clear();
        self.graphName.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SampleRequestProto {
        static instance: SampleRequestProto = SampleRequestProto {
            vertexId: ::std::string::String::new(),
            steps: ::std::vec::Vec::new(),
            graphName: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SampleRequestProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SampleRequestProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SampleRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SampleRequestProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.graphrpc.proto.SampleResponseProto)
pub struct SampleResponseProto {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.SampleResponseProto.code)
    pub code: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.SampleResponseProto.vertices)
    pub vertices: ::std::vec::Vec<FrontVertex>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.graphrpc.proto.SampleResponseProto.edges)
    pub edges: ::std::vec::Vec<FrontEdge>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.graphrpc.proto.SampleResponseProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SampleResponseProto {
    fn default() -> &'a SampleResponseProto {
        <SampleResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SampleResponseProto {
    pub fn new() -> SampleResponseProto {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &SampleResponseProto| { &m.code },
            |m: &mut SampleResponseProto| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vertices",
            |m: &SampleResponseProto| { &m.vertices },
            |m: &mut SampleResponseProto| { &mut m.vertices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edges",
            |m: &SampleResponseProto| { &m.edges },
            |m: &mut SampleResponseProto| { &mut m.edges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SampleResponseProto>(
            "SampleResponseProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SampleResponseProto {
    const NAME: &'static str = "SampleResponseProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = is.read_int32()?;
                },
                18 => {
                    self.vertices.push(is.read_message()?);
                },
                26 => {
                    self.edges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.code);
        }
        for value in &self.vertices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        for v in &self.vertices {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.edges {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SampleResponseProto {
        SampleResponseProto::new()
    }

    fn clear(&mut self) {
        self.code = 0;
        self.vertices.clear();
        self.edges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SampleResponseProto {
        static instance: SampleResponseProto = SampleResponseProto {
            code: 0,
            vertices: ::std::vec::Vec::new(),
            edges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SampleResponseProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SampleResponseProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SampleResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SampleResponseProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fgraph_rpc.proto\x12$com.tencent.easygraph.graphrpc.proto\x1a\nmeta\
    .proto\"[\n\x0fEasyGraphConfig\x12\x18\n\x07address\x18\x01\x20\x01(\tR\
    \x07address\x12\x12\n\x04user\x18\x02\x20\x01(\tR\x04user\x12\x1a\n\x08p\
    assword\x18\x03\x20\x01(\tR\x08password\"\xd5\x01\n\x0bFrontVertex\x12\
    \x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12\x0e\n\x02id\x18\x03\x20\
    \x01(\tR\x02id\x12a\n\nproperties\x18\x04\x20\x03(\x0b2A.com.tencent.eas\
    ygraph.graphrpc.proto.FrontVertex.PropertiesEntryR\nproperties\x1a=\n\
    \x0fPropertiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x8b\x02\n\tFrontEdg\
    e\x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05label\x12\x14\n\x05srcId\x18\
    \x03\x20\x01(\tR\x05srcId\x12\x14\n\x05dstId\x18\x04\x20\x01(\tR\x05dstI\
    d\x12\x1c\n\tdirection\x18\x05\x20\x01(\x05R\tdirection\x12_\n\nproperti\
    es\x18\x06\x20\x03(\x0b2?.com.tencent.easygraph.graphrpc.proto.FrontEdge\
    .PropertiesEntryR\nproperties\x1a=\n\x0fPropertiesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"q\n\x10AddVertexRequest\x12\x14\n\x05graph\x18\x01\x20\
    \x01(\tR\x05graph\x12G\n\x05batch\x18\x02\x20\x03(\x0b21.com.tencent.eas\
    ygraph.graphrpc.proto.FrontVertexR\x05batch\"A\n\x11AddVertexResponse\
    \x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\x07message\
    \x18\x02\x20\x01(\tR\x07message\"r\n\x11DropVertexRequest\x12\x14\n\x05g\
    raph\x18\x01\x20\x01(\tR\x05graph\x12G\n\x05batch\x18\x02\x20\x03(\x0b21\
    .com.tencent.easygraph.graphrpc.proto.FrontVertexR\x05batch\"B\n\x12Drop\
    VertexResponse\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\"m\n\x0eAddEdgeRequest\x12\
    \x14\n\x05graph\x18\x01\x20\x01(\tR\x05graph\x12E\n\x05batch\x18\x02\x20\
    \x03(\x0b2/.com.tencent.easygraph.graphrpc.proto.FrontEdgeR\x05batch\"?\
    \n\x0fAddEdgeResponse\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\
    \x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"n\n\x0fDropEdgeReq\
    uest\x12\x14\n\x05graph\x18\x01\x20\x01(\tR\x05graph\x12E\n\x05batch\x18\
    \x02\x20\x03(\x0b2/.com.tencent.easygraph.graphrpc.proto.FrontEdgeR\x05b\
    atch\"@\n\x10DropEdgeResponse\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\
    \x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\")\n\x13Get\
    GraphMetaRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"f\n\x14G\
    etGraphMetaResponse\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12:\
    \n\x04meta\x18\x02\x20\x01(\x0b2&.com.tencent.easygraph.proto.GraphMetaR\
    \x04meta\"!\n\x0bAuthRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\"(\n\x0cAuthResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07su\
    ccess\"M\n\x0bTaskRequest\x12\x14\n\x05graph\x18\x01\x20\x01(\tR\x05grap\
    h\x12\x12\n\x04task\x18\x02\x20\x01(\tR\x04task\x12\x14\n\x05clazz\x18\
    \x03\x20\x01(\tR\x05clazz\"B\n\x0cTaskResponse\x12\x18\n\x07success\x18\
    \x01\x20\x01(\x08R\x07success\x12\x18\n\x07message\x18\x02\x20\x01(\tR\
    \x07message\"\xd9\x02\n\x18GetFullGraphRequestProto\x12\x1a\n\x08vertexI\
    d\x18\x01\x20\x01(\tR\x08vertexId\x12K\n\x05steps\x18\x02\x20\x03(\x0b25\
    .com.tencent.easygraph.graphrpc.proto.StepConfigProtoR\x05steps\x12\x1e\
    \n\nfilterName\x18\x03\x20\x01(\tR\nfilterName\x12\x1c\n\tfilterDef\x18\
    \x04\x20\x01(\tR\tfilterDef\x12\x20\n\x0bresultLimit\x18\x05\x20\x01(\
    \x05R\x0bresultLimit\x12.\n\x12execeptResultLimit\x18\x06\x20\x01(\x05R\
    \x12execeptResultLimit\x12&\n\x0epushDownFilter\x18\x07\x20\x01(\x08R\
    \x0epushDownFilter\x12\x1c\n\tgraphName\x18\x08\x20\x01(\tR\tgraphName\"\
    \xc5\x01\n\x19GetFullGraphResponseProto\x12\x12\n\x04code\x18\x01\x20\
    \x01(\x05R\x04code\x12M\n\x08vertices\x18\x02\x20\x03(\x0b21.com.tencent\
    .easygraph.graphrpc.proto.FrontVertexR\x08vertices\x12E\n\x05edges\x18\
    \x03\x20\x03(\x0b2/.com.tencent.easygraph.graphrpc.proto.FrontEdgeR\x05e\
    dges\"\xc5\x01\n\x0fStepConfigProto\x12Z\n\x0clabelConfigs\x18\x01\x20\
    \x03(\x0b26.com.tencent.easygraph.graphrpc.proto.LabelConfigProtoR\x0cla\
    belConfigs\x12\x1c\n\tdirection\x18\x02\x20\x01(\x05R\tdirection\x12\x14\
    \n\x05limit\x18\x03\x20\x01(\x05R\x05limit\x12\"\n\x0cdistinctHint\x18\
    \x04\x20\x01(\x08R\x0cdistinctHint\"\x88\x01\n\x10LabelConfigProto\x12\
    \x1c\n\tlabelName\x18\x01\x20\x01(\tR\tlabelName\x12\x1c\n\tdirection\
    \x18\x02\x20\x01(\x05R\tdirection\x12\x14\n\x05limit\x18\x03\x20\x01(\
    \x05R\x05limit\x12\"\n\x0cdistinctHint\x18\x04\x20\x01(\x08R\x0cdistinct\
    Hint\"\x9b\x01\n\x12SampleRequestProto\x12\x1a\n\x08vertexId\x18\x01\x20\
    \x01(\tR\x08vertexId\x12K\n\x05steps\x18\x02\x20\x03(\x0b25.com.tencent.\
    easygraph.graphrpc.proto.StepConfigProtoR\x05steps\x12\x1c\n\tgraphName\
    \x18\x03\x20\x01(\tR\tgraphName\"\xbf\x01\n\x13SampleResponseProto\x12\
    \x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12M\n\x08vertices\x18\x02\
    \x20\x03(\x0b21.com.tencent.easygraph.graphrpc.proto.FrontVertexR\x08ver\
    tices\x12E\n\x05edges\x18\x03\x20\x03(\x0b2/.com.tencent.easygraph.graph\
    rpc.proto.FrontEdgeR\x05edges2\x80\t\n\x0fGraphRpcService\x12|\n\taddVer\
    tex\x126.com.tencent.easygraph.graphrpc.proto.AddVertexRequest\x1a7.com.\
    tencent.easygraph.graphrpc.proto.AddVertexResponse\x12\x7f\n\ndropVertex\
    \x127.com.tencent.easygraph.graphrpc.proto.DropVertexRequest\x1a8.com.te\
    ncent.easygraph.graphrpc.proto.DropVertexResponse\x12v\n\x07addEdge\x124\
    .com.tencent.easygraph.graphrpc.proto.AddEdgeRequest\x1a5.com.tencent.ea\
    sygraph.graphrpc.proto.AddEdgeResponse\x12y\n\x08dropEdge\x125.com.tence\
    nt.easygraph.graphrpc.proto.DropEdgeRequest\x1a6.com.tencent.easygraph.g\
    raphrpc.proto.DropEdgeResponse\x12\x85\x01\n\x0cgetGraphMeta\x129.com.te\
    ncent.easygraph.graphrpc.proto.GetGraphMetaRequest\x1a:.com.tencent.easy\
    graph.graphrpc.proto.GetGraphMetaResponse\x12o\n\x06doTask\x121.com.tenc\
    ent.easygraph.graphrpc.proto.TaskRequest\x1a2.com.tencent.easygraph.grap\
    hrpc.proto.TaskResponse\x12m\n\x04auth\x121.com.tencent.easygraph.graphr\
    pc.proto.AuthRequest\x1a2.com.tencent.easygraph.graphrpc.proto.AuthRespo\
    nse\x12\x91\x01\n\x0cgetFullGraph\x12>.com.tencent.easygraph.graphrpc.pr\
    oto.GetFullGraphRequestProto\x1a?.com.tencent.easygraph.graphrpc.proto.G\
    etFullGraphResponseProto0\x01\x12\x7f\n\x06sample\x128.com.tencent.easyg\
    raph.graphrpc.proto.SampleRequestProto\x1a9.com.tencent.easygraph.graphr\
    pc.proto.SampleResponseProto0\x01B\x02P\x01J\xb9+\n\x07\x12\x05\0\0\x94\
    \x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\x02\x03\0\x12\x03\x02\0\
    \x14\n\x08\n\x01\x02\x12\x03\x03\0-\n\x08\n\x01\x08\x12\x03\x05\0\"\n\t\
    \n\x02\x08\n\x12\x03\x05\0\"\n\n\n\x02\x04\0\x12\x04\x07\0\x0b\x01\n\n\n\
    \x03\x04\0\x01\x12\x03\x07\x08\x17\n\x0b\n\x04\x04\0\x02\0\x12\x03\x08\
    \x02\x15\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x08\x02\x07\x19\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03\x08\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x08\t\x10\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x08\x13\x14\n\x0b\n\x04\
    \x04\0\x02\x01\x12\x03\t\x02\x12\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\t\
    \x02\x08\x15\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\t\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x01\x01\x12\x03\t\t\r\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\t\
    \x10\x11\n\x0b\n\x04\x04\0\x02\x02\x12\x03\n\x02\x16\n\r\n\x05\x04\0\x02\
    \x02\x04\x12\x04\n\x02\t\x12\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\n\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\n\t\x11\n\x0c\n\x05\x04\0\x02\
    \x02\x03\x12\x03\n\x14\x15\n\n\n\x02\x04\x01\x12\x04\r\0\x11\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03\r\x08\x13\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x0e\
    \x02\x13\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x0e\x02\r\x15\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03\x0e\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03\x0e\t\x0e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0e\x11\x12\n\x0b\n\
    \x04\x04\x01\x02\x01\x12\x03\x0f\x02\x10\n\r\n\x05\x04\x01\x02\x01\x04\
    \x12\x04\x0f\x02\x0e\x13\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x0f\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0f\t\x0b\n\x0c\n\x05\x04\
    \x01\x02\x01\x03\x12\x03\x0f\x0e\x0f\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\
    \x10\x02%\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\x10\x02\x0f\x10\n\x0c\n\
    \x05\x04\x01\x02\x02\x06\x12\x03\x10\x02\x15\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x03\x10\x16\x20\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x10#$\n\
    \n\n\x02\x04\x02\x12\x04\x13\0\x19\x01\n\n\n\x03\x04\x02\x01\x12\x03\x13\
    \x08\x11\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x14\x02\x13\n\r\n\x05\x04\x02\
    \x02\0\x04\x12\x04\x14\x02\x13\x13\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\
    \x14\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x14\t\x0e\n\x0c\n\x05\
    \x04\x02\x02\0\x03\x12\x03\x14\x11\x12\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03\x15\x02\x13\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\x15\x02\x14\x13\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x15\x02\x08\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03\x15\t\x0e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\
    \x15\x11\x12\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x16\x02\x13\n\r\n\x05\
    \x04\x02\x02\x02\x04\x12\x04\x16\x02\x15\x13\n\x0c\n\x05\x04\x02\x02\x02\
    \x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x16\t\
    \x0e\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\x16\x11\x12\n\x0b\n\x04\x04\
    \x02\x02\x03\x12\x03\x17\x02\x16\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\
    \x17\x02\x16\x13\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03\x17\x02\x07\n\
    \x0c\n\x05\x04\x02\x02\x03\x01\x12\x03\x17\x08\x11\n\x0c\n\x05\x04\x02\
    \x02\x03\x03\x12\x03\x17\x14\x15\n\x0b\n\x04\x04\x02\x02\x04\x12\x03\x18\
    \x02%\n\r\n\x05\x04\x02\x02\x04\x04\x12\x04\x18\x02\x17\x16\n\x0c\n\x05\
    \x04\x02\x02\x04\x06\x12\x03\x18\x02\x15\n\x0c\n\x05\x04\x02\x02\x04\x01\
    \x12\x03\x18\x16\x20\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03\x18#$\n\n\n\
    \x02\x04\x03\x12\x04\x1b\0\x1e\x01\n\n\n\x03\x04\x03\x01\x12\x03\x1b\x08\
    \x18\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x1c\x02\x13\n\r\n\x05\x04\x03\x02\
    \0\x04\x12\x04\x1c\x02\x1b\x19\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x1c\
    \x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x1c\t\x0e\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03\x1c\x11\x12\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\
    \x1d\x02!\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03\x1d\x02\n\n\x0c\n\x05\
    \x04\x03\x02\x01\x06\x12\x03\x1d\x0b\x16\n\x0c\n\x05\x04\x03\x02\x01\x01\
    \x12\x03\x1d\x17\x1c\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x1d\x1f\x20\
    \n\n\n\x02\x04\x04\x12\x04\x20\0#\x01\n\n\n\x03\x04\x04\x01\x12\x03\x20\
    \x08\x19\n\x0b\n\x04\x04\x04\x02\0\x12\x03!\x02\x11\n\r\n\x05\x04\x04\
    \x02\0\x04\x12\x04!\x02\x20\x1a\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03!\
    \x02\x07\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03!\x08\x0c\n\x0c\n\x05\x04\
    \x04\x02\0\x03\x12\x03!\x0f\x10\n\x0b\n\x04\x04\x04\x02\x01\x12\x03\"\
    \x02\x15\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\"\x02!\x11\n\x0c\n\x05\
    \x04\x04\x02\x01\x05\x12\x03\"\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\
    \x12\x03\"\t\x10\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03\"\x13\x14\n\n\n\
    \x02\x04\x05\x12\x04%\0(\x01\n\n\n\x03\x04\x05\x01\x12\x03%\x08\x19\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x03&\x02\x13\n\r\n\x05\x04\x05\x02\0\x04\
    \x12\x04&\x02%\x1a\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03&\x02\x08\n\x0c\
    \n\x05\x04\x05\x02\0\x01\x12\x03&\t\x0e\n\x0c\n\x05\x04\x05\x02\0\x03\
    \x12\x03&\x11\x12\n\x0b\n\x04\x04\x05\x02\x01\x12\x03'\x02!\n\x0c\n\x05\
    \x04\x05\x02\x01\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\
    \x03'\x0b\x16\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03'\x17\x1c\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x03'\x1f\x20\n\n\n\x02\x04\x06\x12\x04*\0-\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03*\x08\x1a\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x03+\x02\x11\n\r\n\x05\x04\x06\x02\0\x04\x12\x04+\x02*\x1b\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x03+\x02\x07\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03+\x08\x0c\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03+\x0f\x10\n\x0b\n\
    \x04\x04\x06\x02\x01\x12\x03,\x02\x15\n\r\n\x05\x04\x06\x02\x01\x04\x12\
    \x04,\x02+\x11\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03,\x02\x08\n\x0c\n\
    \x05\x04\x06\x02\x01\x01\x12\x03,\t\x10\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03,\x13\x14\n\n\n\x02\x04\x07\x12\x04/\02\x01\n\n\n\x03\x04\x07\
    \x01\x12\x03/\x08\x16\n\x0b\n\x04\x04\x07\x02\0\x12\x030\x02\x13\n\r\n\
    \x05\x04\x07\x02\0\x04\x12\x040\x02/\x17\n\x0c\n\x05\x04\x07\x02\0\x05\
    \x12\x030\x02\x08\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x030\t\x0e\n\x0c\n\
    \x05\x04\x07\x02\0\x03\x12\x030\x11\x12\n\x0b\n\x04\x04\x07\x02\x01\x12\
    \x031\x02\x1f\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x031\x02\n\n\x0c\n\x05\
    \x04\x07\x02\x01\x06\x12\x031\x0b\x14\n\x0c\n\x05\x04\x07\x02\x01\x01\
    \x12\x031\x15\x1a\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x031\x1d\x1e\n\n\n\
    \x02\x04\x08\x12\x044\07\x01\n\n\n\x03\x04\x08\x01\x12\x034\x08\x17\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x035\x02\x11\n\r\n\x05\x04\x08\x02\0\x04\
    \x12\x045\x024\x18\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x035\x02\x07\n\x0c\
    \n\x05\x04\x08\x02\0\x01\x12\x035\x08\x0c\n\x0c\n\x05\x04\x08\x02\0\x03\
    \x12\x035\x0f\x10\n\x0b\n\x04\x04\x08\x02\x01\x12\x036\x02\x15\n\r\n\x05\
    \x04\x08\x02\x01\x04\x12\x046\x025\x11\n\x0c\n\x05\x04\x08\x02\x01\x05\
    \x12\x036\x02\x08\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x036\t\x10\n\x0c\n\
    \x05\x04\x08\x02\x01\x03\x12\x036\x13\x14\n\n\n\x02\x04\t\x12\x049\0<\
    \x01\n\n\n\x03\x04\t\x01\x12\x039\x08\x17\n\x0b\n\x04\x04\t\x02\0\x12\
    \x03:\x02\x13\n\r\n\x05\x04\t\x02\0\x04\x12\x04:\x029\x18\n\x0c\n\x05\
    \x04\t\x02\0\x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03:\t\
    \x0e\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03:\x11\x12\n\x0b\n\x04\x04\t\x02\
    \x01\x12\x03;\x02\x1f\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03;\x02\n\n\x0c\
    \n\x05\x04\t\x02\x01\x06\x12\x03;\x0b\x14\n\x0c\n\x05\x04\t\x02\x01\x01\
    \x12\x03;\x15\x1a\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03;\x1d\x1e\n\n\n\
    \x02\x04\n\x12\x04>\0A\x01\n\n\n\x03\x04\n\x01\x12\x03>\x08\x18\n\x0b\n\
    \x04\x04\n\x02\0\x12\x03?\x02\x11\n\r\n\x05\x04\n\x02\0\x04\x12\x04?\x02\
    >\x19\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03?\x02\x07\n\x0c\n\x05\x04\n\x02\
    \0\x01\x12\x03?\x08\x0c\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03?\x0f\x10\n\
    \x0b\n\x04\x04\n\x02\x01\x12\x03@\x02\x15\n\r\n\x05\x04\n\x02\x01\x04\
    \x12\x04@\x02?\x11\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03@\x02\x08\n\x0c\
    \n\x05\x04\n\x02\x01\x01\x12\x03@\t\x10\n\x0c\n\x05\x04\n\x02\x01\x03\
    \x12\x03@\x13\x14\n\n\n\x02\x04\x0b\x12\x04C\0E\x01\n\n\n\x03\x04\x0b\
    \x01\x12\x03C\x08\x1b\n\x0b\n\x04\x04\x0b\x02\0\x12\x03D\x02\x12\n\r\n\
    \x05\x04\x0b\x02\0\x04\x12\x04D\x02C\x1d\n\x0c\n\x05\x04\x0b\x02\0\x05\
    \x12\x03D\x02\x08\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03D\t\r\n\x0c\n\x05\
    \x04\x0b\x02\0\x03\x12\x03D\x10\x11\n\n\n\x02\x04\x0c\x12\x04G\0J\x01\n\
    \n\n\x03\x04\x0c\x01\x12\x03G\x08\x1c\n\x0b\n\x04\x04\x0c\x02\0\x12\x03H\
    \x02\x11\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04H\x02G\x1e\n\x0c\n\x05\x04\
    \x0c\x02\0\x05\x12\x03H\x02\x07\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03H\
    \x08\x0c\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03H\x0f\x10\n\x0b\n\x04\x04\
    \x0c\x02\x01\x12\x03I\x021\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04I\x02H\
    \x11\n\x0c\n\x05\x04\x0c\x02\x01\x06\x12\x03I\x02'\n\x0c\n\x05\x04\x0c\
    \x02\x01\x01\x12\x03I(,\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03I/0\n\n\n\
    \x02\x04\r\x12\x04L\0N\x01\n\n\n\x03\x04\r\x01\x12\x03L\x08\x13\n\x0b\n\
    \x04\x04\r\x02\0\x12\x03M\x02\x12\n\r\n\x05\x04\r\x02\0\x04\x12\x04M\x02\
    L\x15\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03M\x02\x08\n\x0c\n\x05\x04\r\x02\
    \0\x01\x12\x03M\t\r\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03M\x10\x11\n\n\n\
    \x02\x04\x0e\x12\x04P\0R\x01\n\n\n\x03\x04\x0e\x01\x12\x03P\x08\x14\n\
    \x0b\n\x04\x04\x0e\x02\0\x12\x03Q\x02\x13\n\r\n\x05\x04\x0e\x02\0\x04\
    \x12\x04Q\x02P\x16\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03Q\x02\x06\n\x0c\
    \n\x05\x04\x0e\x02\0\x01\x12\x03Q\x07\x0e\n\x0c\n\x05\x04\x0e\x02\0\x03\
    \x12\x03Q\x11\x12\n\n\n\x02\x04\x0f\x12\x04T\0X\x01\n\n\n\x03\x04\x0f\
    \x01\x12\x03T\x08\x13\n\x0b\n\x04\x04\x0f\x02\0\x12\x03U\x02\x13\n\r\n\
    \x05\x04\x0f\x02\0\x04\x12\x04U\x02T\x14\n\x0c\n\x05\x04\x0f\x02\0\x05\
    \x12\x03U\x02\x08\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03U\t\x0e\n\x0c\n\
    \x05\x04\x0f\x02\0\x03\x12\x03U\x11\x12\n\x0b\n\x04\x04\x0f\x02\x01\x12\
    \x03V\x02\x12\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04V\x02U\x13\n\x0c\n\
    \x05\x04\x0f\x02\x01\x05\x12\x03V\x02\x08\n\x0c\n\x05\x04\x0f\x02\x01\
    \x01\x12\x03V\t\r\n\x0c\n\x05\x04\x0f\x02\x01\x03\x12\x03V\x10\x11\n\x0b\
    \n\x04\x04\x0f\x02\x02\x12\x03W\x02\x13\n\r\n\x05\x04\x0f\x02\x02\x04\
    \x12\x04W\x02V\x12\n\x0c\n\x05\x04\x0f\x02\x02\x05\x12\x03W\x02\x08\n\
    \x0c\n\x05\x04\x0f\x02\x02\x01\x12\x03W\t\x0e\n\x0c\n\x05\x04\x0f\x02\
    \x02\x03\x12\x03W\x11\x12\n\n\n\x02\x04\x10\x12\x04Z\0]\x01\n\n\n\x03\
    \x04\x10\x01\x12\x03Z\x08\x14\n\x0b\n\x04\x04\x10\x02\0\x12\x03[\x02\x13\
    \n\r\n\x05\x04\x10\x02\0\x04\x12\x04[\x02Z\x16\n\x0c\n\x05\x04\x10\x02\0\
    \x05\x12\x03[\x02\x06\n\x0c\n\x05\x04\x10\x02\0\x01\x12\x03[\x07\x0e\n\
    \x0c\n\x05\x04\x10\x02\0\x03\x12\x03[\x11\x12\n\x0b\n\x04\x04\x10\x02\
    \x01\x12\x03\\\x02\x15\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\\\x02[\x13\
    \n\x0c\n\x05\x04\x10\x02\x01\x05\x12\x03\\\x02\x08\n\x0c\n\x05\x04\x10\
    \x02\x01\x01\x12\x03\\\t\x10\n\x0c\n\x05\x04\x10\x02\x01\x03\x12\x03\\\
    \x13\x14\n\n\n\x02\x04\x11\x12\x04_\0h\x01\n\n\n\x03\x04\x11\x01\x12\x03\
    _\x08\x20\n\x0b\n\x04\x04\x11\x02\0\x12\x03`\x02\x16\n\r\n\x05\x04\x11\
    \x02\0\x04\x12\x04`\x02_\"\n\x0c\n\x05\x04\x11\x02\0\x05\x12\x03`\x02\
    \x08\n\x0c\n\x05\x04\x11\x02\0\x01\x12\x03`\t\x11\n\x0c\n\x05\x04\x11\
    \x02\0\x03\x12\x03`\x14\x15\n\x0b\n\x04\x04\x11\x02\x01\x12\x03a\x02%\n\
    \x0c\n\x05\x04\x11\x02\x01\x04\x12\x03a\x02\n\n\x0c\n\x05\x04\x11\x02\
    \x01\x06\x12\x03a\x0b\x1a\n\x0c\n\x05\x04\x11\x02\x01\x01\x12\x03a\x1b\
    \x20\n\x0c\n\x05\x04\x11\x02\x01\x03\x12\x03a#$\n\x0b\n\x04\x04\x11\x02\
    \x02\x12\x03b\x02\x18\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04b\x02a%\n\x0c\
    \n\x05\x04\x11\x02\x02\x05\x12\x03b\x02\x08\n\x0c\n\x05\x04\x11\x02\x02\
    \x01\x12\x03b\t\x13\n\x0c\n\x05\x04\x11\x02\x02\x03\x12\x03b\x16\x17\n\
    \x0b\n\x04\x04\x11\x02\x03\x12\x03c\x02\x17\n\r\n\x05\x04\x11\x02\x03\
    \x04\x12\x04c\x02b\x18\n\x0c\n\x05\x04\x11\x02\x03\x05\x12\x03c\x02\x08\
    \n\x0c\n\x05\x04\x11\x02\x03\x01\x12\x03c\t\x12\n\x0c\n\x05\x04\x11\x02\
    \x03\x03\x12\x03c\x15\x16\n\x0b\n\x04\x04\x11\x02\x04\x12\x03d\x02\x18\n\
    \r\n\x05\x04\x11\x02\x04\x04\x12\x04d\x02c\x17\n\x0c\n\x05\x04\x11\x02\
    \x04\x05\x12\x03d\x02\x07\n\x0c\n\x05\x04\x11\x02\x04\x01\x12\x03d\x08\
    \x13\n\x0c\n\x05\x04\x11\x02\x04\x03\x12\x03d\x16\x17\n\x0b\n\x04\x04\
    \x11\x02\x05\x12\x03e\x02\x1f\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04e\x02\
    d\x18\n\x0c\n\x05\x04\x11\x02\x05\x05\x12\x03e\x02\x07\n\x0c\n\x05\x04\
    \x11\x02\x05\x01\x12\x03e\x08\x1a\n\x0c\n\x05\x04\x11\x02\x05\x03\x12\
    \x03e\x1d\x1e\n\x0b\n\x04\x04\x11\x02\x06\x12\x03f\x02\x1a\n\r\n\x05\x04\
    \x11\x02\x06\x04\x12\x04f\x02e\x1f\n\x0c\n\x05\x04\x11\x02\x06\x05\x12\
    \x03f\x02\x06\n\x0c\n\x05\x04\x11\x02\x06\x01\x12\x03f\x07\x15\n\x0c\n\
    \x05\x04\x11\x02\x06\x03\x12\x03f\x18\x19\n\x0b\n\x04\x04\x11\x02\x07\
    \x12\x03g\x02\x17\n\r\n\x05\x04\x11\x02\x07\x04\x12\x04g\x02f\x1a\n\x0c\
    \n\x05\x04\x11\x02\x07\x05\x12\x03g\x02\x08\n\x0c\n\x05\x04\x11\x02\x07\
    \x01\x12\x03g\t\x12\n\x0c\n\x05\x04\x11\x02\x07\x03\x12\x03g\x15\x16\n\n\
    \n\x02\x04\x12\x12\x04j\0n\x01\n\n\n\x03\x04\x12\x01\x12\x03j\x08!\n\x0b\
    \n\x04\x04\x12\x02\0\x12\x03k\x02\x11\n\r\n\x05\x04\x12\x02\0\x04\x12\
    \x04k\x02j#\n\x0c\n\x05\x04\x12\x02\0\x05\x12\x03k\x02\x07\n\x0c\n\x05\
    \x04\x12\x02\0\x01\x12\x03k\x08\x0c\n\x0c\n\x05\x04\x12\x02\0\x03\x12\
    \x03k\x0f\x10\n\x0b\n\x04\x04\x12\x02\x01\x12\x03l\x02$\n\x0c\n\x05\x04\
    \x12\x02\x01\x04\x12\x03l\x02\n\n\x0c\n\x05\x04\x12\x02\x01\x06\x12\x03l\
    \x0b\x16\n\x0c\n\x05\x04\x12\x02\x01\x01\x12\x03l\x17\x1f\n\x0c\n\x05\
    \x04\x12\x02\x01\x03\x12\x03l\"#\n\x0b\n\x04\x04\x12\x02\x02\x12\x03m\
    \x02\x1f\n\x0c\n\x05\x04\x12\x02\x02\x04\x12\x03m\x02\n\n\x0c\n\x05\x04\
    \x12\x02\x02\x06\x12\x03m\x0b\x14\n\x0c\n\x05\x04\x12\x02\x02\x01\x12\
    \x03m\x15\x1a\n\x0c\n\x05\x04\x12\x02\x02\x03\x12\x03m\x1d\x1e\n\n\n\x02\
    \x04\x13\x12\x04p\0u\x01\n\n\n\x03\x04\x13\x01\x12\x03p\x08\x17\n\x0b\n\
    \x04\x04\x13\x02\0\x12\x03q\x02-\n\x0c\n\x05\x04\x13\x02\0\x04\x12\x03q\
    \x02\n\n\x0c\n\x05\x04\x13\x02\0\x06\x12\x03q\x0b\x1b\n\x0c\n\x05\x04\
    \x13\x02\0\x01\x12\x03q\x1c(\n\x0c\n\x05\x04\x13\x02\0\x03\x12\x03q+,\n\
    \x0b\n\x04\x04\x13\x02\x01\x12\x03r\x02\x16\n\r\n\x05\x04\x13\x02\x01\
    \x04\x12\x04r\x02q-\n\x0c\n\x05\x04\x13\x02\x01\x05\x12\x03r\x02\x07\n\
    \x0c\n\x05\x04\x13\x02\x01\x01\x12\x03r\x08\x11\n\x0c\n\x05\x04\x13\x02\
    \x01\x03\x12\x03r\x14\x15\n\x0b\n\x04\x04\x13\x02\x02\x12\x03s\x02\x12\n\
    \r\n\x05\x04\x13\x02\x02\x04\x12\x04s\x02r\x16\n\x0c\n\x05\x04\x13\x02\
    \x02\x05\x12\x03s\x02\x07\n\x0c\n\x05\x04\x13\x02\x02\x01\x12\x03s\x08\r\
    \n\x0c\n\x05\x04\x13\x02\x02\x03\x12\x03s\x10\x11\n\x0b\n\x04\x04\x13\
    \x02\x03\x12\x03t\x02\x18\n\r\n\x05\x04\x13\x02\x03\x04\x12\x04t\x02s\
    \x12\n\x0c\n\x05\x04\x13\x02\x03\x05\x12\x03t\x02\x06\n\x0c\n\x05\x04\
    \x13\x02\x03\x01\x12\x03t\x07\x13\n\x0c\n\x05\x04\x13\x02\x03\x03\x12\
    \x03t\x16\x17\n\n\n\x02\x04\x14\x12\x04w\0|\x01\n\n\n\x03\x04\x14\x01\
    \x12\x03w\x08\x18\n\x0b\n\x04\x04\x14\x02\0\x12\x03x\x02\x17\n\r\n\x05\
    \x04\x14\x02\0\x04\x12\x04x\x02w\x1a\n\x0c\n\x05\x04\x14\x02\0\x05\x12\
    \x03x\x02\x08\n\x0c\n\x05\x04\x14\x02\0\x01\x12\x03x\t\x12\n\x0c\n\x05\
    \x04\x14\x02\0\x03\x12\x03x\x15\x16\n\x0b\n\x04\x04\x14\x02\x01\x12\x03y\
    \x02\x16\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04y\x02x\x17\n\x0c\n\x05\x04\
    \x14\x02\x01\x05\x12\x03y\x02\x07\n\x0c\n\x05\x04\x14\x02\x01\x01\x12\
    \x03y\x08\x11\n\x0c\n\x05\x04\x14\x02\x01\x03\x12\x03y\x14\x15\n\x0b\n\
    \x04\x04\x14\x02\x02\x12\x03z\x02\x12\n\r\n\x05\x04\x14\x02\x02\x04\x12\
    \x04z\x02y\x16\n\x0c\n\x05\x04\x14\x02\x02\x05\x12\x03z\x02\x07\n\x0c\n\
    \x05\x04\x14\x02\x02\x01\x12\x03z\x08\r\n\x0c\n\x05\x04\x14\x02\x02\x03\
    \x12\x03z\x10\x11\n\x0b\n\x04\x04\x14\x02\x03\x12\x03{\x02\x18\n\r\n\x05\
    \x04\x14\x02\x03\x04\x12\x04{\x02z\x12\n\x0c\n\x05\x04\x14\x02\x03\x05\
    \x12\x03{\x02\x06\n\x0c\n\x05\x04\x14\x02\x03\x01\x12\x03{\x07\x13\n\x0c\
    \n\x05\x04\x14\x02\x03\x03\x12\x03{\x16\x17\n\x0b\n\x02\x04\x15\x12\x05~\
    \0\x82\x01\x01\n\n\n\x03\x04\x15\x01\x12\x03~\x08\x1a\n\x0b\n\x04\x04\
    \x15\x02\0\x12\x03\x7f\x02\x16\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\x7f\
    \x02~\x1c\n\x0c\n\x05\x04\x15\x02\0\x05\x12\x03\x7f\x02\x08\n\x0c\n\x05\
    \x04\x15\x02\0\x01\x12\x03\x7f\t\x11\n\x0c\n\x05\x04\x15\x02\0\x03\x12\
    \x03\x7f\x14\x15\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x80\x01\x02%\n\r\n\
    \x05\x04\x15\x02\x01\x04\x12\x04\x80\x01\x02\n\n\r\n\x05\x04\x15\x02\x01\
    \x06\x12\x04\x80\x01\x0b\x1a\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x80\
    \x01\x1b\x20\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x80\x01#$\n\x0c\n\x04\
    \x04\x15\x02\x02\x12\x04\x81\x01\x02\x17\n\x0f\n\x05\x04\x15\x02\x02\x04\
    \x12\x06\x81\x01\x02\x80\x01%\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x81\
    \x01\x02\x08\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x81\x01\t\x12\n\r\n\
    \x05\x04\x15\x02\x02\x03\x12\x04\x81\x01\x15\x16\n\x0c\n\x02\x04\x16\x12\
    \x06\x84\x01\0\x88\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x84\x01\x08\
    \x1b\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x85\x01\x02\x11\n\x0f\n\x05\x04\
    \x16\x02\0\x04\x12\x06\x85\x01\x02\x84\x01\x1d\n\r\n\x05\x04\x16\x02\0\
    \x05\x12\x04\x85\x01\x02\x07\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x85\x01\
    \x08\x0c\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x85\x01\x0f\x10\n\x0c\n\x04\
    \x04\x16\x02\x01\x12\x04\x86\x01\x02$\n\r\n\x05\x04\x16\x02\x01\x04\x12\
    \x04\x86\x01\x02\n\n\r\n\x05\x04\x16\x02\x01\x06\x12\x04\x86\x01\x0b\x16\
    \n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x86\x01\x17\x1f\n\r\n\x05\x04\x16\
    \x02\x01\x03\x12\x04\x86\x01\"#\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\x87\
    \x01\x02\x1f\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\x87\x01\x02\n\n\r\n\
    \x05\x04\x16\x02\x02\x06\x12\x04\x87\x01\x0b\x14\n\r\n\x05\x04\x16\x02\
    \x02\x01\x12\x04\x87\x01\x15\x1a\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\
    \x87\x01\x1d\x1e\n\x0c\n\x02\x06\0\x12\x06\x8a\x01\0\x94\x01\x01\n\x0b\n\
    \x03\x06\0\x01\x12\x04\x8a\x01\x08\x17\n\x0c\n\x04\x06\0\x02\0\x12\x04\
    \x8b\x01\x02>\n\r\n\x05\x06\0\x02\0\x01\x12\x04\x8b\x01\x06\x0f\n\r\n\
    \x05\x06\0\x02\0\x02\x12\x04\x8b\x01\x10\x20\n\r\n\x05\x06\0\x02\0\x03\
    \x12\x04\x8b\x01+<\n\x0c\n\x04\x06\0\x02\x01\x12\x04\x8c\x01\x02A\n\r\n\
    \x05\x06\0\x02\x01\x01\x12\x04\x8c\x01\x06\x10\n\r\n\x05\x06\0\x02\x01\
    \x02\x12\x04\x8c\x01\x11\"\n\r\n\x05\x06\0\x02\x01\x03\x12\x04\x8c\x01-?\
    \n\x0c\n\x04\x06\0\x02\x02\x12\x04\x8d\x01\x028\n\r\n\x05\x06\0\x02\x02\
    \x01\x12\x04\x8d\x01\x06\r\n\r\n\x05\x06\0\x02\x02\x02\x12\x04\x8d\x01\
    \x0e\x1c\n\r\n\x05\x06\0\x02\x02\x03\x12\x04\x8d\x01'6\n\x0c\n\x04\x06\0\
    \x02\x03\x12\x04\x8e\x01\x02;\n\r\n\x05\x06\0\x02\x03\x01\x12\x04\x8e\
    \x01\x06\x0e\n\r\n\x05\x06\0\x02\x03\x02\x12\x04\x8e\x01\x0f\x1e\n\r\n\
    \x05\x06\0\x02\x03\x03\x12\x04\x8e\x01)9\n\x0c\n\x04\x06\0\x02\x04\x12\
    \x04\x8f\x01\x02G\n\r\n\x05\x06\0\x02\x04\x01\x12\x04\x8f\x01\x06\x12\n\
    \r\n\x05\x06\0\x02\x04\x02\x12\x04\x8f\x01\x13&\n\r\n\x05\x06\0\x02\x04\
    \x03\x12\x04\x8f\x011E\n\x0c\n\x04\x06\0\x02\x05\x12\x04\x90\x01\x021\n\
    \r\n\x05\x06\0\x02\x05\x01\x12\x04\x90\x01\x06\x0c\n\r\n\x05\x06\0\x02\
    \x05\x02\x12\x04\x90\x01\r\x18\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\x90\
    \x01#/\n\x0c\n\x04\x06\0\x02\x06\x12\x04\x91\x01\x02/\n\r\n\x05\x06\0\
    \x02\x06\x01\x12\x04\x91\x01\x06\n\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\
    \x91\x01\x0b\x16\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\x91\x01!-\n\x0c\n\
    \x04\x06\0\x02\x07\x12\x04\x92\x01\x02X\n\r\n\x05\x06\0\x02\x07\x01\x12\
    \x04\x92\x01\x06\x12\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\x92\x01\x13+\n\
    \r\n\x05\x06\0\x02\x07\x06\x12\x04\x92\x016<\n\r\n\x05\x06\0\x02\x07\x03\
    \x12\x04\x92\x01=V\n\x0c\n\x04\x06\0\x02\x08\x12\x04\x93\x01\x02F\n\r\n\
    \x05\x06\0\x02\x08\x01\x12\x04\x93\x01\x06\x0c\n\r\n\x05\x06\0\x02\x08\
    \x02\x12\x04\x93\x01\r\x1f\n\r\n\x05\x06\0\x02\x08\x06\x12\x04\x93\x01*0\
    \n\r\n\x05\x06\0\x02\x08\x03\x12\x04\x93\x011Db\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::meta::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(EasyGraphConfig::generated_message_descriptor_data());
            messages.push(FrontVertex::generated_message_descriptor_data());
            messages.push(FrontEdge::generated_message_descriptor_data());
            messages.push(AddVertexRequest::generated_message_descriptor_data());
            messages.push(AddVertexResponse::generated_message_descriptor_data());
            messages.push(DropVertexRequest::generated_message_descriptor_data());
            messages.push(DropVertexResponse::generated_message_descriptor_data());
            messages.push(AddEdgeRequest::generated_message_descriptor_data());
            messages.push(AddEdgeResponse::generated_message_descriptor_data());
            messages.push(DropEdgeRequest::generated_message_descriptor_data());
            messages.push(DropEdgeResponse::generated_message_descriptor_data());
            messages.push(GetGraphMetaRequest::generated_message_descriptor_data());
            messages.push(GetGraphMetaResponse::generated_message_descriptor_data());
            messages.push(AuthRequest::generated_message_descriptor_data());
            messages.push(AuthResponse::generated_message_descriptor_data());
            messages.push(TaskRequest::generated_message_descriptor_data());
            messages.push(TaskResponse::generated_message_descriptor_data());
            messages.push(GetFullGraphRequestProto::generated_message_descriptor_data());
            messages.push(GetFullGraphResponseProto::generated_message_descriptor_data());
            messages.push(StepConfigProto::generated_message_descriptor_data());
            messages.push(LabelConfigProto::generated_message_descriptor_data());
            messages.push(SampleRequestProto::generated_message_descriptor_data());
            messages.push(SampleResponseProto::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
