// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `meta.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

/// common data structure
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.Header)
pub struct Header {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.Header.success)
    pub success: bool,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.Header.code)
    pub code: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.Header.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.Header.trace_id)
    pub trace_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.Header.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &Header| { &m.success },
            |m: &mut Header| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Header| { &m.code },
            |m: &mut Header| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &Header| { &m.msg },
            |m: &mut Header| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &Header| { &m.trace_id },
            |m: &mut Header| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Header>(
            "Header",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Header {
    const NAME: &'static str = "Header";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.code = is.read_int32()?;
                },
                26 => {
                    self.msg = is.read_string()?;
                },
                32 => {
                    self.trace_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.code);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.msg);
        }
        if self.trace_id != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.code != 0 {
            os.write_int32(2, self.code)?;
        }
        if !self.msg.is_empty() {
            os.write_string(3, &self.msg)?;
        }
        if self.trace_id != 0 {
            os.write_int64(4, self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Header {
        Header::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.code = 0;
        self.msg.clear();
        self.trace_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Header {
        static instance: Header = Header {
            success: false,
            code: 0,
            msg: ::std::string::String::new(),
            trace_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Header {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Header").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.MetaDesc)
pub struct MetaDesc {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.MetaDesc.type)
    pub type_: ::protobuf::EnumOrUnknown<MetaType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.MetaDesc.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.MetaDesc.meta)
    pub meta: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.MetaDesc.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetaDesc {
    fn default() -> &'a MetaDesc {
        <MetaDesc as ::protobuf::Message>::default_instance()
    }
}

impl MetaDesc {
    pub fn new() -> MetaDesc {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MetaDesc| { &m.type_ },
            |m: &mut MetaDesc| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &MetaDesc| { &m.key },
            |m: &mut MetaDesc| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "meta",
            |m: &MetaDesc| { &m.meta },
            |m: &mut MetaDesc| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetaDesc>(
            "MetaDesc",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetaDesc {
    const NAME: &'static str = "MetaDesc";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.key = is.read_string()?;
                },
                26 => {
                    self.meta = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.meta.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.meta);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.meta.is_empty() {
            os.write_bytes(3, &self.meta)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetaDesc {
        MetaDesc::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(MetaType::Graph);
        self.key.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetaDesc {
        static instance: MetaDesc = MetaDesc {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            key: ::std::string::String::new(),
            meta: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetaDesc {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetaDesc").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetaDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaDesc {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.PropertyMeta)
pub struct PropertyMeta {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.id)
    pub id: u32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.propertyName)
    pub propertyName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.dataType)
    pub dataType: ::protobuf::EnumOrUnknown<DataType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.defaultValue)
    pub defaultValue: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.comment)
    pub comment: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.alias)
    pub alias: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.vertices)
    pub vertices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.edges)
    pub edges: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.PropertyMeta.config)
    pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.PropertyMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PropertyMeta {
    fn default() -> &'a PropertyMeta {
        <PropertyMeta as ::protobuf::Message>::default_instance()
    }
}

impl PropertyMeta {
    pub fn new() -> PropertyMeta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PropertyMeta| { &m.id },
            |m: &mut PropertyMeta| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "propertyName",
            |m: &PropertyMeta| { &m.propertyName },
            |m: &mut PropertyMeta| { &mut m.propertyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataType",
            |m: &PropertyMeta| { &m.dataType },
            |m: &mut PropertyMeta| { &mut m.dataType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "defaultValue",
            |m: &PropertyMeta| { &m.defaultValue },
            |m: &mut PropertyMeta| { &mut m.defaultValue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comment",
            |m: &PropertyMeta| { &m.comment },
            |m: &mut PropertyMeta| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "alias",
            |m: &PropertyMeta| { &m.alias },
            |m: &mut PropertyMeta| { &mut m.alias },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vertices",
            |m: &PropertyMeta| { &m.vertices },
            |m: &mut PropertyMeta| { &mut m.vertices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edges",
            |m: &PropertyMeta| { &m.edges },
            |m: &mut PropertyMeta| { &mut m.edges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "config",
            |m: &PropertyMeta| { &m.config },
            |m: &mut PropertyMeta| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PropertyMeta>(
            "PropertyMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PropertyMeta {
    const NAME: &'static str = "PropertyMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.propertyName = is.read_string()?;
                },
                24 => {
                    self.dataType = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.defaultValue = is.read_bytes()?;
                },
                42 => {
                    self.comment = is.read_string()?;
                },
                50 => {
                    self.alias = is.read_string()?;
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.vertices)?;
                },
                56 => {
                    self.vertices.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.edges)?;
                },
                64 => {
                    self.edges.push(is.read_uint32()?);
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.config.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.propertyName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.propertyName);
        }
        if self.dataType != ::protobuf::EnumOrUnknown::new(DataType::T_INT) {
            my_size += ::protobuf::rt::int32_size(3, self.dataType.value());
        }
        if !self.defaultValue.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.defaultValue);
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.comment);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.alias);
        }
        for value in &self.vertices {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        for value in &self.edges {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.propertyName.is_empty() {
            os.write_string(2, &self.propertyName)?;
        }
        if self.dataType != ::protobuf::EnumOrUnknown::new(DataType::T_INT) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.dataType))?;
        }
        if !self.defaultValue.is_empty() {
            os.write_bytes(4, &self.defaultValue)?;
        }
        if !self.comment.is_empty() {
            os.write_string(5, &self.comment)?;
        }
        if !self.alias.is_empty() {
            os.write_string(6, &self.alias)?;
        }
        for v in &self.vertices {
            os.write_uint32(7, *v)?;
        };
        for v in &self.edges {
            os.write_uint32(8, *v)?;
        };
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PropertyMeta {
        PropertyMeta::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.propertyName.clear();
        self.dataType = ::protobuf::EnumOrUnknown::new(DataType::T_INT);
        self.defaultValue.clear();
        self.comment.clear();
        self.alias.clear();
        self.vertices.clear();
        self.edges.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PropertyMeta {
        static instance: ::protobuf::rt::Lazy<PropertyMeta> = ::protobuf::rt::Lazy::new();
        instance.get(PropertyMeta::new)
    }
}

impl ::protobuf::MessageFull for PropertyMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PropertyMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PropertyMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.GraphMeta)
pub struct GraphMeta {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.id)
    pub id: u32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.create_time)
    pub create_time: i64,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.version)
    pub version: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.partition_num)
    pub partition_num: u32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.comment)
    pub comment: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.alias)
    pub alias: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.properties_meta)
    pub properties_meta: ::std::collections::HashMap<::std::string::String, PropertyMeta>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.vertices_meta)
    pub vertices_meta: ::std::collections::HashMap<::std::string::String, VertexMeta>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.edges_meta)
    pub edges_meta: ::std::collections::HashMap<::std::string::String, EdgeMeta>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GraphMeta.config)
    pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.GraphMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GraphMeta {
    fn default() -> &'a GraphMeta {
        <GraphMeta as ::protobuf::Message>::default_instance()
    }
}

impl GraphMeta {
    pub fn new() -> GraphMeta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GraphMeta| { &m.id },
            |m: &mut GraphMeta| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GraphMeta| { &m.name },
            |m: &mut GraphMeta| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &GraphMeta| { &m.create_time },
            |m: &mut GraphMeta| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &GraphMeta| { &m.version },
            |m: &mut GraphMeta| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partition_num",
            |m: &GraphMeta| { &m.partition_num },
            |m: &mut GraphMeta| { &mut m.partition_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comment",
            |m: &GraphMeta| { &m.comment },
            |m: &mut GraphMeta| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "alias",
            |m: &GraphMeta| { &m.alias },
            |m: &mut GraphMeta| { &mut m.alias },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "properties_meta",
            |m: &GraphMeta| { &m.properties_meta },
            |m: &mut GraphMeta| { &mut m.properties_meta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "vertices_meta",
            |m: &GraphMeta| { &m.vertices_meta },
            |m: &mut GraphMeta| { &mut m.vertices_meta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "edges_meta",
            |m: &GraphMeta| { &m.edges_meta },
            |m: &mut GraphMeta| { &mut m.edges_meta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "config",
            |m: &GraphMeta| { &m.config },
            |m: &mut GraphMeta| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GraphMeta>(
            "GraphMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GraphMeta {
    const NAME: &'static str = "GraphMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.create_time = is.read_int64()?;
                },
                32 => {
                    self.version = is.read_int32()?;
                },
                40 => {
                    self.partition_num = is.read_uint32()?;
                },
                50 => {
                    self.comment = is.read_string()?;
                },
                58 => {
                    self.alias = is.read_string()?;
                },
                66 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.properties_meta.insert(key, value);
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.vertices_meta.insert(key, value);
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.edges_meta.insert(key, value);
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.config.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.create_time);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.version);
        }
        if self.partition_num != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.partition_num);
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.comment);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.alias);
        }
        for (k, v) in &self.properties_meta {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.vertices_meta {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.edges_meta {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.create_time != 0 {
            os.write_int64(3, self.create_time)?;
        }
        if self.version != 0 {
            os.write_int32(4, self.version)?;
        }
        if self.partition_num != 0 {
            os.write_uint32(5, self.partition_num)?;
        }
        if !self.comment.is_empty() {
            os.write_string(6, &self.comment)?;
        }
        if !self.alias.is_empty() {
            os.write_string(7, &self.alias)?;
        }
        for (k, v) in &self.properties_meta {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(66)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.vertices_meta {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.edges_meta {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GraphMeta {
        GraphMeta::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.create_time = 0;
        self.version = 0;
        self.partition_num = 0;
        self.comment.clear();
        self.alias.clear();
        self.properties_meta.clear();
        self.vertices_meta.clear();
        self.edges_meta.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GraphMeta {
        static instance: ::protobuf::rt::Lazy<GraphMeta> = ::protobuf::rt::Lazy::new();
        instance.get(GraphMeta::new)
    }
}

impl ::protobuf::MessageFull for GraphMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GraphMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GraphMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.VertexMeta)
pub struct VertexMeta {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.id)
    pub id: u32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.primary_key)
    pub primary_key: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.create_time)
    pub create_time: i64,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.comment)
    pub comment: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.alias)
    pub alias: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.properties)
    pub properties: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.edges)
    pub edges: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.config)
    pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VertexMeta.indices)
    pub indices: ::std::collections::HashMap<::std::string::String, IndexMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.VertexMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VertexMeta {
    fn default() -> &'a VertexMeta {
        <VertexMeta as ::protobuf::Message>::default_instance()
    }
}

impl VertexMeta {
    pub fn new() -> VertexMeta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &VertexMeta| { &m.id },
            |m: &mut VertexMeta| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &VertexMeta| { &m.name },
            |m: &mut VertexMeta| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "primary_key",
            |m: &VertexMeta| { &m.primary_key },
            |m: &mut VertexMeta| { &mut m.primary_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &VertexMeta| { &m.create_time },
            |m: &mut VertexMeta| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comment",
            |m: &VertexMeta| { &m.comment },
            |m: &mut VertexMeta| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "alias",
            |m: &VertexMeta| { &m.alias },
            |m: &mut VertexMeta| { &mut m.alias },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &VertexMeta| { &m.properties },
            |m: &mut VertexMeta| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edges",
            |m: &VertexMeta| { &m.edges },
            |m: &mut VertexMeta| { &mut m.edges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "config",
            |m: &VertexMeta| { &m.config },
            |m: &mut VertexMeta| { &mut m.config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "indices",
            |m: &VertexMeta| { &m.indices },
            |m: &mut VertexMeta| { &mut m.indices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VertexMeta>(
            "VertexMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VertexMeta {
    const NAME: &'static str = "VertexMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.primary_key = is.read_string()?;
                },
                32 => {
                    self.create_time = is.read_int64()?;
                },
                42 => {
                    self.comment = is.read_string()?;
                },
                50 => {
                    self.alias = is.read_string()?;
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.properties)?;
                },
                56 => {
                    self.properties.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.edges)?;
                },
                64 => {
                    self.edges.push(is.read_uint32()?);
                },
                74 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.config.insert(key, value);
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.indices.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.primary_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.primary_key);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.create_time);
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.comment);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.alias);
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        for value in &self.edges {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.indices {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.primary_key.is_empty() {
            os.write_string(3, &self.primary_key)?;
        }
        if self.create_time != 0 {
            os.write_int64(4, self.create_time)?;
        }
        if !self.comment.is_empty() {
            os.write_string(5, &self.comment)?;
        }
        if !self.alias.is_empty() {
            os.write_string(6, &self.alias)?;
        }
        for v in &self.properties {
            os.write_uint32(7, *v)?;
        };
        for v in &self.edges {
            os.write_uint32(8, *v)?;
        };
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(74)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.indices {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VertexMeta {
        VertexMeta::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.primary_key.clear();
        self.create_time = 0;
        self.comment.clear();
        self.alias.clear();
        self.properties.clear();
        self.edges.clear();
        self.config.clear();
        self.indices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VertexMeta {
        static instance: ::protobuf::rt::Lazy<VertexMeta> = ::protobuf::rt::Lazy::new();
        instance.get(VertexMeta::new)
    }
}

impl ::protobuf::MessageFull for VertexMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VertexMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VertexMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.EdgeMeta)
pub struct EdgeMeta {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.id)
    pub id: u32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.src_label_id)
    pub src_label_id: u32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.dst_label_id)
    pub dst_label_id: u32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.create_time)
    pub create_time: i64,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.comment)
    pub comment: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.alias)
    pub alias: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.properties)
    pub properties: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.config)
    pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.EdgeMeta.indices)
    pub indices: ::std::collections::HashMap<::std::string::String, IndexMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.EdgeMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EdgeMeta {
    fn default() -> &'a EdgeMeta {
        <EdgeMeta as ::protobuf::Message>::default_instance()
    }
}

impl EdgeMeta {
    pub fn new() -> EdgeMeta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &EdgeMeta| { &m.id },
            |m: &mut EdgeMeta| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &EdgeMeta| { &m.name },
            |m: &mut EdgeMeta| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "src_label_id",
            |m: &EdgeMeta| { &m.src_label_id },
            |m: &mut EdgeMeta| { &mut m.src_label_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dst_label_id",
            |m: &EdgeMeta| { &m.dst_label_id },
            |m: &mut EdgeMeta| { &mut m.dst_label_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &EdgeMeta| { &m.create_time },
            |m: &mut EdgeMeta| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comment",
            |m: &EdgeMeta| { &m.comment },
            |m: &mut EdgeMeta| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "alias",
            |m: &EdgeMeta| { &m.alias },
            |m: &mut EdgeMeta| { &mut m.alias },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &EdgeMeta| { &m.properties },
            |m: &mut EdgeMeta| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "config",
            |m: &EdgeMeta| { &m.config },
            |m: &mut EdgeMeta| { &mut m.config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "indices",
            |m: &EdgeMeta| { &m.indices },
            |m: &mut EdgeMeta| { &mut m.indices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EdgeMeta>(
            "EdgeMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EdgeMeta {
    const NAME: &'static str = "EdgeMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.src_label_id = is.read_uint32()?;
                },
                32 => {
                    self.dst_label_id = is.read_uint32()?;
                },
                40 => {
                    self.create_time = is.read_int64()?;
                },
                58 => {
                    self.comment = is.read_string()?;
                },
                66 => {
                    self.alias = is.read_string()?;
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.properties)?;
                },
                72 => {
                    self.properties.push(is.read_uint32()?);
                },
                82 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.config.insert(key, value);
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.indices.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.src_label_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.src_label_id);
        }
        if self.dst_label_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.dst_label_id);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.create_time);
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.comment);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.alias);
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.indices {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.src_label_id != 0 {
            os.write_uint32(3, self.src_label_id)?;
        }
        if self.dst_label_id != 0 {
            os.write_uint32(4, self.dst_label_id)?;
        }
        if self.create_time != 0 {
            os.write_int64(5, self.create_time)?;
        }
        if !self.comment.is_empty() {
            os.write_string(7, &self.comment)?;
        }
        if !self.alias.is_empty() {
            os.write_string(8, &self.alias)?;
        }
        for v in &self.properties {
            os.write_uint32(9, *v)?;
        };
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(82)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.indices {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EdgeMeta {
        EdgeMeta::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.src_label_id = 0;
        self.dst_label_id = 0;
        self.create_time = 0;
        self.comment.clear();
        self.alias.clear();
        self.properties.clear();
        self.config.clear();
        self.indices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EdgeMeta {
        static instance: ::protobuf::rt::Lazy<EdgeMeta> = ::protobuf::rt::Lazy::new();
        instance.get(EdgeMeta::new)
    }
}

impl ::protobuf::MessageFull for EdgeMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EdgeMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EdgeMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.IndexMeta)
pub struct IndexMeta {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.IndexMeta.id)
    pub id: u32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.IndexMeta.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.IndexMeta.properties)
    pub properties: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.IndexMeta.create_time)
    pub create_time: i64,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.IndexMeta.config)
    pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.IndexMeta.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IndexMeta {
    fn default() -> &'a IndexMeta {
        <IndexMeta as ::protobuf::Message>::default_instance()
    }
}

impl IndexMeta {
    pub fn new() -> IndexMeta {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &IndexMeta| { &m.id },
            |m: &mut IndexMeta| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &IndexMeta| { &m.name },
            |m: &mut IndexMeta| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &IndexMeta| { &m.properties },
            |m: &mut IndexMeta| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &IndexMeta| { &m.create_time },
            |m: &mut IndexMeta| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "config",
            |m: &IndexMeta| { &m.config },
            |m: &mut IndexMeta| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IndexMeta>(
            "IndexMeta",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IndexMeta {
    const NAME: &'static str = "IndexMeta";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.properties.push(is.read_string()?);
                },
                32 => {
                    self.create_time = is.read_int64()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.config.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.create_time != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.create_time);
        }
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.properties {
            os.write_string(3, &v)?;
        };
        if self.create_time != 0 {
            os.write_int64(4, self.create_time)?;
        }
        for (k, v) in &self.config {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IndexMeta {
        IndexMeta::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.properties.clear();
        self.create_time = 0;
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IndexMeta {
        static instance: ::protobuf::rt::Lazy<IndexMeta> = ::protobuf::rt::Lazy::new();
        instance.get(IndexMeta::new)
    }
}

impl ::protobuf::MessageFull for IndexMeta {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IndexMeta").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IndexMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IndexMeta {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Graph RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreateGraphRequest)
pub struct CreateGraphRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateGraphRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateGraphRequest.partition_num)
    pub partition_num: u32,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreateGraphRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateGraphRequest {
    fn default() -> &'a CreateGraphRequest {
        <CreateGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateGraphRequest {
    pub fn new() -> CreateGraphRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CreateGraphRequest| { &m.name },
            |m: &mut CreateGraphRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partition_num",
            |m: &CreateGraphRequest| { &m.partition_num },
            |m: &mut CreateGraphRequest| { &mut m.partition_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateGraphRequest>(
            "CreateGraphRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateGraphRequest {
    const NAME: &'static str = "CreateGraphRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.partition_num = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.partition_num != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.partition_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.partition_num != 0 {
            os.write_uint32(2, self.partition_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateGraphRequest {
        CreateGraphRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.partition_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateGraphRequest {
        static instance: CreateGraphRequest = CreateGraphRequest {
            name: ::std::string::String::new(),
            partition_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateGraphRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateGraphRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateGraphRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreateGraphResponse)
pub struct CreateGraphResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateGraphResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateGraphResponse.meta)
    pub meta: ::protobuf::MessageField<GraphMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreateGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateGraphResponse {
    fn default() -> &'a CreateGraphResponse {
        <CreateGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateGraphResponse {
    pub fn new() -> CreateGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &CreateGraphResponse| { &m.header },
            |m: &mut CreateGraphResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GraphMeta>(
            "meta",
            |m: &CreateGraphResponse| { &m.meta },
            |m: &mut CreateGraphResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateGraphResponse>(
            "CreateGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateGraphResponse {
    const NAME: &'static str = "CreateGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateGraphResponse {
        CreateGraphResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateGraphResponse {
        static instance: CreateGraphResponse = CreateGraphResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropGraphMetaRequest)
pub struct DropGraphMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropGraphMetaRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropGraphMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropGraphMetaRequest {
    fn default() -> &'a DropGraphMetaRequest {
        <DropGraphMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropGraphMetaRequest {
    pub fn new() -> DropGraphMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DropGraphMetaRequest| { &m.name },
            |m: &mut DropGraphMetaRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropGraphMetaRequest>(
            "DropGraphMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropGraphMetaRequest {
    const NAME: &'static str = "DropGraphMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropGraphMetaRequest {
        DropGraphMetaRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropGraphMetaRequest {
        static instance: DropGraphMetaRequest = DropGraphMetaRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropGraphMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropGraphMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropGraphMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropGraphMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropGraphMetaResponse)
pub struct DropGraphMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropGraphMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropGraphMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropGraphMetaResponse {
    fn default() -> &'a DropGraphMetaResponse {
        <DropGraphMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl DropGraphMetaResponse {
    pub fn new() -> DropGraphMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &DropGraphMetaResponse| { &m.header },
            |m: &mut DropGraphMetaResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropGraphMetaResponse>(
            "DropGraphMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropGraphMetaResponse {
    const NAME: &'static str = "DropGraphMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropGraphMetaResponse {
        DropGraphMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropGraphMetaResponse {
        static instance: DropGraphMetaResponse = DropGraphMetaResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropGraphMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropGraphMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropGraphMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropGraphMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.GetGraphMetaRequest)
pub struct GetGraphMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetGraphMetaRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.GetGraphMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetGraphMetaRequest {
    fn default() -> &'a GetGraphMetaRequest {
        <GetGraphMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetGraphMetaRequest {
    pub fn new() -> GetGraphMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GetGraphMetaRequest| { &m.name },
            |m: &mut GetGraphMetaRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetGraphMetaRequest>(
            "GetGraphMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetGraphMetaRequest {
    const NAME: &'static str = "GetGraphMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetGraphMetaRequest {
        GetGraphMetaRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetGraphMetaRequest {
        static instance: GetGraphMetaRequest = GetGraphMetaRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetGraphMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetGraphMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetGraphMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetGraphMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.GetGraphMetaResponse)
pub struct GetGraphMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetGraphMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetGraphMetaResponse.meta)
    pub meta: ::protobuf::MessageField<GraphMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.GetGraphMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetGraphMetaResponse {
    fn default() -> &'a GetGraphMetaResponse {
        <GetGraphMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetGraphMetaResponse {
    pub fn new() -> GetGraphMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &GetGraphMetaResponse| { &m.header },
            |m: &mut GetGraphMetaResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GraphMeta>(
            "meta",
            |m: &GetGraphMetaResponse| { &m.meta },
            |m: &mut GetGraphMetaResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetGraphMetaResponse>(
            "GetGraphMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetGraphMetaResponse {
    const NAME: &'static str = "GetGraphMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetGraphMetaResponse {
        GetGraphMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetGraphMetaResponse {
        static instance: GetGraphMetaResponse = GetGraphMetaResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetGraphMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetGraphMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetGraphMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetGraphMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.GetAllGraphMetaRequest)
pub struct GetAllGraphMetaRequest {
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.GetAllGraphMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAllGraphMetaRequest {
    fn default() -> &'a GetAllGraphMetaRequest {
        <GetAllGraphMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAllGraphMetaRequest {
    pub fn new() -> GetAllGraphMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllGraphMetaRequest>(
            "GetAllGraphMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAllGraphMetaRequest {
    const NAME: &'static str = "GetAllGraphMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAllGraphMetaRequest {
        GetAllGraphMetaRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAllGraphMetaRequest {
        static instance: GetAllGraphMetaRequest = GetAllGraphMetaRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAllGraphMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAllGraphMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAllGraphMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllGraphMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.GetAllGraphMetaResponse)
pub struct GetAllGraphMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetAllGraphMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetAllGraphMetaResponse.meta)
    pub meta: ::std::vec::Vec<GraphMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.GetAllGraphMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAllGraphMetaResponse {
    fn default() -> &'a GetAllGraphMetaResponse {
        <GetAllGraphMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAllGraphMetaResponse {
    pub fn new() -> GetAllGraphMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &GetAllGraphMetaResponse| { &m.header },
            |m: &mut GetAllGraphMetaResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "meta",
            |m: &GetAllGraphMetaResponse| { &m.meta },
            |m: &mut GetAllGraphMetaResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllGraphMetaResponse>(
            "GetAllGraphMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAllGraphMetaResponse {
    const NAME: &'static str = "GetAllGraphMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.meta.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.meta {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.meta {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAllGraphMetaResponse {
        GetAllGraphMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAllGraphMetaResponse {
        static instance: GetAllGraphMetaResponse = GetAllGraphMetaResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAllGraphMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAllGraphMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAllGraphMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllGraphMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Property RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreatePropertyRequest)
pub struct CreatePropertyRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreatePropertyRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreatePropertyRequest.propertyName)
    pub propertyName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreatePropertyRequest.dataType)
    pub dataType: ::protobuf::EnumOrUnknown<DataType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreatePropertyRequest.defaultValue)
    pub defaultValue: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreatePropertyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreatePropertyRequest {
    fn default() -> &'a CreatePropertyRequest {
        <CreatePropertyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreatePropertyRequest {
    pub fn new() -> CreatePropertyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &CreatePropertyRequest| { &m.graphName },
            |m: &mut CreatePropertyRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "propertyName",
            |m: &CreatePropertyRequest| { &m.propertyName },
            |m: &mut CreatePropertyRequest| { &mut m.propertyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataType",
            |m: &CreatePropertyRequest| { &m.dataType },
            |m: &mut CreatePropertyRequest| { &mut m.dataType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "defaultValue",
            |m: &CreatePropertyRequest| { &m.defaultValue },
            |m: &mut CreatePropertyRequest| { &mut m.defaultValue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreatePropertyRequest>(
            "CreatePropertyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreatePropertyRequest {
    const NAME: &'static str = "CreatePropertyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.propertyName = is.read_string()?;
                },
                24 => {
                    self.dataType = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.defaultValue = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.propertyName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.propertyName);
        }
        if self.dataType != ::protobuf::EnumOrUnknown::new(DataType::T_INT) {
            my_size += ::protobuf::rt::int32_size(3, self.dataType.value());
        }
        if !self.defaultValue.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.defaultValue);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.propertyName.is_empty() {
            os.write_string(2, &self.propertyName)?;
        }
        if self.dataType != ::protobuf::EnumOrUnknown::new(DataType::T_INT) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.dataType))?;
        }
        if !self.defaultValue.is_empty() {
            os.write_bytes(4, &self.defaultValue)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreatePropertyRequest {
        CreatePropertyRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.propertyName.clear();
        self.dataType = ::protobuf::EnumOrUnknown::new(DataType::T_INT);
        self.defaultValue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreatePropertyRequest {
        static instance: CreatePropertyRequest = CreatePropertyRequest {
            graphName: ::std::string::String::new(),
            propertyName: ::std::string::String::new(),
            dataType: ::protobuf::EnumOrUnknown::from_i32(0),
            defaultValue: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreatePropertyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreatePropertyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreatePropertyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePropertyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreatePropertyResponse)
pub struct CreatePropertyResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreatePropertyResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreatePropertyResponse.meta)
    pub meta: ::protobuf::MessageField<PropertyMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreatePropertyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreatePropertyResponse {
    fn default() -> &'a CreatePropertyResponse {
        <CreatePropertyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreatePropertyResponse {
    pub fn new() -> CreatePropertyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &CreatePropertyResponse| { &m.header },
            |m: &mut CreatePropertyResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PropertyMeta>(
            "meta",
            |m: &CreatePropertyResponse| { &m.meta },
            |m: &mut CreatePropertyResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreatePropertyResponse>(
            "CreatePropertyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreatePropertyResponse {
    const NAME: &'static str = "CreatePropertyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreatePropertyResponse {
        CreatePropertyResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreatePropertyResponse {
        static instance: CreatePropertyResponse = CreatePropertyResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreatePropertyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreatePropertyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreatePropertyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePropertyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropPropertyMetaRequest)
pub struct DropPropertyMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropPropertyMetaRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropPropertyMetaRequest.propertyName)
    pub propertyName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropPropertyMetaRequest.trace_id)
    pub trace_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropPropertyMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropPropertyMetaRequest {
    fn default() -> &'a DropPropertyMetaRequest {
        <DropPropertyMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropPropertyMetaRequest {
    pub fn new() -> DropPropertyMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &DropPropertyMetaRequest| { &m.graphName },
            |m: &mut DropPropertyMetaRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "propertyName",
            |m: &DropPropertyMetaRequest| { &m.propertyName },
            |m: &mut DropPropertyMetaRequest| { &mut m.propertyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &DropPropertyMetaRequest| { &m.trace_id },
            |m: &mut DropPropertyMetaRequest| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropPropertyMetaRequest>(
            "DropPropertyMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropPropertyMetaRequest {
    const NAME: &'static str = "DropPropertyMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.propertyName = is.read_string()?;
                },
                24 => {
                    self.trace_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.propertyName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.propertyName);
        }
        if self.trace_id != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.propertyName.is_empty() {
            os.write_string(2, &self.propertyName)?;
        }
        if self.trace_id != 0 {
            os.write_int64(3, self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropPropertyMetaRequest {
        DropPropertyMetaRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.propertyName.clear();
        self.trace_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropPropertyMetaRequest {
        static instance: DropPropertyMetaRequest = DropPropertyMetaRequest {
            graphName: ::std::string::String::new(),
            propertyName: ::std::string::String::new(),
            trace_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropPropertyMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropPropertyMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropPropertyMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropPropertyMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropPropertyMetaResponse)
pub struct DropPropertyMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropPropertyMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropPropertyMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropPropertyMetaResponse {
    fn default() -> &'a DropPropertyMetaResponse {
        <DropPropertyMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl DropPropertyMetaResponse {
    pub fn new() -> DropPropertyMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &DropPropertyMetaResponse| { &m.header },
            |m: &mut DropPropertyMetaResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropPropertyMetaResponse>(
            "DropPropertyMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropPropertyMetaResponse {
    const NAME: &'static str = "DropPropertyMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropPropertyMetaResponse {
        DropPropertyMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropPropertyMetaResponse {
        static instance: DropPropertyMetaResponse = DropPropertyMetaResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropPropertyMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropPropertyMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropPropertyMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropPropertyMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdatePropertyMetaRequest)
pub struct UpdatePropertyMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdatePropertyMetaRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdatePropertyMetaRequest.propertyName)
    pub propertyName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdatePropertyMetaRequest.defaultValue)
    pub defaultValue: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdatePropertyMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdatePropertyMetaRequest {
    fn default() -> &'a UpdatePropertyMetaRequest {
        <UpdatePropertyMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePropertyMetaRequest {
    pub fn new() -> UpdatePropertyMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &UpdatePropertyMetaRequest| { &m.graphName },
            |m: &mut UpdatePropertyMetaRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "propertyName",
            |m: &UpdatePropertyMetaRequest| { &m.propertyName },
            |m: &mut UpdatePropertyMetaRequest| { &mut m.propertyName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "defaultValue",
            |m: &UpdatePropertyMetaRequest| { &m.defaultValue },
            |m: &mut UpdatePropertyMetaRequest| { &mut m.defaultValue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdatePropertyMetaRequest>(
            "UpdatePropertyMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdatePropertyMetaRequest {
    const NAME: &'static str = "UpdatePropertyMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.propertyName = is.read_string()?;
                },
                34 => {
                    self.defaultValue = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.propertyName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.propertyName);
        }
        if !self.defaultValue.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.defaultValue);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.propertyName.is_empty() {
            os.write_string(2, &self.propertyName)?;
        }
        if !self.defaultValue.is_empty() {
            os.write_bytes(4, &self.defaultValue)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdatePropertyMetaRequest {
        UpdatePropertyMetaRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.propertyName.clear();
        self.defaultValue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdatePropertyMetaRequest {
        static instance: UpdatePropertyMetaRequest = UpdatePropertyMetaRequest {
            graphName: ::std::string::String::new(),
            propertyName: ::std::string::String::new(),
            defaultValue: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdatePropertyMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdatePropertyMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdatePropertyMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePropertyMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdatePropertyMetaResponse)
pub struct UpdatePropertyMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdatePropertyMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdatePropertyMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdatePropertyMetaResponse {
    fn default() -> &'a UpdatePropertyMetaResponse {
        <UpdatePropertyMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePropertyMetaResponse {
    pub fn new() -> UpdatePropertyMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &UpdatePropertyMetaResponse| { &m.header },
            |m: &mut UpdatePropertyMetaResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdatePropertyMetaResponse>(
            "UpdatePropertyMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdatePropertyMetaResponse {
    const NAME: &'static str = "UpdatePropertyMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdatePropertyMetaResponse {
        UpdatePropertyMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdatePropertyMetaResponse {
        static instance: UpdatePropertyMetaResponse = UpdatePropertyMetaResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdatePropertyMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdatePropertyMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdatePropertyMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePropertyMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Vertex RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreateVertexRequest)
pub struct CreateVertexRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateVertexRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateVertexRequest.vertexName)
    pub vertexName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateVertexRequest.primary_key)
    pub primary_key: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateVertexRequest.properties)
    pub properties: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateVertexRequest.trace_id)
    pub trace_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreateVertexRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateVertexRequest {
    fn default() -> &'a CreateVertexRequest {
        <CreateVertexRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateVertexRequest {
    pub fn new() -> CreateVertexRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &CreateVertexRequest| { &m.graphName },
            |m: &mut CreateVertexRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vertexName",
            |m: &CreateVertexRequest| { &m.vertexName },
            |m: &mut CreateVertexRequest| { &mut m.vertexName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "primary_key",
            |m: &CreateVertexRequest| { &m.primary_key },
            |m: &mut CreateVertexRequest| { &mut m.primary_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &CreateVertexRequest| { &m.properties },
            |m: &mut CreateVertexRequest| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &CreateVertexRequest| { &m.trace_id },
            |m: &mut CreateVertexRequest| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateVertexRequest>(
            "CreateVertexRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateVertexRequest {
    const NAME: &'static str = "CreateVertexRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.vertexName = is.read_string()?;
                },
                26 => {
                    self.primary_key = is.read_string()?;
                },
                34 => {
                    self.properties.push(is.read_string()?);
                },
                40 => {
                    self.trace_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.vertexName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.vertexName);
        }
        if !self.primary_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.primary_key);
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.trace_id != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.vertexName.is_empty() {
            os.write_string(2, &self.vertexName)?;
        }
        if !self.primary_key.is_empty() {
            os.write_string(3, &self.primary_key)?;
        }
        for v in &self.properties {
            os.write_string(4, &v)?;
        };
        if self.trace_id != 0 {
            os.write_int64(5, self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateVertexRequest {
        CreateVertexRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.vertexName.clear();
        self.primary_key.clear();
        self.properties.clear();
        self.trace_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateVertexRequest {
        static instance: CreateVertexRequest = CreateVertexRequest {
            graphName: ::std::string::String::new(),
            vertexName: ::std::string::String::new(),
            primary_key: ::std::string::String::new(),
            properties: ::std::vec::Vec::new(),
            trace_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateVertexRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateVertexRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateVertexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateVertexRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreateVertexResponse)
pub struct CreateVertexResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateVertexResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateVertexResponse.meta)
    pub meta: ::protobuf::MessageField<VertexMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreateVertexResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateVertexResponse {
    fn default() -> &'a CreateVertexResponse {
        <CreateVertexResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateVertexResponse {
    pub fn new() -> CreateVertexResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &CreateVertexResponse| { &m.header },
            |m: &mut CreateVertexResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VertexMeta>(
            "meta",
            |m: &CreateVertexResponse| { &m.meta },
            |m: &mut CreateVertexResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateVertexResponse>(
            "CreateVertexResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateVertexResponse {
    const NAME: &'static str = "CreateVertexResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateVertexResponse {
        CreateVertexResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateVertexResponse {
        static instance: CreateVertexResponse = CreateVertexResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateVertexResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateVertexResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateVertexResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateVertexResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropVertexMetaRequest)
pub struct DropVertexMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropVertexMetaRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropVertexMetaRequest.vertexName)
    pub vertexName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropVertexMetaRequest.trace_id)
    pub trace_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropVertexMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropVertexMetaRequest {
    fn default() -> &'a DropVertexMetaRequest {
        <DropVertexMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropVertexMetaRequest {
    pub fn new() -> DropVertexMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &DropVertexMetaRequest| { &m.graphName },
            |m: &mut DropVertexMetaRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vertexName",
            |m: &DropVertexMetaRequest| { &m.vertexName },
            |m: &mut DropVertexMetaRequest| { &mut m.vertexName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &DropVertexMetaRequest| { &m.trace_id },
            |m: &mut DropVertexMetaRequest| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropVertexMetaRequest>(
            "DropVertexMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropVertexMetaRequest {
    const NAME: &'static str = "DropVertexMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.vertexName = is.read_string()?;
                },
                24 => {
                    self.trace_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.vertexName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.vertexName);
        }
        if self.trace_id != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.vertexName.is_empty() {
            os.write_string(2, &self.vertexName)?;
        }
        if self.trace_id != 0 {
            os.write_int64(3, self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropVertexMetaRequest {
        DropVertexMetaRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.vertexName.clear();
        self.trace_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropVertexMetaRequest {
        static instance: DropVertexMetaRequest = DropVertexMetaRequest {
            graphName: ::std::string::String::new(),
            vertexName: ::std::string::String::new(),
            trace_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropVertexMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropVertexMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropVertexMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropVertexMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropVertexMetaResponse)
pub struct DropVertexMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropVertexMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropVertexMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropVertexMetaResponse {
    fn default() -> &'a DropVertexMetaResponse {
        <DropVertexMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl DropVertexMetaResponse {
    pub fn new() -> DropVertexMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &DropVertexMetaResponse| { &m.header },
            |m: &mut DropVertexMetaResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropVertexMetaResponse>(
            "DropVertexMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropVertexMetaResponse {
    const NAME: &'static str = "DropVertexMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropVertexMetaResponse {
        DropVertexMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropVertexMetaResponse {
        static instance: DropVertexMetaResponse = DropVertexMetaResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropVertexMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropVertexMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropVertexMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropVertexMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateVertexMetaRequest)
pub struct UpdateVertexMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateVertexMetaRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateVertexMetaRequest.vertexName)
    pub vertexName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateVertexMetaRequest.properties)
    pub properties: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateVertexMetaRequest.trace_id)
    pub trace_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateVertexMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateVertexMetaRequest {
    fn default() -> &'a UpdateVertexMetaRequest {
        <UpdateVertexMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateVertexMetaRequest {
    pub fn new() -> UpdateVertexMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &UpdateVertexMetaRequest| { &m.graphName },
            |m: &mut UpdateVertexMetaRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vertexName",
            |m: &UpdateVertexMetaRequest| { &m.vertexName },
            |m: &mut UpdateVertexMetaRequest| { &mut m.vertexName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &UpdateVertexMetaRequest| { &m.properties },
            |m: &mut UpdateVertexMetaRequest| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &UpdateVertexMetaRequest| { &m.trace_id },
            |m: &mut UpdateVertexMetaRequest| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateVertexMetaRequest>(
            "UpdateVertexMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateVertexMetaRequest {
    const NAME: &'static str = "UpdateVertexMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.vertexName = is.read_string()?;
                },
                26 => {
                    self.properties.push(is.read_string()?);
                },
                32 => {
                    self.trace_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.vertexName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.vertexName);
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.trace_id != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.vertexName.is_empty() {
            os.write_string(2, &self.vertexName)?;
        }
        for v in &self.properties {
            os.write_string(3, &v)?;
        };
        if self.trace_id != 0 {
            os.write_int64(4, self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateVertexMetaRequest {
        UpdateVertexMetaRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.vertexName.clear();
        self.properties.clear();
        self.trace_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateVertexMetaRequest {
        static instance: UpdateVertexMetaRequest = UpdateVertexMetaRequest {
            graphName: ::std::string::String::new(),
            vertexName: ::std::string::String::new(),
            properties: ::std::vec::Vec::new(),
            trace_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateVertexMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateVertexMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateVertexMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateVertexMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateVertexMetaResponse)
pub struct UpdateVertexMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateVertexMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateVertexMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateVertexMetaResponse {
    fn default() -> &'a UpdateVertexMetaResponse {
        <UpdateVertexMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateVertexMetaResponse {
    pub fn new() -> UpdateVertexMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &UpdateVertexMetaResponse| { &m.header },
            |m: &mut UpdateVertexMetaResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateVertexMetaResponse>(
            "UpdateVertexMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateVertexMetaResponse {
    const NAME: &'static str = "UpdateVertexMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateVertexMetaResponse {
        UpdateVertexMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateVertexMetaResponse {
        static instance: UpdateVertexMetaResponse = UpdateVertexMetaResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateVertexMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateVertexMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateVertexMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateVertexMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Edge RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreateEdgeRequest)
pub struct CreateEdgeRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateEdgeRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateEdgeRequest.edgeName)
    pub edgeName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateEdgeRequest.subject)
    pub subject: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateEdgeRequest.object)
    pub object: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateEdgeRequest.properties)
    pub properties: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateEdgeRequest.trace_id)
    pub trace_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreateEdgeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateEdgeRequest {
    fn default() -> &'a CreateEdgeRequest {
        <CreateEdgeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateEdgeRequest {
    pub fn new() -> CreateEdgeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &CreateEdgeRequest| { &m.graphName },
            |m: &mut CreateEdgeRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "edgeName",
            |m: &CreateEdgeRequest| { &m.edgeName },
            |m: &mut CreateEdgeRequest| { &mut m.edgeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subject",
            |m: &CreateEdgeRequest| { &m.subject },
            |m: &mut CreateEdgeRequest| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object",
            |m: &CreateEdgeRequest| { &m.object },
            |m: &mut CreateEdgeRequest| { &mut m.object },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &CreateEdgeRequest| { &m.properties },
            |m: &mut CreateEdgeRequest| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &CreateEdgeRequest| { &m.trace_id },
            |m: &mut CreateEdgeRequest| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateEdgeRequest>(
            "CreateEdgeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateEdgeRequest {
    const NAME: &'static str = "CreateEdgeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.edgeName = is.read_string()?;
                },
                26 => {
                    self.subject = is.read_string()?;
                },
                34 => {
                    self.object = is.read_string()?;
                },
                42 => {
                    self.properties.push(is.read_string()?);
                },
                48 => {
                    self.trace_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.edgeName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.edgeName);
        }
        if !self.subject.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subject);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.object);
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.trace_id != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.edgeName.is_empty() {
            os.write_string(2, &self.edgeName)?;
        }
        if !self.subject.is_empty() {
            os.write_string(3, &self.subject)?;
        }
        if !self.object.is_empty() {
            os.write_string(4, &self.object)?;
        }
        for v in &self.properties {
            os.write_string(5, &v)?;
        };
        if self.trace_id != 0 {
            os.write_int64(6, self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateEdgeRequest {
        CreateEdgeRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.edgeName.clear();
        self.subject.clear();
        self.object.clear();
        self.properties.clear();
        self.trace_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateEdgeRequest {
        static instance: CreateEdgeRequest = CreateEdgeRequest {
            graphName: ::std::string::String::new(),
            edgeName: ::std::string::String::new(),
            subject: ::std::string::String::new(),
            object: ::std::string::String::new(),
            properties: ::std::vec::Vec::new(),
            trace_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateEdgeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateEdgeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateEdgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateEdgeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreateEdgeResponse)
pub struct CreateEdgeResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateEdgeResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateEdgeResponse.meta)
    pub meta: ::protobuf::MessageField<EdgeMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreateEdgeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateEdgeResponse {
    fn default() -> &'a CreateEdgeResponse {
        <CreateEdgeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateEdgeResponse {
    pub fn new() -> CreateEdgeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &CreateEdgeResponse| { &m.header },
            |m: &mut CreateEdgeResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EdgeMeta>(
            "meta",
            |m: &CreateEdgeResponse| { &m.meta },
            |m: &mut CreateEdgeResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateEdgeResponse>(
            "CreateEdgeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateEdgeResponse {
    const NAME: &'static str = "CreateEdgeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateEdgeResponse {
        CreateEdgeResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateEdgeResponse {
        static instance: CreateEdgeResponse = CreateEdgeResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateEdgeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateEdgeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateEdgeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateEdgeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropEdgeMetaRequest)
pub struct DropEdgeMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropEdgeMetaRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropEdgeMetaRequest.edgeName)
    pub edgeName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropEdgeMetaRequest.trace_id)
    pub trace_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropEdgeMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropEdgeMetaRequest {
    fn default() -> &'a DropEdgeMetaRequest {
        <DropEdgeMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropEdgeMetaRequest {
    pub fn new() -> DropEdgeMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &DropEdgeMetaRequest| { &m.graphName },
            |m: &mut DropEdgeMetaRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "edgeName",
            |m: &DropEdgeMetaRequest| { &m.edgeName },
            |m: &mut DropEdgeMetaRequest| { &mut m.edgeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &DropEdgeMetaRequest| { &m.trace_id },
            |m: &mut DropEdgeMetaRequest| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropEdgeMetaRequest>(
            "DropEdgeMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropEdgeMetaRequest {
    const NAME: &'static str = "DropEdgeMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.edgeName = is.read_string()?;
                },
                24 => {
                    self.trace_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.edgeName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.edgeName);
        }
        if self.trace_id != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.edgeName.is_empty() {
            os.write_string(2, &self.edgeName)?;
        }
        if self.trace_id != 0 {
            os.write_int64(3, self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropEdgeMetaRequest {
        DropEdgeMetaRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.edgeName.clear();
        self.trace_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropEdgeMetaRequest {
        static instance: DropEdgeMetaRequest = DropEdgeMetaRequest {
            graphName: ::std::string::String::new(),
            edgeName: ::std::string::String::new(),
            trace_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropEdgeMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropEdgeMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropEdgeMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropEdgeMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropEdgeMetaResponse)
pub struct DropEdgeMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropEdgeMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropEdgeMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropEdgeMetaResponse {
    fn default() -> &'a DropEdgeMetaResponse {
        <DropEdgeMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl DropEdgeMetaResponse {
    pub fn new() -> DropEdgeMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &DropEdgeMetaResponse| { &m.header },
            |m: &mut DropEdgeMetaResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropEdgeMetaResponse>(
            "DropEdgeMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropEdgeMetaResponse {
    const NAME: &'static str = "DropEdgeMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropEdgeMetaResponse {
        DropEdgeMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropEdgeMetaResponse {
        static instance: DropEdgeMetaResponse = DropEdgeMetaResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropEdgeMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropEdgeMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropEdgeMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropEdgeMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateEdgeMetaRequest)
pub struct UpdateEdgeMetaRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateEdgeMetaRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateEdgeMetaRequest.edgeName)
    pub edgeName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateEdgeMetaRequest.properties)
    pub properties: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateEdgeMetaRequest.trace_id)
    pub trace_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateEdgeMetaRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateEdgeMetaRequest {
    fn default() -> &'a UpdateEdgeMetaRequest {
        <UpdateEdgeMetaRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEdgeMetaRequest {
    pub fn new() -> UpdateEdgeMetaRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &UpdateEdgeMetaRequest| { &m.graphName },
            |m: &mut UpdateEdgeMetaRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "edgeName",
            |m: &UpdateEdgeMetaRequest| { &m.edgeName },
            |m: &mut UpdateEdgeMetaRequest| { &mut m.edgeName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &UpdateEdgeMetaRequest| { &m.properties },
            |m: &mut UpdateEdgeMetaRequest| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &UpdateEdgeMetaRequest| { &m.trace_id },
            |m: &mut UpdateEdgeMetaRequest| { &mut m.trace_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateEdgeMetaRequest>(
            "UpdateEdgeMetaRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateEdgeMetaRequest {
    const NAME: &'static str = "UpdateEdgeMetaRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.edgeName = is.read_string()?;
                },
                26 => {
                    self.properties.push(is.read_string()?);
                },
                32 => {
                    self.trace_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.edgeName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.edgeName);
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.trace_id != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.trace_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.edgeName.is_empty() {
            os.write_string(2, &self.edgeName)?;
        }
        for v in &self.properties {
            os.write_string(3, &v)?;
        };
        if self.trace_id != 0 {
            os.write_int64(4, self.trace_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateEdgeMetaRequest {
        UpdateEdgeMetaRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.edgeName.clear();
        self.properties.clear();
        self.trace_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateEdgeMetaRequest {
        static instance: UpdateEdgeMetaRequest = UpdateEdgeMetaRequest {
            graphName: ::std::string::String::new(),
            edgeName: ::std::string::String::new(),
            properties: ::std::vec::Vec::new(),
            trace_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateEdgeMetaRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateEdgeMetaRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateEdgeMetaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEdgeMetaRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateEdgeMetaResponse)
pub struct UpdateEdgeMetaResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateEdgeMetaResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateEdgeMetaResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateEdgeMetaResponse {
    fn default() -> &'a UpdateEdgeMetaResponse {
        <UpdateEdgeMetaResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEdgeMetaResponse {
    pub fn new() -> UpdateEdgeMetaResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &UpdateEdgeMetaResponse| { &m.header },
            |m: &mut UpdateEdgeMetaResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateEdgeMetaResponse>(
            "UpdateEdgeMetaResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateEdgeMetaResponse {
    const NAME: &'static str = "UpdateEdgeMetaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateEdgeMetaResponse {
        UpdateEdgeMetaResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateEdgeMetaResponse {
        static instance: UpdateEdgeMetaResponse = UpdateEdgeMetaResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateEdgeMetaResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateEdgeMetaResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateEdgeMetaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEdgeMetaResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateConfigRequest)
pub struct UpdateConfigRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateConfigRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateConfigRequest.MetaType)
    pub MetaType: ::protobuf::EnumOrUnknown<MetaType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateConfigRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateConfigRequest.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateConfigRequest.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateConfigRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateConfigRequest {
    fn default() -> &'a UpdateConfigRequest {
        <UpdateConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateConfigRequest {
    pub fn new() -> UpdateConfigRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &UpdateConfigRequest| { &m.graphName },
            |m: &mut UpdateConfigRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MetaType",
            |m: &UpdateConfigRequest| { &m.MetaType },
            |m: &mut UpdateConfigRequest| { &mut m.MetaType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &UpdateConfigRequest| { &m.name },
            |m: &mut UpdateConfigRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &UpdateConfigRequest| { &m.key },
            |m: &mut UpdateConfigRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &UpdateConfigRequest| { &m.value },
            |m: &mut UpdateConfigRequest| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateConfigRequest>(
            "UpdateConfigRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateConfigRequest {
    const NAME: &'static str = "UpdateConfigRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                16 => {
                    self.MetaType = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.key = is.read_string()?;
                },
                42 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            my_size += ::protobuf::rt::int32_size(2, self.MetaType.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.MetaType))?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.key.is_empty() {
            os.write_string(4, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(5, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateConfigRequest {
        UpdateConfigRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.MetaType = ::protobuf::EnumOrUnknown::new(MetaType::Graph);
        self.name.clear();
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateConfigRequest {
        static instance: UpdateConfigRequest = UpdateConfigRequest {
            graphName: ::std::string::String::new(),
            MetaType: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateConfigRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateConfigRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateConfigRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateConfigResponse)
pub struct UpdateConfigResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateConfigResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateConfigResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateConfigResponse {
    fn default() -> &'a UpdateConfigResponse {
        <UpdateConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateConfigResponse {
    pub fn new() -> UpdateConfigResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &UpdateConfigResponse| { &m.header },
            |m: &mut UpdateConfigResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateConfigResponse>(
            "UpdateConfigResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateConfigResponse {
    const NAME: &'static str = "UpdateConfigResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateConfigResponse {
        UpdateConfigResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateConfigResponse {
        static instance: UpdateConfigResponse = UpdateConfigResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateConfigResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateConfigResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateConfigResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateAliasRequest)
pub struct UpdateAliasRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateAliasRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateAliasRequest.MetaType)
    pub MetaType: ::protobuf::EnumOrUnknown<MetaType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateAliasRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateAliasRequest.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateAliasRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateAliasRequest {
    fn default() -> &'a UpdateAliasRequest {
        <UpdateAliasRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAliasRequest {
    pub fn new() -> UpdateAliasRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &UpdateAliasRequest| { &m.graphName },
            |m: &mut UpdateAliasRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MetaType",
            |m: &UpdateAliasRequest| { &m.MetaType },
            |m: &mut UpdateAliasRequest| { &mut m.MetaType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &UpdateAliasRequest| { &m.name },
            |m: &mut UpdateAliasRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &UpdateAliasRequest| { &m.value },
            |m: &mut UpdateAliasRequest| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateAliasRequest>(
            "UpdateAliasRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateAliasRequest {
    const NAME: &'static str = "UpdateAliasRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                16 => {
                    self.MetaType = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            my_size += ::protobuf::rt::int32_size(2, self.MetaType.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.MetaType))?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(4, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateAliasRequest {
        UpdateAliasRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.MetaType = ::protobuf::EnumOrUnknown::new(MetaType::Graph);
        self.name.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateAliasRequest {
        static instance: UpdateAliasRequest = UpdateAliasRequest {
            graphName: ::std::string::String::new(),
            MetaType: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateAliasRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateAliasRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateAliasRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAliasRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateAliasResponse)
pub struct UpdateAliasResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateAliasResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateAliasResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateAliasResponse {
    fn default() -> &'a UpdateAliasResponse {
        <UpdateAliasResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAliasResponse {
    pub fn new() -> UpdateAliasResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &UpdateAliasResponse| { &m.header },
            |m: &mut UpdateAliasResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateAliasResponse>(
            "UpdateAliasResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateAliasResponse {
    const NAME: &'static str = "UpdateAliasResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateAliasResponse {
        UpdateAliasResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateAliasResponse {
        static instance: UpdateAliasResponse = UpdateAliasResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateAliasResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateAliasResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateAliasResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAliasResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateCommentRequest)
pub struct UpdateCommentRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateCommentRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateCommentRequest.MetaType)
    pub MetaType: ::protobuf::EnumOrUnknown<MetaType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateCommentRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateCommentRequest.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateCommentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateCommentRequest {
    fn default() -> &'a UpdateCommentRequest {
        <UpdateCommentRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCommentRequest {
    pub fn new() -> UpdateCommentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &UpdateCommentRequest| { &m.graphName },
            |m: &mut UpdateCommentRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MetaType",
            |m: &UpdateCommentRequest| { &m.MetaType },
            |m: &mut UpdateCommentRequest| { &mut m.MetaType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &UpdateCommentRequest| { &m.name },
            |m: &mut UpdateCommentRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &UpdateCommentRequest| { &m.value },
            |m: &mut UpdateCommentRequest| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateCommentRequest>(
            "UpdateCommentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateCommentRequest {
    const NAME: &'static str = "UpdateCommentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                16 => {
                    self.MetaType = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            my_size += ::protobuf::rt::int32_size(2, self.MetaType.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.MetaType))?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(4, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateCommentRequest {
        UpdateCommentRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.MetaType = ::protobuf::EnumOrUnknown::new(MetaType::Graph);
        self.name.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateCommentRequest {
        static instance: UpdateCommentRequest = UpdateCommentRequest {
            graphName: ::std::string::String::new(),
            MetaType: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateCommentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateCommentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateCommentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCommentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.UpdateCommentResponse)
pub struct UpdateCommentResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.UpdateCommentResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.UpdateCommentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateCommentResponse {
    fn default() -> &'a UpdateCommentResponse {
        <UpdateCommentResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCommentResponse {
    pub fn new() -> UpdateCommentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &UpdateCommentResponse| { &m.header },
            |m: &mut UpdateCommentResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateCommentResponse>(
            "UpdateCommentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateCommentResponse {
    const NAME: &'static str = "UpdateCommentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateCommentResponse {
        UpdateCommentResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateCommentResponse {
        static instance: UpdateCommentResponse = UpdateCommentResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateCommentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateCommentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateCommentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCommentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreateIndexRequest)
pub struct CreateIndexRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateIndexRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateIndexRequest.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateIndexRequest.MetaType)
    pub MetaType: ::protobuf::EnumOrUnknown<MetaType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateIndexRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateIndexRequest.properties)
    pub properties: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreateIndexRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateIndexRequest {
    fn default() -> &'a CreateIndexRequest {
        <CreateIndexRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateIndexRequest {
    pub fn new() -> CreateIndexRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &CreateIndexRequest| { &m.graphName },
            |m: &mut CreateIndexRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &CreateIndexRequest| { &m.label },
            |m: &mut CreateIndexRequest| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MetaType",
            |m: &CreateIndexRequest| { &m.MetaType },
            |m: &mut CreateIndexRequest| { &mut m.MetaType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CreateIndexRequest| { &m.name },
            |m: &mut CreateIndexRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "properties",
            |m: &CreateIndexRequest| { &m.properties },
            |m: &mut CreateIndexRequest| { &mut m.properties },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateIndexRequest>(
            "CreateIndexRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateIndexRequest {
    const NAME: &'static str = "CreateIndexRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.label = is.read_string()?;
                },
                24 => {
                    self.MetaType = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                42 => {
                    self.properties.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            my_size += ::protobuf::rt::int32_size(3, self.MetaType.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        for value in &self.properties {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.MetaType))?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        for v in &self.properties {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateIndexRequest {
        CreateIndexRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.label.clear();
        self.MetaType = ::protobuf::EnumOrUnknown::new(MetaType::Graph);
        self.name.clear();
        self.properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateIndexRequest {
        static instance: CreateIndexRequest = CreateIndexRequest {
            graphName: ::std::string::String::new(),
            label: ::std::string::String::new(),
            MetaType: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            properties: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateIndexRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateIndexRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateIndexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateIndexRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CreateIndexResponse)
pub struct CreateIndexResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateIndexResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CreateIndexResponse.index)
    pub index: ::protobuf::MessageField<IndexMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CreateIndexResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateIndexResponse {
    fn default() -> &'a CreateIndexResponse {
        <CreateIndexResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateIndexResponse {
    pub fn new() -> CreateIndexResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &CreateIndexResponse| { &m.header },
            |m: &mut CreateIndexResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IndexMeta>(
            "index",
            |m: &CreateIndexResponse| { &m.index },
            |m: &mut CreateIndexResponse| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateIndexResponse>(
            "CreateIndexResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateIndexResponse {
    const NAME: &'static str = "CreateIndexResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.index)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.index.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateIndexResponse {
        CreateIndexResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.index.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateIndexResponse {
        static instance: CreateIndexResponse = CreateIndexResponse {
            header: ::protobuf::MessageField::none(),
            index: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateIndexResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateIndexResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateIndexResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateIndexResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropIndexRequest)
pub struct DropIndexRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropIndexRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropIndexRequest.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropIndexRequest.MetaType)
    pub MetaType: ::protobuf::EnumOrUnknown<MetaType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropIndexRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropIndexRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropIndexRequest {
    fn default() -> &'a DropIndexRequest {
        <DropIndexRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropIndexRequest {
    pub fn new() -> DropIndexRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &DropIndexRequest| { &m.graphName },
            |m: &mut DropIndexRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &DropIndexRequest| { &m.label },
            |m: &mut DropIndexRequest| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MetaType",
            |m: &DropIndexRequest| { &m.MetaType },
            |m: &mut DropIndexRequest| { &mut m.MetaType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DropIndexRequest| { &m.name },
            |m: &mut DropIndexRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropIndexRequest>(
            "DropIndexRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropIndexRequest {
    const NAME: &'static str = "DropIndexRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                18 => {
                    self.label = is.read_string()?;
                },
                24 => {
                    self.MetaType = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            my_size += ::protobuf::rt::int32_size(3, self.MetaType.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if self.MetaType != ::protobuf::EnumOrUnknown::new(MetaType::Graph) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.MetaType))?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropIndexRequest {
        DropIndexRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.label.clear();
        self.MetaType = ::protobuf::EnumOrUnknown::new(MetaType::Graph);
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropIndexRequest {
        static instance: DropIndexRequest = DropIndexRequest {
            graphName: ::std::string::String::new(),
            label: ::std::string::String::new(),
            MetaType: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropIndexRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropIndexRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropIndexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropIndexRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DropIndexResponse)
pub struct DropIndexResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DropIndexResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DropIndexResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DropIndexResponse {
    fn default() -> &'a DropIndexResponse {
        <DropIndexResponse as ::protobuf::Message>::default_instance()
    }
}

impl DropIndexResponse {
    pub fn new() -> DropIndexResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &DropIndexResponse| { &m.header },
            |m: &mut DropIndexResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropIndexResponse>(
            "DropIndexResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DropIndexResponse {
    const NAME: &'static str = "DropIndexResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DropIndexResponse {
        DropIndexResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DropIndexResponse {
        static instance: DropIndexResponse = DropIndexResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DropIndexResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DropIndexResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DropIndexResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropIndexResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Sync Meta RPC
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.VersionRecord)
pub struct VersionRecord {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VersionRecord.graph)
    pub graph: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.VersionRecord.version)
    pub version: i32,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.VersionRecord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VersionRecord {
    fn default() -> &'a VersionRecord {
        <VersionRecord as ::protobuf::Message>::default_instance()
    }
}

impl VersionRecord {
    pub fn new() -> VersionRecord {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph",
            |m: &VersionRecord| { &m.graph },
            |m: &mut VersionRecord| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &VersionRecord| { &m.version },
            |m: &mut VersionRecord| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VersionRecord>(
            "VersionRecord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VersionRecord {
    const NAME: &'static str = "VersionRecord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graph = is.read_string()?;
                },
                16 => {
                    self.version = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graph.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graph.is_empty() {
            os.write_string(1, &self.graph)?;
        }
        if self.version != 0 {
            os.write_int32(2, self.version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VersionRecord {
        VersionRecord::new()
    }

    fn clear(&mut self) {
        self.graph.clear();
        self.version = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VersionRecord {
        static instance: VersionRecord = VersionRecord {
            graph: ::std::string::String::new(),
            version: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VersionRecord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VersionRecord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VersionRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionRecord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DiffVersionRequest)
pub struct DiffVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DiffVersionRequest.versions)
    pub versions: ::std::vec::Vec<VersionRecord>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DiffVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiffVersionRequest {
    fn default() -> &'a DiffVersionRequest {
        <DiffVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DiffVersionRequest {
    pub fn new() -> DiffVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "versions",
            |m: &DiffVersionRequest| { &m.versions },
            |m: &mut DiffVersionRequest| { &mut m.versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiffVersionRequest>(
            "DiffVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiffVersionRequest {
    const NAME: &'static str = "DiffVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.versions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiffVersionRequest {
        DiffVersionRequest::new()
    }

    fn clear(&mut self) {
        self.versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiffVersionRequest {
        static instance: DiffVersionRequest = DiffVersionRequest {
            versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiffVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiffVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiffVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiffVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DiffVersionResponse)
pub struct DiffVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DiffVersionResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DiffVersionResponse.versions)
    pub versions: ::std::vec::Vec<VersionRecord>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DiffVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiffVersionResponse {
    fn default() -> &'a DiffVersionResponse {
        <DiffVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl DiffVersionResponse {
    pub fn new() -> DiffVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &DiffVersionResponse| { &m.header },
            |m: &mut DiffVersionResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "versions",
            |m: &DiffVersionResponse| { &m.versions },
            |m: &mut DiffVersionResponse| { &mut m.versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiffVersionResponse>(
            "DiffVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiffVersionResponse {
    const NAME: &'static str = "DiffVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiffVersionResponse {
        DiffVersionResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiffVersionResponse {
        static instance: DiffVersionResponse = DiffVersionResponse {
            header: ::protobuf::MessageField::none(),
            versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiffVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiffVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiffVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiffVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DoSnapshotGraphRequest)
pub struct DoSnapshotGraphRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DoSnapshotGraphRequest.snapshot_name)
    pub snapshot_name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DoSnapshotGraphRequest.graph_name)
    pub graph_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DoSnapshotGraphRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DoSnapshotGraphRequest {
    fn default() -> &'a DoSnapshotGraphRequest {
        <DoSnapshotGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl DoSnapshotGraphRequest {
    pub fn new() -> DoSnapshotGraphRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "snapshot_name",
            |m: &DoSnapshotGraphRequest| { &m.snapshot_name },
            |m: &mut DoSnapshotGraphRequest| { &mut m.snapshot_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph_name",
            |m: &DoSnapshotGraphRequest| { &m.graph_name },
            |m: &mut DoSnapshotGraphRequest| { &mut m.graph_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DoSnapshotGraphRequest>(
            "DoSnapshotGraphRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DoSnapshotGraphRequest {
    const NAME: &'static str = "DoSnapshotGraphRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshot_name = is.read_string()?;
                },
                18 => {
                    self.graph_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.snapshot_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot_name);
        }
        if !self.graph_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.graph_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.snapshot_name.is_empty() {
            os.write_string(1, &self.snapshot_name)?;
        }
        if !self.graph_name.is_empty() {
            os.write_string(2, &self.graph_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DoSnapshotGraphRequest {
        DoSnapshotGraphRequest::new()
    }

    fn clear(&mut self) {
        self.snapshot_name.clear();
        self.graph_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DoSnapshotGraphRequest {
        static instance: DoSnapshotGraphRequest = DoSnapshotGraphRequest {
            snapshot_name: ::std::string::String::new(),
            graph_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DoSnapshotGraphRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DoSnapshotGraphRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DoSnapshotGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoSnapshotGraphRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DoSnapshotGraphResponse)
pub struct DoSnapshotGraphResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DoSnapshotGraphResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DoSnapshotGraphResponse.meta)
    pub meta: ::protobuf::MessageField<GraphMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DoSnapshotGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DoSnapshotGraphResponse {
    fn default() -> &'a DoSnapshotGraphResponse {
        <DoSnapshotGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl DoSnapshotGraphResponse {
    pub fn new() -> DoSnapshotGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &DoSnapshotGraphResponse| { &m.header },
            |m: &mut DoSnapshotGraphResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GraphMeta>(
            "meta",
            |m: &DoSnapshotGraphResponse| { &m.meta },
            |m: &mut DoSnapshotGraphResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DoSnapshotGraphResponse>(
            "DoSnapshotGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DoSnapshotGraphResponse {
    const NAME: &'static str = "DoSnapshotGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DoSnapshotGraphResponse {
        DoSnapshotGraphResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DoSnapshotGraphResponse {
        static instance: DoSnapshotGraphResponse = DoSnapshotGraphResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DoSnapshotGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DoSnapshotGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DoSnapshotGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoSnapshotGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.GetSnapshotGraphRequest)
pub struct GetSnapshotGraphRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetSnapshotGraphRequest.snapshot_name)
    pub snapshot_name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetSnapshotGraphRequest.graph_name)
    pub graph_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.GetSnapshotGraphRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSnapshotGraphRequest {
    fn default() -> &'a GetSnapshotGraphRequest {
        <GetSnapshotGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotGraphRequest {
    pub fn new() -> GetSnapshotGraphRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "snapshot_name",
            |m: &GetSnapshotGraphRequest| { &m.snapshot_name },
            |m: &mut GetSnapshotGraphRequest| { &mut m.snapshot_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph_name",
            |m: &GetSnapshotGraphRequest| { &m.graph_name },
            |m: &mut GetSnapshotGraphRequest| { &mut m.graph_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSnapshotGraphRequest>(
            "GetSnapshotGraphRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSnapshotGraphRequest {
    const NAME: &'static str = "GetSnapshotGraphRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshot_name = is.read_string()?;
                },
                18 => {
                    self.graph_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.snapshot_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot_name);
        }
        if !self.graph_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.graph_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.snapshot_name.is_empty() {
            os.write_string(1, &self.snapshot_name)?;
        }
        if !self.graph_name.is_empty() {
            os.write_string(2, &self.graph_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSnapshotGraphRequest {
        GetSnapshotGraphRequest::new()
    }

    fn clear(&mut self) {
        self.snapshot_name.clear();
        self.graph_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSnapshotGraphRequest {
        static instance: GetSnapshotGraphRequest = GetSnapshotGraphRequest {
            snapshot_name: ::std::string::String::new(),
            graph_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSnapshotGraphRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSnapshotGraphRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSnapshotGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotGraphRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.GetSnapshotGraphResponse)
pub struct GetSnapshotGraphResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetSnapshotGraphResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.GetSnapshotGraphResponse.meta)
    pub meta: ::protobuf::MessageField<GraphMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.GetSnapshotGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSnapshotGraphResponse {
    fn default() -> &'a GetSnapshotGraphResponse {
        <GetSnapshotGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotGraphResponse {
    pub fn new() -> GetSnapshotGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &GetSnapshotGraphResponse| { &m.header },
            |m: &mut GetSnapshotGraphResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GraphMeta>(
            "meta",
            |m: &GetSnapshotGraphResponse| { &m.meta },
            |m: &mut GetSnapshotGraphResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSnapshotGraphResponse>(
            "GetSnapshotGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSnapshotGraphResponse {
    const NAME: &'static str = "GetSnapshotGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSnapshotGraphResponse {
        GetSnapshotGraphResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSnapshotGraphResponse {
        static instance: GetSnapshotGraphResponse = GetSnapshotGraphResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSnapshotGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSnapshotGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSnapshotGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.ListSnapshotGraphRequest)
pub struct ListSnapshotGraphRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.ListSnapshotGraphRequest.graph_name)
    pub graph_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.ListSnapshotGraphRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSnapshotGraphRequest {
    fn default() -> &'a ListSnapshotGraphRequest {
        <ListSnapshotGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSnapshotGraphRequest {
    pub fn new() -> ListSnapshotGraphRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph_name",
            |m: &ListSnapshotGraphRequest| { &m.graph_name },
            |m: &mut ListSnapshotGraphRequest| { &mut m.graph_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSnapshotGraphRequest>(
            "ListSnapshotGraphRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSnapshotGraphRequest {
    const NAME: &'static str = "ListSnapshotGraphRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.graph_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graph_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.graph_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graph_name.is_empty() {
            os.write_string(2, &self.graph_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSnapshotGraphRequest {
        ListSnapshotGraphRequest::new()
    }

    fn clear(&mut self) {
        self.graph_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSnapshotGraphRequest {
        static instance: ListSnapshotGraphRequest = ListSnapshotGraphRequest {
            graph_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSnapshotGraphRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSnapshotGraphRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSnapshotGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSnapshotGraphRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.ListSnapshotGraphResponse)
pub struct ListSnapshotGraphResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.ListSnapshotGraphResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.ListSnapshotGraphResponse.snapshot_name)
    pub snapshot_name: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.ListSnapshotGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSnapshotGraphResponse {
    fn default() -> &'a ListSnapshotGraphResponse {
        <ListSnapshotGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSnapshotGraphResponse {
    pub fn new() -> ListSnapshotGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &ListSnapshotGraphResponse| { &m.header },
            |m: &mut ListSnapshotGraphResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshot_name",
            |m: &ListSnapshotGraphResponse| { &m.snapshot_name },
            |m: &mut ListSnapshotGraphResponse| { &mut m.snapshot_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSnapshotGraphResponse>(
            "ListSnapshotGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSnapshotGraphResponse {
    const NAME: &'static str = "ListSnapshotGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    self.snapshot_name.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.snapshot_name {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.snapshot_name {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSnapshotGraphResponse {
        ListSnapshotGraphResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.snapshot_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSnapshotGraphResponse {
        static instance: ListSnapshotGraphResponse = ListSnapshotGraphResponse {
            header: ::protobuf::MessageField::none(),
            snapshot_name: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSnapshotGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSnapshotGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSnapshotGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSnapshotGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.RestoreSnapshotGraphRequest)
pub struct RestoreSnapshotGraphRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.RestoreSnapshotGraphRequest.snapshot_name)
    pub snapshot_name: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.RestoreSnapshotGraphRequest.graph_name)
    pub graph_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.RestoreSnapshotGraphRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RestoreSnapshotGraphRequest {
    fn default() -> &'a RestoreSnapshotGraphRequest {
        <RestoreSnapshotGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl RestoreSnapshotGraphRequest {
    pub fn new() -> RestoreSnapshotGraphRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "snapshot_name",
            |m: &RestoreSnapshotGraphRequest| { &m.snapshot_name },
            |m: &mut RestoreSnapshotGraphRequest| { &mut m.snapshot_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph_name",
            |m: &RestoreSnapshotGraphRequest| { &m.graph_name },
            |m: &mut RestoreSnapshotGraphRequest| { &mut m.graph_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RestoreSnapshotGraphRequest>(
            "RestoreSnapshotGraphRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RestoreSnapshotGraphRequest {
    const NAME: &'static str = "RestoreSnapshotGraphRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.snapshot_name = is.read_string()?;
                },
                18 => {
                    self.graph_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.snapshot_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot_name);
        }
        if !self.graph_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.graph_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.snapshot_name.is_empty() {
            os.write_string(1, &self.snapshot_name)?;
        }
        if !self.graph_name.is_empty() {
            os.write_string(2, &self.graph_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RestoreSnapshotGraphRequest {
        RestoreSnapshotGraphRequest::new()
    }

    fn clear(&mut self) {
        self.snapshot_name.clear();
        self.graph_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RestoreSnapshotGraphRequest {
        static instance: RestoreSnapshotGraphRequest = RestoreSnapshotGraphRequest {
            snapshot_name: ::std::string::String::new(),
            graph_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RestoreSnapshotGraphRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RestoreSnapshotGraphRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RestoreSnapshotGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreSnapshotGraphRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.RestoreSnapshotGraphResponse)
pub struct RestoreSnapshotGraphResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.RestoreSnapshotGraphResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.RestoreSnapshotGraphResponse.meta)
    pub meta: ::protobuf::MessageField<GraphMeta>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.RestoreSnapshotGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RestoreSnapshotGraphResponse {
    fn default() -> &'a RestoreSnapshotGraphResponse {
        <RestoreSnapshotGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl RestoreSnapshotGraphResponse {
    pub fn new() -> RestoreSnapshotGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &RestoreSnapshotGraphResponse| { &m.header },
            |m: &mut RestoreSnapshotGraphResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GraphMeta>(
            "meta",
            |m: &RestoreSnapshotGraphResponse| { &m.meta },
            |m: &mut RestoreSnapshotGraphResponse| { &mut m.meta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RestoreSnapshotGraphResponse>(
            "RestoreSnapshotGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RestoreSnapshotGraphResponse {
    const NAME: &'static str = "RestoreSnapshotGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.meta)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.meta.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RestoreSnapshotGraphResponse {
        RestoreSnapshotGraphResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.meta.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RestoreSnapshotGraphResponse {
        static instance: RestoreSnapshotGraphResponse = RestoreSnapshotGraphResponse {
            header: ::protobuf::MessageField::none(),
            meta: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RestoreSnapshotGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RestoreSnapshotGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RestoreSnapshotGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreSnapshotGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.HealthCheckRequest)
pub struct HealthCheckRequest {
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.HealthCheckRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HealthCheckRequest {
    fn default() -> &'a HealthCheckRequest {
        <HealthCheckRequest as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheckRequest {
    pub fn new() -> HealthCheckRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HealthCheckRequest>(
            "HealthCheckRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HealthCheckRequest {
    const NAME: &'static str = "HealthCheckRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HealthCheckRequest {
        HealthCheckRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HealthCheckRequest {
        static instance: HealthCheckRequest = HealthCheckRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HealthCheckRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HealthCheckRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HealthCheckRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.HealthCheckResponse)
pub struct HealthCheckResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.HealthCheckResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.HealthCheckResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HealthCheckResponse {
    fn default() -> &'a HealthCheckResponse {
        <HealthCheckResponse as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheckResponse {
    pub fn new() -> HealthCheckResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &HealthCheckResponse| { &m.header },
            |m: &mut HealthCheckResponse| { &mut m.header },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HealthCheckResponse>(
            "HealthCheckResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HealthCheckResponse {
    const NAME: &'static str = "HealthCheckResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HealthCheckResponse {
        HealthCheckResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HealthCheckResponse {
        static instance: HealthCheckResponse = HealthCheckResponse {
            header: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HealthCheckResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HealthCheckResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HealthCheckResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.IDRange)
pub struct IDRange {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.IDRange.from)
    pub from: i64,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.IDRange.delta)
    pub delta: i32,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.IDRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IDRange {
    fn default() -> &'a IDRange {
        <IDRange as ::protobuf::Message>::default_instance()
    }
}

impl IDRange {
    pub fn new() -> IDRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from",
            |m: &IDRange| { &m.from },
            |m: &mut IDRange| { &mut m.from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delta",
            |m: &IDRange| { &m.delta },
            |m: &mut IDRange| { &mut m.delta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IDRange>(
            "IDRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IDRange {
    const NAME: &'static str = "IDRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.from = is.read_int64()?;
                },
                24 => {
                    self.delta = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.from != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.from);
        }
        if self.delta != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.delta);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.from != 0 {
            os.write_int64(2, self.from)?;
        }
        if self.delta != 0 {
            os.write_int32(3, self.delta)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IDRange {
        IDRange::new()
    }

    fn clear(&mut self) {
        self.from = 0;
        self.delta = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IDRange {
        static instance: IDRange = IDRange {
            from: 0,
            delta: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IDRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IDRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IDRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IDRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.AllocateIDRequest)
pub struct AllocateIDRequest {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.AllocateIDRequest.graphName)
    pub graphName: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.AllocateIDRequest.delta)
    pub delta: i32,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.AllocateIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocateIDRequest {
    fn default() -> &'a AllocateIDRequest {
        <AllocateIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl AllocateIDRequest {
    pub fn new() -> AllocateIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graphName",
            |m: &AllocateIDRequest| { &m.graphName },
            |m: &mut AllocateIDRequest| { &mut m.graphName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delta",
            |m: &AllocateIDRequest| { &m.delta },
            |m: &mut AllocateIDRequest| { &mut m.delta },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocateIDRequest>(
            "AllocateIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocateIDRequest {
    const NAME: &'static str = "AllocateIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.graphName = is.read_string()?;
                },
                16 => {
                    self.delta = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.graphName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graphName);
        }
        if self.delta != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.delta);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.graphName.is_empty() {
            os.write_string(1, &self.graphName)?;
        }
        if self.delta != 0 {
            os.write_int32(2, self.delta)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocateIDRequest {
        AllocateIDRequest::new()
    }

    fn clear(&mut self) {
        self.graphName.clear();
        self.delta = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocateIDRequest {
        static instance: AllocateIDRequest = AllocateIDRequest {
            graphName: ::std::string::String::new(),
            delta: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocateIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocateIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocateIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocateIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.AllocateIDResponse)
pub struct AllocateIDResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.AllocateIDResponse.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.AllocateIDResponse.range)
    pub range: ::protobuf::MessageField<IDRange>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.AllocateIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllocateIDResponse {
    fn default() -> &'a AllocateIDResponse {
        <AllocateIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl AllocateIDResponse {
    pub fn new() -> AllocateIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &AllocateIDResponse| { &m.header },
            |m: &mut AllocateIDResponse| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IDRange>(
            "range",
            |m: &AllocateIDResponse| { &m.range },
            |m: &mut AllocateIDResponse| { &mut m.range },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllocateIDResponse>(
            "AllocateIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllocateIDResponse {
    const NAME: &'static str = "AllocateIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.range)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllocateIDResponse {
        AllocateIDResponse::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.range.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllocateIDResponse {
        static instance: AllocateIDResponse = AllocateIDResponse {
            header: ::protobuf::MessageField::none(),
            range: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllocateIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllocateIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllocateIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllocateIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:com.tencent.easygraph.proto.DataType)
pub enum DataType {
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataType.T_INT)
    T_INT = 0,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataType.T_LONG)
    T_LONG = 1,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataType.T_DOUBLE)
    T_DOUBLE = 2,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataType.T_FLOAT)
    T_FLOAT = 3,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataType.T_SHORT)
    T_SHORT = 4,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataType.T_STRING)
    T_STRING = 5,
}

impl ::protobuf::Enum for DataType {
    const NAME: &'static str = "DataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataType> {
        match value {
            0 => ::std::option::Option::Some(DataType::T_INT),
            1 => ::std::option::Option::Some(DataType::T_LONG),
            2 => ::std::option::Option::Some(DataType::T_DOUBLE),
            3 => ::std::option::Option::Some(DataType::T_FLOAT),
            4 => ::std::option::Option::Some(DataType::T_SHORT),
            5 => ::std::option::Option::Some(DataType::T_STRING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DataType] = &[
        DataType::T_INT,
        DataType::T_LONG,
        DataType::T_DOUBLE,
        DataType::T_FLOAT,
        DataType::T_SHORT,
        DataType::T_STRING,
    ];
}

impl ::protobuf::EnumFull for DataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DataType {
    fn default() -> Self {
        DataType::T_INT
    }
}

impl DataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataType>("DataType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:com.tencent.easygraph.proto.MetaType)
pub enum MetaType {
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.MetaType.Graph)
    Graph = 0,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.MetaType.Vertex)
    Vertex = 1,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.MetaType.Edge)
    Edge = 2,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.MetaType.Index)
    Index = 3,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.MetaType.Property)
    Property = 4,
}

impl ::protobuf::Enum for MetaType {
    const NAME: &'static str = "MetaType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MetaType> {
        match value {
            0 => ::std::option::Option::Some(MetaType::Graph),
            1 => ::std::option::Option::Some(MetaType::Vertex),
            2 => ::std::option::Option::Some(MetaType::Edge),
            3 => ::std::option::Option::Some(MetaType::Index),
            4 => ::std::option::Option::Some(MetaType::Property),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MetaType] = &[
        MetaType::Graph,
        MetaType::Vertex,
        MetaType::Edge,
        MetaType::Index,
        MetaType::Property,
    ];
}

impl ::protobuf::EnumFull for MetaType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MetaType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MetaType {
    fn default() -> Self {
        MetaType::Graph
    }
}

impl MetaType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MetaType>("MetaType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nmeta.proto\x12\x1bcom.tencent.easygraph.proto\"c\n\x06Header\x12\x18\
    \n\x07success\x18\x01\x20\x01(\x08R\x07success\x12\x12\n\x04code\x18\x02\
    \x20\x01(\x05R\x04code\x12\x10\n\x03msg\x18\x03\x20\x01(\tR\x03msg\x12\
    \x19\n\x08trace_id\x18\x04\x20\x01(\x03R\x07traceId\"k\n\x08MetaDesc\x12\
    9\n\x04type\x18\x01\x20\x01(\x0e2%.com.tencent.easygraph.proto.MetaTypeR\
    \x04type\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x12\n\x04meta\
    \x18\x03\x20\x01(\x0cR\x04meta\"\x95\x03\n\x0cPropertyMeta\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\rR\x02id\x12\"\n\x0cpropertyName\x18\x02\x20\x01(\tR\
    \x0cpropertyName\x12A\n\x08dataType\x18\x03\x20\x01(\x0e2%.com.tencent.e\
    asygraph.proto.DataTypeR\x08dataType\x12\"\n\x0cdefaultValue\x18\x04\x20\
    \x01(\x0cR\x0cdefaultValue\x12\x18\n\x07comment\x18\x05\x20\x01(\tR\x07c\
    omment\x12\x14\n\x05alias\x18\x06\x20\x01(\tR\x05alias\x12\x1a\n\x08vert\
    ices\x18\x07\x20\x03(\rR\x08vertices\x12\x14\n\x05edges\x18\x08\x20\x03(\
    \rR\x05edges\x12M\n\x06config\x18\t\x20\x03(\x0b25.com.tencent.easygraph\
    .proto.PropertyMeta.ConfigEntryR\x06config\x1a9\n\x0bConfigEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\"\x9d\x07\n\tGraphMeta\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1f\
    \n\x0bcreate_time\x18\x03\x20\x01(\x03R\ncreateTime\x12\x18\n\x07version\
    \x18\x04\x20\x01(\x05R\x07version\x12#\n\rpartition_num\x18\x05\x20\x01(\
    \rR\x0cpartitionNum\x12\x18\n\x07comment\x18\x06\x20\x01(\tR\x07comment\
    \x12\x14\n\x05alias\x18\x07\x20\x01(\tR\x05alias\x12c\n\x0fproperties_me\
    ta\x18\x08\x20\x03(\x0b2:.com.tencent.easygraph.proto.GraphMeta.Properti\
    esMetaEntryR\x0epropertiesMeta\x12]\n\rvertices_meta\x18\t\x20\x03(\x0b2\
    8.com.tencent.easygraph.proto.GraphMeta.VerticesMetaEntryR\x0cverticesMe\
    ta\x12T\n\nedges_meta\x18\n\x20\x03(\x0b25.com.tencent.easygraph.proto.G\
    raphMeta.EdgesMetaEntryR\tedgesMeta\x12J\n\x06config\x18\x0b\x20\x03(\
    \x0b22.com.tencent.easygraph.proto.GraphMeta.ConfigEntryR\x06config\x1al\
    \n\x13PropertiesMetaEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12?\n\x05value\x18\x02\x20\x01(\x0b2).com.tencent.easygraph.proto.Prop\
    ertyMetaR\x05value:\x028\x01\x1ah\n\x11VerticesMetaEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12=\n\x05value\x18\x02\x20\x01(\x0b2'.com.\
    tencent.easygraph.proto.VertexMetaR\x05value:\x028\x01\x1ac\n\x0eEdgesMe\
    taEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12;\n\x05value\x18\
    \x02\x20\x01(\x0b2%.com.tencent.easygraph.proto.EdgeMetaR\x05value:\x028\
    \x01\x1a9\n\x0bConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x94\x04\n\n\
    VertexMeta\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x1f\n\x0bprimary_key\x18\x03\x20\x01(\t\
    R\nprimaryKey\x12\x1f\n\x0bcreate_time\x18\x04\x20\x01(\x03R\ncreateTime\
    \x12\x18\n\x07comment\x18\x05\x20\x01(\tR\x07comment\x12\x14\n\x05alias\
    \x18\x06\x20\x01(\tR\x05alias\x12\x1e\n\nproperties\x18\x07\x20\x03(\rR\
    \nproperties\x12\x14\n\x05edges\x18\x08\x20\x03(\rR\x05edges\x12K\n\x06c\
    onfig\x18\t\x20\x03(\x0b23.com.tencent.easygraph.proto.VertexMeta.Config\
    EntryR\x06config\x12N\n\x07indices\x18\n\x20\x03(\x0b24.com.tencent.easy\
    graph.proto.VertexMeta.IndicesEntryR\x07indices\x1a9\n\x0bConfigEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1ab\n\x0cIndicesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12<\n\x05value\x18\x02\x20\x01(\x0b2&.com.t\
    encent.easygraph.proto.IndexMetaR\x05value:\x028\x01\"\x9b\x04\n\x08Edge\
    Meta\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x20\n\x0csrc_label_id\x18\x03\x20\x01(\rR\nsrcL\
    abelId\x12\x20\n\x0cdst_label_id\x18\x04\x20\x01(\rR\ndstLabelId\x12\x1f\
    \n\x0bcreate_time\x18\x05\x20\x01(\x03R\ncreateTime\x12\x18\n\x07comment\
    \x18\x07\x20\x01(\tR\x07comment\x12\x14\n\x05alias\x18\x08\x20\x01(\tR\
    \x05alias\x12\x1e\n\nproperties\x18\t\x20\x03(\rR\nproperties\x12I\n\x06\
    config\x18\n\x20\x03(\x0b21.com.tencent.easygraph.proto.EdgeMeta.ConfigE\
    ntryR\x06config\x12L\n\x07indices\x18\x0b\x20\x03(\x0b22.com.tencent.eas\
    ygraph.proto.EdgeMeta.IndicesEntryR\x07indices\x1a9\n\x0bConfigEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1ab\n\x0cIndicesEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12<\n\x05value\x18\x02\x20\x01(\x0b2&.com.tence\
    nt.easygraph.proto.IndexMetaR\x05value:\x028\x01\"\xf7\x01\n\tIndexMeta\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x1e\n\nproperties\x18\x03\x20\x03(\tR\nproperties\
    \x12\x1f\n\x0bcreate_time\x18\x04\x20\x01(\x03R\ncreateTime\x12J\n\x06co\
    nfig\x18\x05\x20\x03(\x0b22.com.tencent.easygraph.proto.IndexMeta.Config\
    EntryR\x06config\x1a9\n\x0bConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"M\
    \n\x12CreateGraphRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12#\n\rpartition_num\x18\x02\x20\x01(\rR\x0cpartitionNum\"\x8e\x01\n\
    \x13CreateGraphResponse\x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tenc\
    ent.easygraph.proto.HeaderR\x06header\x12:\n\x04meta\x18\x02\x20\x01(\
    \x0b2&.com.tencent.easygraph.proto.GraphMetaR\x04meta\"*\n\x14DropGraphM\
    etaRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"T\n\x15DropGra\
    phMetaResponse\x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easyg\
    raph.proto.HeaderR\x06header\")\n\x13GetGraphMetaRequest\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\"\x8f\x01\n\x14GetGraphMetaResponse\x12;\
    \n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\
    \x06header\x12:\n\x04meta\x18\x02\x20\x01(\x0b2&.com.tencent.easygraph.p\
    roto.GraphMetaR\x04meta\"\x18\n\x16GetAllGraphMetaRequest\"\x92\x01\n\
    \x17GetAllGraphMetaResponse\x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.\
    tencent.easygraph.proto.HeaderR\x06header\x12:\n\x04meta\x18\x02\x20\x03\
    (\x0b2&.com.tencent.easygraph.proto.GraphMetaR\x04meta\"\xc0\x01\n\x15Cr\
    eatePropertyRequest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgraphName\
    \x12\"\n\x0cpropertyName\x18\x02\x20\x01(\tR\x0cpropertyName\x12A\n\x08d\
    ataType\x18\x03\x20\x01(\x0e2%.com.tencent.easygraph.proto.DataTypeR\x08\
    dataType\x12\"\n\x0cdefaultValue\x18\x04\x20\x01(\x0cR\x0cdefaultValue\"\
    \x94\x01\n\x16CreatePropertyResponse\x12;\n\x06header\x18\x01\x20\x01(\
    \x0b2#.com.tencent.easygraph.proto.HeaderR\x06header\x12=\n\x04meta\x18\
    \x02\x20\x01(\x0b2).com.tencent.easygraph.proto.PropertyMetaR\x04meta\"v\
    \n\x17DropPropertyMetaRequest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\t\
    graphName\x12\"\n\x0cpropertyName\x18\x02\x20\x01(\tR\x0cpropertyName\
    \x12\x19\n\x08trace_id\x18\x03\x20\x01(\x03R\x07traceId\"W\n\x18DropProp\
    ertyMetaResponse\x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.eas\
    ygraph.proto.HeaderR\x06header\"\x81\x01\n\x19UpdatePropertyMetaRequest\
    \x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgraphName\x12\"\n\x0cproperty\
    Name\x18\x02\x20\x01(\tR\x0cpropertyName\x12\"\n\x0cdefaultValue\x18\x04\
    \x20\x01(\x0cR\x0cdefaultValue\"Y\n\x1aUpdatePropertyMetaResponse\x12;\n\
    \x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\
    \x06header\"\xaf\x01\n\x13CreateVertexRequest\x12\x1c\n\tgraphName\x18\
    \x01\x20\x01(\tR\tgraphName\x12\x1e\n\nvertexName\x18\x02\x20\x01(\tR\nv\
    ertexName\x12\x1f\n\x0bprimary_key\x18\x03\x20\x01(\tR\nprimaryKey\x12\
    \x1e\n\nproperties\x18\x04\x20\x03(\tR\nproperties\x12\x19\n\x08trace_id\
    \x18\x05\x20\x01(\x03R\x07traceId\"\x90\x01\n\x14CreateVertexResponse\
    \x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.Hea\
    derR\x06header\x12;\n\x04meta\x18\x02\x20\x01(\x0b2'.com.tencent.easygra\
    ph.proto.VertexMetaR\x04meta\"p\n\x15DropVertexMetaRequest\x12\x1c\n\tgr\
    aphName\x18\x01\x20\x01(\tR\tgraphName\x12\x1e\n\nvertexName\x18\x02\x20\
    \x01(\tR\nvertexName\x12\x19\n\x08trace_id\x18\x03\x20\x01(\x03R\x07trac\
    eId\"U\n\x16DropVertexMetaResponse\x12;\n\x06header\x18\x01\x20\x01(\x0b\
    2#.com.tencent.easygraph.proto.HeaderR\x06header\"\x92\x01\n\x17UpdateVe\
    rtexMetaRequest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgraphName\x12\
    \x1e\n\nvertexName\x18\x02\x20\x01(\tR\nvertexName\x12\x1e\n\nproperties\
    \x18\x03\x20\x03(\tR\nproperties\x12\x19\n\x08trace_id\x18\x04\x20\x01(\
    \x03R\x07traceId\"W\n\x18UpdateVertexMetaResponse\x12;\n\x06header\x18\
    \x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\x06header\"\xba\
    \x01\n\x11CreateEdgeRequest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgr\
    aphName\x12\x1a\n\x08edgeName\x18\x02\x20\x01(\tR\x08edgeName\x12\x18\n\
    \x07subject\x18\x03\x20\x01(\tR\x07subject\x12\x16\n\x06object\x18\x04\
    \x20\x01(\tR\x06object\x12\x1e\n\nproperties\x18\x05\x20\x03(\tR\nproper\
    ties\x12\x19\n\x08trace_id\x18\x06\x20\x01(\x03R\x07traceId\"\x8c\x01\n\
    \x12CreateEdgeResponse\x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tence\
    nt.easygraph.proto.HeaderR\x06header\x129\n\x04meta\x18\x02\x20\x01(\x0b\
    2%.com.tencent.easygraph.proto.EdgeMetaR\x04meta\"j\n\x13DropEdgeMetaReq\
    uest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgraphName\x12\x1a\n\x08ed\
    geName\x18\x02\x20\x01(\tR\x08edgeName\x12\x19\n\x08trace_id\x18\x03\x20\
    \x01(\x03R\x07traceId\"S\n\x14DropEdgeMetaResponse\x12;\n\x06header\x18\
    \x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\x06header\"\x8c\
    \x01\n\x15UpdateEdgeMetaRequest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\
    \tgraphName\x12\x1a\n\x08edgeName\x18\x02\x20\x01(\tR\x08edgeName\x12\
    \x1e\n\nproperties\x18\x03\x20\x03(\tR\nproperties\x12\x19\n\x08trace_id\
    \x18\x04\x20\x01(\x03R\x07traceId\"U\n\x16UpdateEdgeMetaResponse\x12;\n\
    \x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\
    \x06header\"\xb2\x01\n\x13UpdateConfigRequest\x12\x1c\n\tgraphName\x18\
    \x01\x20\x01(\tR\tgraphName\x12A\n\x08MetaType\x18\x02\x20\x01(\x0e2%.co\
    m.tencent.easygraph.proto.MetaTypeR\x08MetaType\x12\x12\n\x04name\x18\
    \x03\x20\x01(\tR\x04name\x12\x10\n\x03key\x18\x04\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x05\x20\x01(\tR\x05value\"S\n\x14UpdateConfigRespons\
    e\x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.He\
    aderR\x06header\"\x9f\x01\n\x12UpdateAliasRequest\x12\x1c\n\tgraphName\
    \x18\x01\x20\x01(\tR\tgraphName\x12A\n\x08MetaType\x18\x02\x20\x01(\x0e2\
    %.com.tencent.easygraph.proto.MetaTypeR\x08MetaType\x12\x12\n\x04name\
    \x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x04\x20\x01(\tR\x05v\
    alue\"R\n\x13UpdateAliasResponse\x12;\n\x06header\x18\x01\x20\x01(\x0b2#\
    .com.tencent.easygraph.proto.HeaderR\x06header\"\xa1\x01\n\x14UpdateComm\
    entRequest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgraphName\x12A\n\
    \x08MetaType\x18\x02\x20\x01(\x0e2%.com.tencent.easygraph.proto.MetaType\
    R\x08MetaType\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x14\n\
    \x05value\x18\x04\x20\x01(\tR\x05value\"T\n\x15UpdateCommentResponse\x12\
    ;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\
    \x06header\"\xbf\x01\n\x12CreateIndexRequest\x12\x1c\n\tgraphName\x18\
    \x01\x20\x01(\tR\tgraphName\x12\x14\n\x05label\x18\x02\x20\x01(\tR\x05la\
    bel\x12A\n\x08MetaType\x18\x03\x20\x01(\x0e2%.com.tencent.easygraph.prot\
    o.MetaTypeR\x08MetaType\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\
    \x12\x1e\n\nproperties\x18\x05\x20\x03(\tR\nproperties\"\x90\x01\n\x13Cr\
    eateIndexResponse\x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.ea\
    sygraph.proto.HeaderR\x06header\x12<\n\x05index\x18\x02\x20\x01(\x0b2&.c\
    om.tencent.easygraph.proto.IndexMetaR\x05index\"\x9d\x01\n\x10DropIndexR\
    equest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgraphName\x12\x14\n\x05\
    label\x18\x02\x20\x01(\tR\x05label\x12A\n\x08MetaType\x18\x03\x20\x01(\
    \x0e2%.com.tencent.easygraph.proto.MetaTypeR\x08MetaType\x12\x12\n\x04na\
    me\x18\x04\x20\x01(\tR\x04name\"P\n\x11DropIndexResponse\x12;\n\x06heade\
    r\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\x06header\"\
    ?\n\rVersionRecord\x12\x14\n\x05graph\x18\x01\x20\x01(\tR\x05graph\x12\
    \x18\n\x07version\x18\x02\x20\x01(\x05R\x07version\"\\\n\x12DiffVersionR\
    equest\x12F\n\x08versions\x18\x01\x20\x03(\x0b2*.com.tencent.easygraph.p\
    roto.VersionRecordR\x08versions\"\x9a\x01\n\x13DiffVersionResponse\x12;\
    \n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\
    \x06header\x12F\n\x08versions\x18\x02\x20\x03(\x0b2*.com.tencent.easygra\
    ph.proto.VersionRecordR\x08versions\"\\\n\x16DoSnapshotGraphRequest\x12#\
    \n\rsnapshot_name\x18\x01\x20\x01(\tR\x0csnapshotName\x12\x1d\n\ngraph_n\
    ame\x18\x02\x20\x01(\tR\tgraphName\"\x92\x01\n\x17DoSnapshotGraphRespons\
    e\x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.He\
    aderR\x06header\x12:\n\x04meta\x18\x02\x20\x01(\x0b2&.com.tencent.easygr\
    aph.proto.GraphMetaR\x04meta\"]\n\x17GetSnapshotGraphRequest\x12#\n\rsna\
    pshot_name\x18\x01\x20\x01(\tR\x0csnapshotName\x12\x1d\n\ngraph_name\x18\
    \x02\x20\x01(\tR\tgraphName\"\x93\x01\n\x18GetSnapshotGraphResponse\x12;\
    \n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\
    \x06header\x12:\n\x04meta\x18\x02\x20\x01(\x0b2&.com.tencent.easygraph.p\
    roto.GraphMetaR\x04meta\"9\n\x18ListSnapshotGraphRequest\x12\x1d\n\ngrap\
    h_name\x18\x02\x20\x01(\tR\tgraphName\"}\n\x19ListSnapshotGraphResponse\
    \x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.Hea\
    derR\x06header\x12#\n\rsnapshot_name\x18\x02\x20\x03(\tR\x0csnapshotName\
    \"a\n\x1bRestoreSnapshotGraphRequest\x12#\n\rsnapshot_name\x18\x01\x20\
    \x01(\tR\x0csnapshotName\x12\x1d\n\ngraph_name\x18\x02\x20\x01(\tR\tgrap\
    hName\"\x97\x01\n\x1cRestoreSnapshotGraphResponse\x12;\n\x06header\x18\
    \x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\x06header\x12:\n\
    \x04meta\x18\x02\x20\x01(\x0b2&.com.tencent.easygraph.proto.GraphMetaR\
    \x04meta\"\x14\n\x12HealthCheckRequest\"R\n\x13HealthCheckResponse\x12;\
    \n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.HeaderR\
    \x06header\"3\n\x07IDRange\x12\x12\n\x04from\x18\x02\x20\x01(\x03R\x04fr\
    om\x12\x14\n\x05delta\x18\x03\x20\x01(\x05R\x05delta\"G\n\x11AllocateIDR\
    equest\x12\x1c\n\tgraphName\x18\x01\x20\x01(\tR\tgraphName\x12\x14\n\x05\
    delta\x18\x02\x20\x01(\x05R\x05delta\"\x8d\x01\n\x12AllocateIDResponse\
    \x12;\n\x06header\x18\x01\x20\x01(\x0b2#.com.tencent.easygraph.proto.Hea\
    derR\x06header\x12:\n\x05range\x18\x02\x20\x01(\x0b2$.com.tencent.easygr\
    aph.proto.IDRangeR\x05range*W\n\x08DataType\x12\t\n\x05T_INT\x10\0\x12\n\
    \n\x06T_LONG\x10\x01\x12\x0c\n\x08T_DOUBLE\x10\x02\x12\x0b\n\x07T_FLOAT\
    \x10\x03\x12\x0b\n\x07T_SHORT\x10\x04\x12\x0c\n\x08T_STRING\x10\x05*D\n\
    \x08MetaType\x12\t\n\x05Graph\x10\0\x12\n\n\x06Vertex\x10\x01\x12\x08\n\
    \x04Edge\x10\x02\x12\t\n\x05Index\x10\x03\x12\x0c\n\x08Property\x10\x042\
    \xdc\x17\n\x0eMetaRpcService\x12t\n\x0fcreateGraphMeta\x12/.com.tencent.\
    easygraph.proto.CreateGraphRequest\x1a0.com.tencent.easygraph.proto.Crea\
    teGraphResponse\x12v\n\rdropGraphMeta\x121.com.tencent.easygraph.proto.D\
    ropGraphMetaRequest\x1a2.com.tencent.easygraph.proto.DropGraphMetaRespon\
    se\x12s\n\x0cgetGraphMeta\x120.com.tencent.easygraph.proto.GetGraphMetaR\
    equest\x1a1.com.tencent.easygraph.proto.GetGraphMetaResponse\x12|\n\x0fg\
    etAllGraphMeta\x123.com.tencent.easygraph.proto.GetAllGraphMetaRequest\
    \x1a4.com.tencent.easygraph.proto.GetAllGraphMetaResponse\x12}\n\x12crea\
    tePropertyMeta\x122.com.tencent.easygraph.proto.CreatePropertyRequest\
    \x1a3.com.tencent.easygraph.proto.CreatePropertyResponse\x12\x7f\n\x10dr\
    opPropertyMeta\x124.com.tencent.easygraph.proto.DropPropertyMetaRequest\
    \x1a5.com.tencent.easygraph.proto.DropPropertyMetaResponse\x12\x85\x01\n\
    \x12updatePropertyMeta\x126.com.tencent.easygraph.proto.UpdatePropertyMe\
    taRequest\x1a7.com.tencent.easygraph.proto.UpdatePropertyMetaResponse\
    \x12w\n\x10createVertexMeta\x120.com.tencent.easygraph.proto.CreateVerte\
    xRequest\x1a1.com.tencent.easygraph.proto.CreateVertexResponse\x12y\n\
    \x0edropVertexMeta\x122.com.tencent.easygraph.proto.DropVertexMetaReques\
    t\x1a3.com.tencent.easygraph.proto.DropVertexMetaResponse\x12\x7f\n\x10u\
    pdateVertexMeta\x124.com.tencent.easygraph.proto.UpdateVertexMetaRequest\
    \x1a5.com.tencent.easygraph.proto.UpdateVertexMetaResponse\x12q\n\x0ecre\
    ateEdgeMeta\x12..com.tencent.easygraph.proto.CreateEdgeRequest\x1a/.com.\
    tencent.easygraph.proto.CreateEdgeResponse\x12s\n\x0cdropEdgeMeta\x120.c\
    om.tencent.easygraph.proto.DropEdgeMetaRequest\x1a1.com.tencent.easygrap\
    h.proto.DropEdgeMetaResponse\x12y\n\x0eupdateEdgeMeta\x122.com.tencent.e\
    asygraph.proto.UpdateEdgeMetaRequest\x1a3.com.tencent.easygraph.proto.Up\
    dateEdgeMetaResponse\x12s\n\x0cupdateConfig\x120.com.tencent.easygraph.p\
    roto.UpdateConfigRequest\x1a1.com.tencent.easygraph.proto.UpdateConfigRe\
    sponse\x12p\n\x0bupdateAlias\x12/.com.tencent.easygraph.proto.UpdateAlia\
    sRequest\x1a0.com.tencent.easygraph.proto.UpdateAliasResponse\x12v\n\rup\
    dateComment\x121.com.tencent.easygraph.proto.UpdateCommentRequest\x1a2.c\
    om.tencent.easygraph.proto.UpdateCommentResponse\x12p\n\x0bcreateIndex\
    \x12/.com.tencent.easygraph.proto.CreateIndexRequest\x1a0.com.tencent.ea\
    sygraph.proto.CreateIndexResponse\x12j\n\tdropIndex\x12-.com.tencent.eas\
    ygraph.proto.DropIndexRequest\x1a..com.tencent.easygraph.proto.DropIndex\
    Response\x12p\n\x0bdiffVersion\x12/.com.tencent.easygraph.proto.DiffVers\
    ionRequest\x1a0.com.tencent.easygraph.proto.DiffVersionResponse\x12w\n\n\
    doSnapshot\x123.com.tencent.easygraph.proto.DoSnapshotGraphRequest\x1a4.\
    com.tencent.easygraph.proto.DoSnapshotGraphResponse\x12z\n\x0bgetSnapsho\
    t\x124.com.tencent.easygraph.proto.GetSnapshotGraphRequest\x1a5.com.tenc\
    ent.easygraph.proto.GetSnapshotGraphResponse\x12}\n\x0clistSnapshot\x125\
    .com.tencent.easygraph.proto.ListSnapshotGraphRequest\x1a6.com.tencent.e\
    asygraph.proto.ListSnapshotGraphResponse\x12\x86\x01\n\x0frestoreSnapsho\
    t\x128.com.tencent.easygraph.proto.RestoreSnapshotGraphRequest\x1a9.com.\
    tencent.easygraph.proto.RestoreSnapshotGraphResponse\x12p\n\x0bhealthChe\
    ck\x12/.com.tencent.easygraph.proto.HealthCheckRequest\x1a0.com.tencent.\
    easygraph.proto.HealthCheckResponse\x12k\n\x08allocate\x12..com.tencent.\
    easygraph.proto.AllocateIDRequest\x1a/.com.tencent.easygraph.proto.Alloc\
    ateIDResponseB\x02P\x01J\xe0{\n\x07\x12\x05\0\0\xa5\x03\x01\n\x08\n\x01\
    \x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0$\n\x08\n\x01\x08\x12\
    \x03\x03\0\"\n\t\n\x02\x08\n\x12\x03\x03\0\"\n\"\n\x02\x04\0\x12\x04\x06\
    \0\x0b\x01\x1a\x16common\x20data\x20structure\n\n\n\n\x03\x04\0\x01\x12\
    \x03\x06\x08\x0e\n\x0b\n\x04\x04\0\x02\0\x12\x03\x07\x02\x13\n\r\n\x05\
    \x04\0\x02\0\x04\x12\x04\x07\x02\x06\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03\x07\x02\x06\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x07\x07\x0e\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03\x07\x11\x12\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x03\x08\x02\x11\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x08\x02\x07\x13\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x08\x02\x07\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x08\x08\x0c\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x08\
    \x0f\x10\n\x0b\n\x04\x04\0\x02\x02\x12\x03\t\x02\x11\n\r\n\x05\x04\0\x02\
    \x02\x04\x12\x04\t\x02\x08\x11\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\t\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\t\t\x0c\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03\t\x0f\x10\n\x0b\n\x04\x04\0\x02\x03\x12\x03\n\x02\
    \x15\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\n\x02\t\x11\n\x0c\n\x05\x04\0\
    \x02\x03\x05\x12\x03\n\x02\x07\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\n\
    \x08\x10\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\n\x13\x14\n\n\n\x02\x05\0\
    \x12\x04\r\0\x14\x01\n\n\n\x03\x05\0\x01\x12\x03\r\x05\r\n\x0b\n\x04\x05\
    \0\x02\0\x12\x03\x0e\x02\x0c\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x0e\x02\
    \x07\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x0e\n\x0b\n\x0b\n\x04\x05\0\x02\
    \x01\x12\x03\x0f\x02\r\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x0f\x02\x08\
    \n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x0f\x0b\x0c\n\x0b\n\x04\x05\0\x02\
    \x02\x12\x03\x10\x02\x0f\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x10\x02\n\
    \n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x10\r\x0e\n\x0b\n\x04\x05\0\x02\
    \x03\x12\x03\x11\x02\x0e\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x11\x02\t\
    \n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x11\x0c\r\n\x0b\n\x04\x05\0\x02\
    \x04\x12\x03\x12\x02\x0e\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x12\x02\t\
    \n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x12\x0c\r\n\x0b\n\x04\x05\0\x02\
    \x05\x12\x03\x13\x02\x0f\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x13\x02\n\
    \n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x13\r\x0e\n\n\n\x02\x05\x01\x12\
    \x04\x16\0\x1c\x01\n\n\n\x03\x05\x01\x01\x12\x03\x16\x05\r\n\x0b\n\x04\
    \x05\x01\x02\0\x12\x03\x17\x02\x0c\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\
    \x17\x02\x07\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x17\n\x0b\n\x0b\n\x04\
    \x05\x01\x02\x01\x12\x03\x18\x02\r\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\
    \x03\x18\x02\x08\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x18\x0b\x0c\n\
    \x0b\n\x04\x05\x01\x02\x02\x12\x03\x19\x02\x0b\n\x0c\n\x05\x05\x01\x02\
    \x02\x01\x12\x03\x19\x02\x06\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\x19\
    \t\n\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\x1a\x02\x0c\n\x0c\n\x05\x05\x01\
    \x02\x03\x01\x12\x03\x1a\x02\x07\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03\
    \x1a\n\x0b\n\x0b\n\x04\x05\x01\x02\x04\x12\x03\x1b\x02\x0f\n\x0c\n\x05\
    \x05\x01\x02\x04\x01\x12\x03\x1b\x02\n\n\x0c\n\x05\x05\x01\x02\x04\x02\
    \x12\x03\x1b\r\x0e\n\n\n\x02\x04\x01\x12\x04\x1e\0\"\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03\x1e\x08\x10\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x1f\x02\
    \x14\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x1f\x02\x1e\x11\n\x0c\n\x05\x04\
    \x01\x02\0\x06\x12\x03\x1f\x02\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\
    \x1f\x0b\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1f\x12\x13\n\x0b\n\
    \x04\x04\x01\x02\x01\x12\x03\x20\x02\x11\n\r\n\x05\x04\x01\x02\x01\x04\
    \x12\x04\x20\x02\x1f\x14\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x20\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x20\t\x0c\n\x0c\n\x05\x04\
    \x01\x02\x01\x03\x12\x03\x20\x0f\x10\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\
    !\x02\x11\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04!\x02\x20\x11\n\x0c\n\x05\
    \x04\x01\x02\x02\x05\x12\x03!\x02\x07\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03!\x08\x0c\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03!\x0f\x10\n\n\n\
    \x02\x04\x02\x12\x04$\0.\x01\n\n\n\x03\x04\x02\x01\x12\x03$\x08\x14\n\
    \x0b\n\x04\x04\x02\x02\0\x12\x03%\x02\x10\n\r\n\x05\x04\x02\x02\0\x04\
    \x12\x04%\x02$\x16\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03%\x02\x08\n\x0c\
    \n\x05\x04\x02\x02\0\x01\x12\x03%\t\x0b\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03%\x0e\x0f\n\x0b\n\x04\x04\x02\x02\x01\x12\x03&\x02\x1a\n\r\n\x05\
    \x04\x02\x02\x01\x04\x12\x04&\x02%\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03&\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03&\t\x15\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03&\x18\x19\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03'\x02\x18\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04'\x02&\x1a\n\x0c\
    \n\x05\x04\x02\x02\x02\x06\x12\x03'\x02\n\n\x0c\n\x05\x04\x02\x02\x02\
    \x01\x12\x03'\x0b\x13\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03'\x16\x17\n\
    \x0b\n\x04\x04\x02\x02\x03\x12\x03(\x02\x19\n\r\n\x05\x04\x02\x02\x03\
    \x04\x12\x04(\x02'\x18\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03(\x02\x07\
    \n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03(\x08\x14\n\x0c\n\x05\x04\x02\
    \x02\x03\x03\x12\x03(\x17\x18\n\x0b\n\x04\x04\x02\x02\x04\x12\x03)\x02\
    \x15\n\r\n\x05\x04\x02\x02\x04\x04\x12\x04)\x02(\x19\n\x0c\n\x05\x04\x02\
    \x02\x04\x05\x12\x03)\x02\x08\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03)\t\
    \x10\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03)\x13\x14\n\x0b\n\x04\x04\
    \x02\x02\x05\x12\x03*\x02\x13\n\r\n\x05\x04\x02\x02\x05\x04\x12\x04*\x02\
    )\x15\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03*\x02\x08\n\x0c\n\x05\x04\
    \x02\x02\x05\x01\x12\x03*\t\x0e\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03*\
    \x11\x12\n\x0b\n\x04\x04\x02\x02\x06\x12\x03+\x02\x1f\n\x0c\n\x05\x04\
    \x02\x02\x06\x04\x12\x03+\x02\n\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\x03+\
    \x0b\x11\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03+\x12\x1a\n\x0c\n\x05\
    \x04\x02\x02\x06\x03\x12\x03+\x1d\x1e\n\x0b\n\x04\x04\x02\x02\x07\x12\
    \x03,\x02\x1c\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03,\x02\n\n\x0c\n\x05\
    \x04\x02\x02\x07\x05\x12\x03,\x0b\x11\n\x0c\n\x05\x04\x02\x02\x07\x01\
    \x12\x03,\x12\x17\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03,\x1a\x1b\n\x0b\
    \n\x04\x04\x02\x02\x08\x12\x03-\x02!\n\r\n\x05\x04\x02\x02\x08\x04\x12\
    \x04-\x02,\x1c\n\x0c\n\x05\x04\x02\x02\x08\x06\x12\x03-\x02\x15\n\x0c\n\
    \x05\x04\x02\x02\x08\x01\x12\x03-\x16\x1c\n\x0c\n\x05\x04\x02\x02\x08\
    \x03\x12\x03-\x1f\x20\n\n\n\x02\x04\x03\x12\x040\0<\x01\n\n\n\x03\x04\
    \x03\x01\x12\x030\x08\x11\n\x0b\n\x04\x04\x03\x02\0\x12\x031\x02\x10\n\r\
    \n\x05\x04\x03\x02\0\x04\x12\x041\x020\x13\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x031\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x031\t\x0b\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x031\x0e\x0f\n\x0b\n\x04\x04\x03\x02\x01\x12\
    \x032\x02\x12\n\r\n\x05\x04\x03\x02\x01\x04\x12\x042\x021\x10\n\x0c\n\
    \x05\x04\x03\x02\x01\x05\x12\x032\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x032\t\r\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x032\x10\x11\n\x0b\
    \n\x04\x04\x03\x02\x02\x12\x033\x02\x18\n\r\n\x05\x04\x03\x02\x02\x04\
    \x12\x043\x022\x12\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x033\x02\x07\n\
    \x0c\n\x05\x04\x03\x02\x02\x01\x12\x033\x08\x13\n\x0c\n\x05\x04\x03\x02\
    \x02\x03\x12\x033\x16\x17\n\x0b\n\x04\x04\x03\x02\x03\x12\x034\x02\x14\n\
    \r\n\x05\x04\x03\x02\x03\x04\x12\x044\x023\x18\n\x0c\n\x05\x04\x03\x02\
    \x03\x05\x12\x034\x02\x07\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x034\x08\
    \x0f\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x034\x12\x13\n\x0b\n\x04\x04\
    \x03\x02\x04\x12\x035\x02\x1b\n\r\n\x05\x04\x03\x02\x04\x04\x12\x045\x02\
    4\x14\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x035\x02\x08\n\x0c\n\x05\x04\
    \x03\x02\x04\x01\x12\x035\t\x16\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x035\
    \x19\x1a\n\x0b\n\x04\x04\x03\x02\x05\x12\x036\x02\x15\n\r\n\x05\x04\x03\
    \x02\x05\x04\x12\x046\x025\x1b\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x036\
    \x02\x08\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x036\t\x10\n\x0c\n\x05\x04\
    \x03\x02\x05\x03\x12\x036\x13\x14\n\x0b\n\x04\x04\x03\x02\x06\x12\x037\
    \x02\x13\n\r\n\x05\x04\x03\x02\x06\x04\x12\x047\x026\x15\n\x0c\n\x05\x04\
    \x03\x02\x06\x05\x12\x037\x02\x08\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\
    \x037\t\x0e\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x037\x11\x12\n\x0b\n\x04\
    \x04\x03\x02\x07\x12\x038\x020\n\r\n\x05\x04\x03\x02\x07\x04\x12\x048\
    \x027\x13\n\x0c\n\x05\x04\x03\x02\x07\x06\x12\x038\x02\x1b\n\x0c\n\x05\
    \x04\x03\x02\x07\x01\x12\x038\x1c+\n\x0c\n\x05\x04\x03\x02\x07\x03\x12\
    \x038./\n\x0b\n\x04\x04\x03\x02\x08\x12\x039\x02,\n\r\n\x05\x04\x03\x02\
    \x08\x04\x12\x049\x0280\n\x0c\n\x05\x04\x03\x02\x08\x06\x12\x039\x02\x19\
    \n\x0c\n\x05\x04\x03\x02\x08\x01\x12\x039\x1a'\n\x0c\n\x05\x04\x03\x02\
    \x08\x03\x12\x039*+\n\x0b\n\x04\x04\x03\x02\t\x12\x03:\x02(\n\r\n\x05\
    \x04\x03\x02\t\x04\x12\x04:\x029,\n\x0c\n\x05\x04\x03\x02\t\x06\x12\x03:\
    \x02\x17\n\x0c\n\x05\x04\x03\x02\t\x01\x12\x03:\x18\"\n\x0c\n\x05\x04\
    \x03\x02\t\x03\x12\x03:%'\n\x0b\n\x04\x04\x03\x02\n\x12\x03;\x02\"\n\r\n\
    \x05\x04\x03\x02\n\x04\x12\x04;\x02:(\n\x0c\n\x05\x04\x03\x02\n\x06\x12\
    \x03;\x02\x15\n\x0c\n\x05\x04\x03\x02\n\x01\x12\x03;\x16\x1c\n\x0c\n\x05\
    \x04\x03\x02\n\x03\x12\x03;\x1f!\n\n\n\x02\x04\x04\x12\x04>\0I\x01\n\n\n\
    \x03\x04\x04\x01\x12\x03>\x08\x12\n\x0b\n\x04\x04\x04\x02\0\x12\x03?\x02\
    \x10\n\r\n\x05\x04\x04\x02\0\x04\x12\x04?\x02>\x14\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03?\t\x0b\
    \n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03?\x0e\x0f\n\x0b\n\x04\x04\x04\x02\
    \x01\x12\x03@\x02\x12\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04@\x02?\x10\n\
    \x0c\n\x05\x04\x04\x02\x01\x05\x12\x03@\x02\x08\n\x0c\n\x05\x04\x04\x02\
    \x01\x01\x12\x03@\t\r\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03@\x10\x11\n\
    \x0b\n\x04\x04\x04\x02\x02\x12\x03A\x02\x19\n\r\n\x05\x04\x04\x02\x02\
    \x04\x12\x04A\x02@\x12\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03A\x02\x08\
    \n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03A\t\x14\n\x0c\n\x05\x04\x04\x02\
    \x02\x03\x12\x03A\x17\x18\n\x0b\n\x04\x04\x04\x02\x03\x12\x03B\x02\x18\n\
    \r\n\x05\x04\x04\x02\x03\x04\x12\x04B\x02A\x19\n\x0c\n\x05\x04\x04\x02\
    \x03\x05\x12\x03B\x02\x07\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03B\x08\
    \x13\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03B\x16\x17\n\x0b\n\x04\x04\
    \x04\x02\x04\x12\x03C\x02\x15\n\r\n\x05\x04\x04\x02\x04\x04\x12\x04C\x02\
    B\x18\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\x03C\x02\x08\n\x0c\n\x05\x04\
    \x04\x02\x04\x01\x12\x03C\t\x10\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03C\
    \x13\x14\n\x0b\n\x04\x04\x04\x02\x05\x12\x03D\x02\x13\n\r\n\x05\x04\x04\
    \x02\x05\x04\x12\x04D\x02C\x15\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x03D\
    \x02\x08\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03D\t\x0e\n\x0c\n\x05\x04\
    \x04\x02\x05\x03\x12\x03D\x11\x12\n\x0b\n\x04\x04\x04\x02\x06\x12\x03E\
    \x02!\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03E\x02\n\n\x0c\n\x05\x04\x04\
    \x02\x06\x05\x12\x03E\x0b\x11\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\x03E\
    \x12\x1c\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03E\x1f\x20\n\x0b\n\x04\
    \x04\x04\x02\x07\x12\x03F\x02\x1c\n\x0c\n\x05\x04\x04\x02\x07\x04\x12\
    \x03F\x02\n\n\x0c\n\x05\x04\x04\x02\x07\x05\x12\x03F\x0b\x11\n\x0c\n\x05\
    \x04\x04\x02\x07\x01\x12\x03F\x12\x17\n\x0c\n\x05\x04\x04\x02\x07\x03\
    \x12\x03F\x1a\x1b\n\x0b\n\x04\x04\x04\x02\x08\x12\x03G\x02!\n\r\n\x05\
    \x04\x04\x02\x08\x04\x12\x04G\x02F\x1c\n\x0c\n\x05\x04\x04\x02\x08\x06\
    \x12\x03G\x02\x15\n\x0c\n\x05\x04\x04\x02\x08\x01\x12\x03G\x16\x1c\n\x0c\
    \n\x05\x04\x04\x02\x08\x03\x12\x03G\x1f\x20\n\x0b\n\x04\x04\x04\x02\t\
    \x12\x03H\x02&\n\r\n\x05\x04\x04\x02\t\x04\x12\x04H\x02G!\n\x0c\n\x05\
    \x04\x04\x02\t\x06\x12\x03H\x02\x18\n\x0c\n\x05\x04\x04\x02\t\x01\x12\
    \x03H\x19\x20\n\x0c\n\x05\x04\x04\x02\t\x03\x12\x03H#%\n\n\n\x02\x04\x05\
    \x12\x04K\0V\x01\n\n\n\x03\x04\x05\x01\x12\x03K\x08\x10\n\x0b\n\x04\x04\
    \x05\x02\0\x12\x03L\x02\x10\n\r\n\x05\x04\x05\x02\0\x04\x12\x04L\x02K\
    \x12\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03L\x02\x08\n\x0c\n\x05\x04\x05\
    \x02\0\x01\x12\x03L\t\x0b\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03L\x0e\x0f\
    \n\x0b\n\x04\x04\x05\x02\x01\x12\x03M\x02\x12\n\r\n\x05\x04\x05\x02\x01\
    \x04\x12\x04M\x02L\x10\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03M\x02\x08\
    \n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03M\t\r\n\x0c\n\x05\x04\x05\x02\
    \x01\x03\x12\x03M\x10\x11\n\x0b\n\x04\x04\x05\x02\x02\x12\x03N\x02\x1a\n\
    \r\n\x05\x04\x05\x02\x02\x04\x12\x04N\x02M\x12\n\x0c\n\x05\x04\x05\x02\
    \x02\x05\x12\x03N\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03N\t\x15\
    \n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03N\x18\x19\n\x0b\n\x04\x04\x05\
    \x02\x03\x12\x03O\x02\x1a\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04O\x02N\
    \x1a\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\
    \x05\x02\x03\x01\x12\x03O\t\x15\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03O\
    \x18\x19\n\x0b\n\x04\x04\x05\x02\x04\x12\x03P\x02\x18\n\r\n\x05\x04\x05\
    \x02\x04\x04\x12\x04P\x02O\x1a\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x03P\
    \x02\x07\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03P\x08\x13\n\x0c\n\x05\
    \x04\x05\x02\x04\x03\x12\x03P\x16\x17\n\x0b\n\x04\x04\x05\x02\x05\x12\
    \x03Q\x02\x15\n\r\n\x05\x04\x05\x02\x05\x04\x12\x04Q\x02P\x18\n\x0c\n\
    \x05\x04\x05\x02\x05\x05\x12\x03Q\x02\x08\n\x0c\n\x05\x04\x05\x02\x05\
    \x01\x12\x03Q\t\x10\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03Q\x13\x14\n\
    \x0b\n\x04\x04\x05\x02\x06\x12\x03R\x02\x13\n\r\n\x05\x04\x05\x02\x06\
    \x04\x12\x04R\x02Q\x15\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\x03R\x02\x08\
    \n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03R\t\x0e\n\x0c\n\x05\x04\x05\x02\
    \x06\x03\x12\x03R\x11\x12\n\x0b\n\x04\x04\x05\x02\x07\x12\x03S\x02!\n\
    \x0c\n\x05\x04\x05\x02\x07\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\x05\x02\
    \x07\x05\x12\x03S\x0b\x11\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03S\x12\
    \x1c\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03S\x1f\x20\n\x0b\n\x04\x04\
    \x05\x02\x08\x12\x03T\x02\"\n\r\n\x05\x04\x05\x02\x08\x04\x12\x04T\x02S!\
    \n\x0c\n\x05\x04\x05\x02\x08\x06\x12\x03T\x02\x15\n\x0c\n\x05\x04\x05\
    \x02\x08\x01\x12\x03T\x16\x1c\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\x03T\
    \x1f!\n\x0b\n\x04\x04\x05\x02\t\x12\x03U\x02&\n\r\n\x05\x04\x05\x02\t\
    \x04\x12\x04U\x02T\"\n\x0c\n\x05\x04\x05\x02\t\x06\x12\x03U\x02\x18\n\
    \x0c\n\x05\x04\x05\x02\t\x01\x12\x03U\x19\x20\n\x0c\n\x05\x04\x05\x02\t\
    \x03\x12\x03U#%\n\n\n\x02\x04\x06\x12\x04X\0^\x01\n\n\n\x03\x04\x06\x01\
    \x12\x03X\x08\x11\n\x0b\n\x04\x04\x06\x02\0\x12\x03Y\x02\x10\n\r\n\x05\
    \x04\x06\x02\0\x04\x12\x04Y\x02X\x13\n\x0c\n\x05\x04\x06\x02\0\x05\x12\
    \x03Y\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03Y\t\x0b\n\x0c\n\x05\
    \x04\x06\x02\0\x03\x12\x03Y\x0e\x0f\n\x0b\n\x04\x04\x06\x02\x01\x12\x03Z\
    \x02\x12\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04Z\x02Y\x10\n\x0c\n\x05\x04\
    \x06\x02\x01\x05\x12\x03Z\x02\x08\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\
    \x03Z\t\r\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03Z\x10\x11\n\x0b\n\x04\
    \x04\x06\x02\x02\x12\x03[\x02!\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03[\
    \x02\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03[\x0b\x11\n\x0c\n\x05\x04\
    \x06\x02\x02\x01\x12\x03[\x12\x1c\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\
    \x03[\x1f\x20\n\x0b\n\x04\x04\x06\x02\x03\x12\x03\\\x02\x18\n\r\n\x05\
    \x04\x06\x02\x03\x04\x12\x04\\\x02[!\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\
    \x03\\\x02\x07\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03\\\x08\x13\n\x0c\n\
    \x05\x04\x06\x02\x03\x03\x12\x03\\\x16\x17\n\x0b\n\x04\x04\x06\x02\x04\
    \x12\x03]\x02!\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04]\x02\\\x18\n\x0c\n\
    \x05\x04\x06\x02\x04\x06\x12\x03]\x02\x15\n\x0c\n\x05\x04\x06\x02\x04\
    \x01\x12\x03]\x16\x1c\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03]\x1f\x20\n\
    \x16\n\x02\x04\x07\x12\x04a\0d\x01\x1a\nGraph\x20RPC\n\n\n\n\x03\x04\x07\
    \x01\x12\x03a\x08\x1a\n\x0b\n\x04\x04\x07\x02\0\x12\x03b\x02\x12\n\r\n\
    \x05\x04\x07\x02\0\x04\x12\x04b\x02a\x1c\n\x0c\n\x05\x04\x07\x02\0\x05\
    \x12\x03b\x02\x08\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03b\t\r\n\x0c\n\x05\
    \x04\x07\x02\0\x03\x12\x03b\x10\x11\n\x0b\n\x04\x04\x07\x02\x01\x12\x03c\
    \x02\x1b\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04c\x02b\x12\n\x0c\n\x05\x04\
    \x07\x02\x01\x05\x12\x03c\x02\x08\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\
    \x03c\t\x16\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03c\x19\x1a\n\n\n\x02\
    \x04\x08\x12\x04f\0i\x01\n\n\n\x03\x04\x08\x01\x12\x03f\x08\x1b\n\x0b\n\
    \x04\x04\x08\x02\0\x12\x03g\x02\x14\n\r\n\x05\x04\x08\x02\0\x04\x12\x04g\
    \x02f\x1d\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03g\x02\x08\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03g\t\x0f\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03g\x12\
    \x13\n\x0b\n\x04\x04\x08\x02\x01\x12\x03h\x02\x15\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x04h\x02g\x14\n\x0c\n\x05\x04\x08\x02\x01\x06\x12\x03h\x02\
    \x0b\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03h\x0c\x10\n\x0c\n\x05\x04\
    \x08\x02\x01\x03\x12\x03h\x13\x14\n\n\n\x02\x04\t\x12\x04k\0m\x01\n\n\n\
    \x03\x04\t\x01\x12\x03k\x08\x1c\n\x0b\n\x04\x04\t\x02\0\x12\x03l\x02\x12\
    \n\r\n\x05\x04\t\x02\0\x04\x12\x04l\x02k\x1e\n\x0c\n\x05\x04\t\x02\0\x05\
    \x12\x03l\x02\x08\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03l\t\r\n\x0c\n\x05\
    \x04\t\x02\0\x03\x12\x03l\x10\x11\n\n\n\x02\x04\n\x12\x04o\0q\x01\n\n\n\
    \x03\x04\n\x01\x12\x03o\x08\x1d\n\x0b\n\x04\x04\n\x02\0\x12\x03p\x02\x14\
    \n\r\n\x05\x04\n\x02\0\x04\x12\x04p\x02o\x1f\n\x0c\n\x05\x04\n\x02\0\x06\
    \x12\x03p\x02\x08\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03p\t\x0f\n\x0c\n\x05\
    \x04\n\x02\0\x03\x12\x03p\x12\x13\n\n\n\x02\x04\x0b\x12\x04s\0u\x01\n\n\
    \n\x03\x04\x0b\x01\x12\x03s\x08\x1b\n\x0b\n\x04\x04\x0b\x02\0\x12\x03t\
    \x02\x12\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04t\x02s\x1d\n\x0c\n\x05\x04\
    \x0b\x02\0\x05\x12\x03t\x02\x08\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03t\t\
    \r\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03t\x10\x11\n\n\n\x02\x04\x0c\x12\
    \x04w\0z\x01\n\n\n\x03\x04\x0c\x01\x12\x03w\x08\x1c\n\x0b\n\x04\x04\x0c\
    \x02\0\x12\x03x\x02\x14\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04x\x02w\x1e\n\
    \x0c\n\x05\x04\x0c\x02\0\x06\x12\x03x\x02\x08\n\x0c\n\x05\x04\x0c\x02\0\
    \x01\x12\x03x\t\x0f\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03x\x12\x13\n\x0b\
    \n\x04\x04\x0c\x02\x01\x12\x03y\x02\x15\n\r\n\x05\x04\x0c\x02\x01\x04\
    \x12\x04y\x02x\x14\n\x0c\n\x05\x04\x0c\x02\x01\x06\x12\x03y\x02\x0b\n\
    \x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03y\x0c\x10\n\x0c\n\x05\x04\x0c\x02\
    \x01\x03\x12\x03y\x13\x14\n\n\n\x02\x04\r\x12\x04|\0}\x01\n\n\n\x03\x04\
    \r\x01\x12\x03|\x08\x1e\n\x0b\n\x02\x04\x0e\x12\x05\x7f\0\x82\x01\x01\n\
    \n\n\x03\x04\x0e\x01\x12\x03\x7f\x08\x1f\n\x0c\n\x04\x04\x0e\x02\0\x12\
    \x04\x80\x01\x02\x14\n\x0e\n\x05\x04\x0e\x02\0\x04\x12\x05\x80\x01\x02\
    \x7f!\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\x80\x01\x02\x08\n\r\n\x05\x04\
    \x0e\x02\0\x01\x12\x04\x80\x01\t\x0f\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\
    \x80\x01\x12\x13\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x81\x01\x02\x1e\n\r\
    \n\x05\x04\x0e\x02\x01\x04\x12\x04\x81\x01\x02\n\n\r\n\x05\x04\x0e\x02\
    \x01\x06\x12\x04\x81\x01\x0b\x14\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \x81\x01\x15\x19\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x81\x01\x1c\x1d\n\
    \x1b\n\x02\x04\x0f\x12\x06\x85\x01\0\x8a\x01\x01\x1a\rProperty\x20RPC\n\
    \n\x0b\n\x03\x04\x0f\x01\x12\x04\x85\x01\x08\x1d\n\x0c\n\x04\x04\x0f\x02\
    \0\x12\x04\x86\x01\x02\x17\n\x0f\n\x05\x04\x0f\x02\0\x04\x12\x06\x86\x01\
    \x02\x85\x01\x1e\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x86\x01\x02\x08\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\x86\x01\t\x12\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\x86\x01\x15\x16\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\x87\x01\
    \x02\x1a\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\x06\x87\x01\x02\x86\x01\x17\
    \n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x87\x01\x02\x08\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\x87\x01\t\x15\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\
    \x87\x01\x18\x19\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\x88\x01\x02\x18\n\
    \x0f\n\x05\x04\x0f\x02\x02\x04\x12\x06\x88\x01\x02\x87\x01\x1a\n\r\n\x05\
    \x04\x0f\x02\x02\x06\x12\x04\x88\x01\x02\n\n\r\n\x05\x04\x0f\x02\x02\x01\
    \x12\x04\x88\x01\x0b\x13\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x88\x01\
    \x16\x17\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\x89\x01\x02\x19\n\x0f\n\x05\
    \x04\x0f\x02\x03\x04\x12\x06\x89\x01\x02\x88\x01\x18\n\r\n\x05\x04\x0f\
    \x02\x03\x05\x12\x04\x89\x01\x02\x07\n\r\n\x05\x04\x0f\x02\x03\x01\x12\
    \x04\x89\x01\x08\x14\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\x89\x01\x17\
    \x18\n\x0c\n\x02\x04\x10\x12\x06\x8c\x01\0\x8f\x01\x01\n\x0b\n\x03\x04\
    \x10\x01\x12\x04\x8c\x01\x08\x1e\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x8d\
    \x01\x02\x14\n\x0f\n\x05\x04\x10\x02\0\x04\x12\x06\x8d\x01\x02\x8c\x01\
    \x20\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\x8d\x01\x02\x08\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\x8d\x01\t\x0f\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \x8d\x01\x12\x13\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\x8e\x01\x02\x18\n\
    \x0f\n\x05\x04\x10\x02\x01\x04\x12\x06\x8e\x01\x02\x8d\x01\x14\n\r\n\x05\
    \x04\x10\x02\x01\x06\x12\x04\x8e\x01\x02\x0e\n\r\n\x05\x04\x10\x02\x01\
    \x01\x12\x04\x8e\x01\x0f\x13\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x8e\
    \x01\x16\x17\n\x0c\n\x02\x04\x11\x12\x06\x91\x01\0\x95\x01\x01\n\x0b\n\
    \x03\x04\x11\x01\x12\x04\x91\x01\x08\x1f\n\x0c\n\x04\x04\x11\x02\0\x12\
    \x04\x92\x01\x02\x17\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\x92\x01\x02\
    \x91\x01!\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\x92\x01\x02\x08\n\r\n\x05\
    \x04\x11\x02\0\x01\x12\x04\x92\x01\t\x12\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\x92\x01\x15\x16\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x93\x01\x02\x1a\
    \n\x0f\n\x05\x04\x11\x02\x01\x04\x12\x06\x93\x01\x02\x92\x01\x17\n\r\n\
    \x05\x04\x11\x02\x01\x05\x12\x04\x93\x01\x02\x08\n\r\n\x05\x04\x11\x02\
    \x01\x01\x12\x04\x93\x01\t\x15\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x93\
    \x01\x18\x19\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\x94\x01\x02\x15\n\x0f\n\
    \x05\x04\x11\x02\x02\x04\x12\x06\x94\x01\x02\x93\x01\x1a\n\r\n\x05\x04\
    \x11\x02\x02\x05\x12\x04\x94\x01\x02\x07\n\r\n\x05\x04\x11\x02\x02\x01\
    \x12\x04\x94\x01\x08\x10\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\x94\x01\
    \x13\x14\n\x0c\n\x02\x04\x12\x12\x06\x97\x01\0\x99\x01\x01\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\x97\x01\x08\x20\n\x0c\n\x04\x04\x12\x02\0\x12\x04\
    \x98\x01\x02\x14\n\x0f\n\x05\x04\x12\x02\0\x04\x12\x06\x98\x01\x02\x97\
    \x01\"\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\x98\x01\x02\x08\n\r\n\x05\x04\
    \x12\x02\0\x01\x12\x04\x98\x01\t\x0f\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \x98\x01\x12\x13\n\x0c\n\x02\x04\x13\x12\x06\x9b\x01\0\x9f\x01\x01\n\x0b\
    \n\x03\x04\x13\x01\x12\x04\x9b\x01\x08!\n\x0c\n\x04\x04\x13\x02\0\x12\
    \x04\x9c\x01\x02\x17\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\x9c\x01\x02\
    \x9b\x01#\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\x9c\x01\x02\x08\n\r\n\x05\
    \x04\x13\x02\0\x01\x12\x04\x9c\x01\t\x12\n\r\n\x05\x04\x13\x02\0\x03\x12\
    \x04\x9c\x01\x15\x16\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x9d\x01\x02\x1a\
    \n\x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\x9d\x01\x02\x9c\x01\x17\n\r\n\
    \x05\x04\x13\x02\x01\x05\x12\x04\x9d\x01\x02\x08\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\x9d\x01\t\x15\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x9d\
    \x01\x18\x19\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x9e\x01\x02\x19\n\x0f\n\
    \x05\x04\x13\x02\x02\x04\x12\x06\x9e\x01\x02\x9d\x01\x1a\n\r\n\x05\x04\
    \x13\x02\x02\x05\x12\x04\x9e\x01\x02\x07\n\r\n\x05\x04\x13\x02\x02\x01\
    \x12\x04\x9e\x01\x08\x14\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x9e\x01\
    \x17\x18\n\x0c\n\x02\x04\x14\x12\x06\xa1\x01\0\xa3\x01\x01\n\x0b\n\x03\
    \x04\x14\x01\x12\x04\xa1\x01\x08\"\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xa2\
    \x01\x02\x14\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\xa2\x01\x02\xa1\x01$\
    \n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xa2\x01\x02\x08\n\r\n\x05\x04\x14\
    \x02\0\x01\x12\x04\xa2\x01\t\x0f\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xa2\
    \x01\x12\x13\n\x19\n\x02\x04\x15\x12\x06\xa6\x01\0\xac\x01\x01\x1a\x0bVe\
    rtex\x20RPC\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xa6\x01\x08\x1b\n\x0c\n\
    \x04\x04\x15\x02\0\x12\x04\xa7\x01\x02\x17\n\x0f\n\x05\x04\x15\x02\0\x04\
    \x12\x06\xa7\x01\x02\xa6\x01\x1c\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xa7\
    \x01\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xa7\x01\t\x12\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\xa7\x01\x15\x16\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\xa8\x01\x02\x18\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\xa8\x01\
    \x02\xa7\x01\x17\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xa8\x01\x02\x08\n\
    \r\n\x05\x04\x15\x02\x01\x01\x12\x04\xa8\x01\t\x13\n\r\n\x05\x04\x15\x02\
    \x01\x03\x12\x04\xa8\x01\x16\x17\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xa9\
    \x01\x02\x19\n\x0f\n\x05\x04\x15\x02\x02\x04\x12\x06\xa9\x01\x02\xa8\x01\
    \x18\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\
    \x15\x02\x02\x01\x12\x04\xa9\x01\t\x14\n\r\n\x05\x04\x15\x02\x02\x03\x12\
    \x04\xa9\x01\x17\x18\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\xaa\x01\x02!\n\
    \r\n\x05\x04\x15\x02\x03\x04\x12\x04\xaa\x01\x02\n\n\r\n\x05\x04\x15\x02\
    \x03\x05\x12\x04\xaa\x01\x0b\x11\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\
    \xaa\x01\x12\x1c\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xaa\x01\x1f\x20\n\
    \x0c\n\x04\x04\x15\x02\x04\x12\x04\xab\x01\x02\x15\n\x0f\n\x05\x04\x15\
    \x02\x04\x04\x12\x06\xab\x01\x02\xaa\x01!\n\r\n\x05\x04\x15\x02\x04\x05\
    \x12\x04\xab\x01\x02\x07\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\xab\x01\
    \x08\x10\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xab\x01\x13\x14\n\x0c\n\
    \x02\x04\x16\x12\x06\xae\x01\0\xb1\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\xae\x01\x08\x1c\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xaf\x01\x02\x14\n\
    \x0f\n\x05\x04\x16\x02\0\x04\x12\x06\xaf\x01\x02\xae\x01\x1e\n\r\n\x05\
    \x04\x16\x02\0\x06\x12\x04\xaf\x01\x02\x08\n\r\n\x05\x04\x16\x02\0\x01\
    \x12\x04\xaf\x01\t\x0f\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xaf\x01\x12\
    \x13\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xb0\x01\x02\x16\n\x0f\n\x05\x04\
    \x16\x02\x01\x04\x12\x06\xb0\x01\x02\xaf\x01\x14\n\r\n\x05\x04\x16\x02\
    \x01\x06\x12\x04\xb0\x01\x02\x0c\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\
    \xb0\x01\r\x11\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xb0\x01\x14\x15\n\
    \x0c\n\x02\x04\x17\x12\x06\xb3\x01\0\xb7\x01\x01\n\x0b\n\x03\x04\x17\x01\
    \x12\x04\xb3\x01\x08\x1d\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xb4\x01\x02\
    \x17\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\xb4\x01\x02\xb3\x01\x1f\n\r\n\
    \x05\x04\x17\x02\0\x05\x12\x04\xb4\x01\x02\x08\n\r\n\x05\x04\x17\x02\0\
    \x01\x12\x04\xb4\x01\t\x12\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xb4\x01\
    \x15\x16\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xb5\x01\x02\x18\n\x0f\n\x05\
    \x04\x17\x02\x01\x04\x12\x06\xb5\x01\x02\xb4\x01\x17\n\r\n\x05\x04\x17\
    \x02\x01\x05\x12\x04\xb5\x01\x02\x08\n\r\n\x05\x04\x17\x02\x01\x01\x12\
    \x04\xb5\x01\t\x13\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xb5\x01\x16\x17\
    \n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xb6\x01\x02\x15\n\x0f\n\x05\x04\x17\
    \x02\x02\x04\x12\x06\xb6\x01\x02\xb5\x01\x18\n\r\n\x05\x04\x17\x02\x02\
    \x05\x12\x04\xb6\x01\x02\x07\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xb6\
    \x01\x08\x10\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xb6\x01\x13\x14\n\x0c\
    \n\x02\x04\x18\x12\x06\xb9\x01\0\xbb\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xb9\x01\x08\x1e\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xba\x01\x02\x14\n\
    \x0f\n\x05\x04\x18\x02\0\x04\x12\x06\xba\x01\x02\xb9\x01\x20\n\r\n\x05\
    \x04\x18\x02\0\x06\x12\x04\xba\x01\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\
    \x12\x04\xba\x01\t\x0f\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xba\x01\x12\
    \x13\n\x0c\n\x02\x04\x19\x12\x06\xbd\x01\0\xc2\x01\x01\n\x0b\n\x03\x04\
    \x19\x01\x12\x04\xbd\x01\x08\x1f\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xbe\
    \x01\x02\x17\n\x0f\n\x05\x04\x19\x02\0\x04\x12\x06\xbe\x01\x02\xbd\x01!\
    \n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xbe\x01\x02\x08\n\r\n\x05\x04\x19\
    \x02\0\x01\x12\x04\xbe\x01\t\x12\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xbe\
    \x01\x15\x16\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xbf\x01\x02\x18\n\x0f\n\
    \x05\x04\x19\x02\x01\x04\x12\x06\xbf\x01\x02\xbe\x01\x17\n\r\n\x05\x04\
    \x19\x02\x01\x05\x12\x04\xbf\x01\x02\x08\n\r\n\x05\x04\x19\x02\x01\x01\
    \x12\x04\xbf\x01\t\x13\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xbf\x01\x16\
    \x17\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xc0\x01\x02!\n\r\n\x05\x04\x19\
    \x02\x02\x04\x12\x04\xc0\x01\x02\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\
    \xc0\x01\x0b\x11\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xc0\x01\x12\x1c\n\
    \r\n\x05\x04\x19\x02\x02\x03\x12\x04\xc0\x01\x1f\x20\n\x0c\n\x04\x04\x19\
    \x02\x03\x12\x04\xc1\x01\x02\x15\n\x0f\n\x05\x04\x19\x02\x03\x04\x12\x06\
    \xc1\x01\x02\xc0\x01!\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xc1\x01\x02\
    \x07\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xc1\x01\x08\x10\n\r\n\x05\x04\
    \x19\x02\x03\x03\x12\x04\xc1\x01\x13\x14\n\x0c\n\x02\x04\x1a\x12\x06\xc4\
    \x01\0\xc6\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xc4\x01\x08\x20\n\x0c\
    \n\x04\x04\x1a\x02\0\x12\x04\xc5\x01\x02\x14\n\x0f\n\x05\x04\x1a\x02\0\
    \x04\x12\x06\xc5\x01\x02\xc4\x01\"\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\
    \xc5\x01\x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xc5\x01\t\x0f\n\r\n\
    \x05\x04\x1a\x02\0\x03\x12\x04\xc5\x01\x12\x13\n\x17\n\x02\x04\x1b\x12\
    \x06\xc9\x01\0\xd0\x01\x01\x1a\tEdge\x20RPC\n\n\x0b\n\x03\x04\x1b\x01\
    \x12\x04\xc9\x01\x08\x19\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xca\x01\x02\
    \x17\n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\xca\x01\x02\xc9\x01\x1a\n\r\n\
    \x05\x04\x1b\x02\0\x05\x12\x04\xca\x01\x02\x08\n\r\n\x05\x04\x1b\x02\0\
    \x01\x12\x04\xca\x01\t\x12\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xca\x01\
    \x15\x16\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xcb\x01\x02\x16\n\x0f\n\x05\
    \x04\x1b\x02\x01\x04\x12\x06\xcb\x01\x02\xca\x01\x17\n\r\n\x05\x04\x1b\
    \x02\x01\x05\x12\x04\xcb\x01\x02\x08\n\r\n\x05\x04\x1b\x02\x01\x01\x12\
    \x04\xcb\x01\t\x11\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xcb\x01\x14\x15\
    \n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xcc\x01\x02\x15\n\x0f\n\x05\x04\x1b\
    \x02\x02\x04\x12\x06\xcc\x01\x02\xcb\x01\x16\n\r\n\x05\x04\x1b\x02\x02\
    \x05\x12\x04\xcc\x01\x02\x08\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xcc\
    \x01\t\x10\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xcc\x01\x13\x14\n\x0c\n\
    \x04\x04\x1b\x02\x03\x12\x04\xcd\x01\x02\x14\n\x0f\n\x05\x04\x1b\x02\x03\
    \x04\x12\x06\xcd\x01\x02\xcc\x01\x15\n\r\n\x05\x04\x1b\x02\x03\x05\x12\
    \x04\xcd\x01\x02\x08\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\xcd\x01\t\x0f\
    \n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xcd\x01\x12\x13\n\x0c\n\x04\x04\
    \x1b\x02\x04\x12\x04\xce\x01\x02!\n\r\n\x05\x04\x1b\x02\x04\x04\x12\x04\
    \xce\x01\x02\n\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\xce\x01\x0b\x11\n\r\
    \n\x05\x04\x1b\x02\x04\x01\x12\x04\xce\x01\x12\x1c\n\r\n\x05\x04\x1b\x02\
    \x04\x03\x12\x04\xce\x01\x1f\x20\n\x0c\n\x04\x04\x1b\x02\x05\x12\x04\xcf\
    \x01\x02\x15\n\x0f\n\x05\x04\x1b\x02\x05\x04\x12\x06\xcf\x01\x02\xce\x01\
    !\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\xcf\x01\x02\x07\n\r\n\x05\x04\
    \x1b\x02\x05\x01\x12\x04\xcf\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x05\x03\
    \x12\x04\xcf\x01\x13\x14\n\x0c\n\x02\x04\x1c\x12\x06\xd2\x01\0\xd5\x01\
    \x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xd2\x01\x08\x1a\n\x0c\n\x04\x04\x1c\
    \x02\0\x12\x04\xd3\x01\x02\x14\n\x0f\n\x05\x04\x1c\x02\0\x04\x12\x06\xd3\
    \x01\x02\xd2\x01\x1c\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xd3\x01\x02\x08\
    \n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xd3\x01\t\x0f\n\r\n\x05\x04\x1c\x02\
    \0\x03\x12\x04\xd3\x01\x12\x13\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xd4\
    \x01\x02\x14\n\x0f\n\x05\x04\x1c\x02\x01\x04\x12\x06\xd4\x01\x02\xd3\x01\
    \x14\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\xd4\x01\x02\n\n\r\n\x05\x04\
    \x1c\x02\x01\x01\x12\x04\xd4\x01\x0b\x0f\n\r\n\x05\x04\x1c\x02\x01\x03\
    \x12\x04\xd4\x01\x12\x13\n\x0c\n\x02\x04\x1d\x12\x06\xd7\x01\0\xdb\x01\
    \x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xd7\x01\x08\x1b\n\x0c\n\x04\x04\x1d\
    \x02\0\x12\x04\xd8\x01\x02\x17\n\x0f\n\x05\x04\x1d\x02\0\x04\x12\x06\xd8\
    \x01\x02\xd7\x01\x1d\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xd8\x01\x02\x08\
    \n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xd8\x01\t\x12\n\r\n\x05\x04\x1d\x02\
    \0\x03\x12\x04\xd8\x01\x15\x16\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xd9\
    \x01\x02\x16\n\x0f\n\x05\x04\x1d\x02\x01\x04\x12\x06\xd9\x01\x02\xd8\x01\
    \x17\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xd9\x01\x02\x08\n\r\n\x05\x04\
    \x1d\x02\x01\x01\x12\x04\xd9\x01\t\x11\n\r\n\x05\x04\x1d\x02\x01\x03\x12\
    \x04\xd9\x01\x14\x15\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xda\x01\x02\x15\
    \n\x0f\n\x05\x04\x1d\x02\x02\x04\x12\x06\xda\x01\x02\xd9\x01\x16\n\r\n\
    \x05\x04\x1d\x02\x02\x05\x12\x04\xda\x01\x02\x07\n\r\n\x05\x04\x1d\x02\
    \x02\x01\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\
    \xda\x01\x13\x14\n\x0c\n\x02\x04\x1e\x12\x06\xdd\x01\0\xdf\x01\x01\n\x0b\
    \n\x03\x04\x1e\x01\x12\x04\xdd\x01\x08\x1c\n\x0c\n\x04\x04\x1e\x02\0\x12\
    \x04\xde\x01\x02\x14\n\x0f\n\x05\x04\x1e\x02\0\x04\x12\x06\xde\x01\x02\
    \xdd\x01\x1e\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xde\x01\x02\x08\n\r\n\
    \x05\x04\x1e\x02\0\x01\x12\x04\xde\x01\t\x0f\n\r\n\x05\x04\x1e\x02\0\x03\
    \x12\x04\xde\x01\x12\x13\n\x0c\n\x02\x04\x1f\x12\x06\xe1\x01\0\xe6\x01\
    \x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xe1\x01\x08\x1d\n\x0c\n\x04\x04\x1f\
    \x02\0\x12\x04\xe2\x01\x02\x17\n\x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\xe2\
    \x01\x02\xe1\x01\x1f\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xe2\x01\x02\x08\
    \n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xe2\x01\t\x12\n\r\n\x05\x04\x1f\x02\
    \0\x03\x12\x04\xe2\x01\x15\x16\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xe3\
    \x01\x02\x16\n\x0f\n\x05\x04\x1f\x02\x01\x04\x12\x06\xe3\x01\x02\xe2\x01\
    \x17\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xe3\x01\x02\x08\n\r\n\x05\x04\
    \x1f\x02\x01\x01\x12\x04\xe3\x01\t\x11\n\r\n\x05\x04\x1f\x02\x01\x03\x12\
    \x04\xe3\x01\x14\x15\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\xe4\x01\x02!\n\
    \r\n\x05\x04\x1f\x02\x02\x04\x12\x04\xe4\x01\x02\n\n\r\n\x05\x04\x1f\x02\
    \x02\x05\x12\x04\xe4\x01\x0b\x11\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\
    \xe4\x01\x12\x1c\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xe4\x01\x1f\x20\n\
    \x0c\n\x04\x04\x1f\x02\x03\x12\x04\xe5\x01\x02\x15\n\x0f\n\x05\x04\x1f\
    \x02\x03\x04\x12\x06\xe5\x01\x02\xe4\x01!\n\r\n\x05\x04\x1f\x02\x03\x05\
    \x12\x04\xe5\x01\x02\x07\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\xe5\x01\
    \x08\x10\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\xe5\x01\x13\x14\n\x0c\n\
    \x02\x04\x20\x12\x06\xe8\x01\0\xea\x01\x01\n\x0b\n\x03\x04\x20\x01\x12\
    \x04\xe8\x01\x08\x1e\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xe9\x01\x02\x14\n\
    \x0f\n\x05\x04\x20\x02\0\x04\x12\x06\xe9\x01\x02\xe8\x01\x20\n\r\n\x05\
    \x04\x20\x02\0\x06\x12\x04\xe9\x01\x02\x08\n\r\n\x05\x04\x20\x02\0\x01\
    \x12\x04\xe9\x01\t\x0f\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xe9\x01\x12\
    \x13\n\x0c\n\x02\x04!\x12\x06\xec\x01\0\xf2\x01\x01\n\x0b\n\x03\x04!\x01\
    \x12\x04\xec\x01\x08\x1b\n\x0c\n\x04\x04!\x02\0\x12\x04\xed\x01\x02\x17\
    \n\x0f\n\x05\x04!\x02\0\x04\x12\x06\xed\x01\x02\xec\x01\x1d\n\r\n\x05\
    \x04!\x02\0\x05\x12\x04\xed\x01\x02\x08\n\r\n\x05\x04!\x02\0\x01\x12\x04\
    \xed\x01\t\x12\n\r\n\x05\x04!\x02\0\x03\x12\x04\xed\x01\x15\x16\n\x0c\n\
    \x04\x04!\x02\x01\x12\x04\xee\x01\x02\x18\n\x0f\n\x05\x04!\x02\x01\x04\
    \x12\x06\xee\x01\x02\xed\x01\x17\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xee\
    \x01\x02\n\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xee\x01\x0b\x13\n\r\n\x05\
    \x04!\x02\x01\x03\x12\x04\xee\x01\x16\x17\n\x0c\n\x04\x04!\x02\x02\x12\
    \x04\xef\x01\x02\x12\n\x0f\n\x05\x04!\x02\x02\x04\x12\x06\xef\x01\x02\
    \xee\x01\x18\n\r\n\x05\x04!\x02\x02\x05\x12\x04\xef\x01\x02\x08\n\r\n\
    \x05\x04!\x02\x02\x01\x12\x04\xef\x01\t\r\n\r\n\x05\x04!\x02\x02\x03\x12\
    \x04\xef\x01\x10\x11\n\x0c\n\x04\x04!\x02\x03\x12\x04\xf0\x01\x02\x11\n\
    \x0f\n\x05\x04!\x02\x03\x04\x12\x06\xf0\x01\x02\xef\x01\x12\n\r\n\x05\
    \x04!\x02\x03\x05\x12\x04\xf0\x01\x02\x08\n\r\n\x05\x04!\x02\x03\x01\x12\
    \x04\xf0\x01\t\x0c\n\r\n\x05\x04!\x02\x03\x03\x12\x04\xf0\x01\x0f\x10\n\
    \x0c\n\x04\x04!\x02\x04\x12\x04\xf1\x01\x02\x13\n\x0f\n\x05\x04!\x02\x04\
    \x04\x12\x06\xf1\x01\x02\xf0\x01\x11\n\r\n\x05\x04!\x02\x04\x05\x12\x04\
    \xf1\x01\x02\x08\n\r\n\x05\x04!\x02\x04\x01\x12\x04\xf1\x01\t\x0e\n\r\n\
    \x05\x04!\x02\x04\x03\x12\x04\xf1\x01\x11\x12\n\x0c\n\x02\x04\"\x12\x06\
    \xf4\x01\0\xf6\x01\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xf4\x01\x08\x1c\n\
    \x0c\n\x04\x04\"\x02\0\x12\x04\xf5\x01\x02\x14\n\x0f\n\x05\x04\"\x02\0\
    \x04\x12\x06\xf5\x01\x02\xf4\x01\x1e\n\r\n\x05\x04\"\x02\0\x06\x12\x04\
    \xf5\x01\x02\x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xf5\x01\t\x0f\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\xf5\x01\x12\x13\n\x0c\n\x02\x04#\x12\x06\
    \xf8\x01\0\xfd\x01\x01\n\x0b\n\x03\x04#\x01\x12\x04\xf8\x01\x08\x1a\n\
    \x0c\n\x04\x04#\x02\0\x12\x04\xf9\x01\x02\x17\n\x0f\n\x05\x04#\x02\0\x04\
    \x12\x06\xf9\x01\x02\xf8\x01\x1c\n\r\n\x05\x04#\x02\0\x05\x12\x04\xf9\
    \x01\x02\x08\n\r\n\x05\x04#\x02\0\x01\x12\x04\xf9\x01\t\x12\n\r\n\x05\
    \x04#\x02\0\x03\x12\x04\xf9\x01\x15\x16\n\x0c\n\x04\x04#\x02\x01\x12\x04\
    \xfa\x01\x02\x18\n\x0f\n\x05\x04#\x02\x01\x04\x12\x06\xfa\x01\x02\xf9\
    \x01\x17\n\r\n\x05\x04#\x02\x01\x06\x12\x04\xfa\x01\x02\n\n\r\n\x05\x04#\
    \x02\x01\x01\x12\x04\xfa\x01\x0b\x13\n\r\n\x05\x04#\x02\x01\x03\x12\x04\
    \xfa\x01\x16\x17\n\x0c\n\x04\x04#\x02\x02\x12\x04\xfb\x01\x02\x12\n\x0f\
    \n\x05\x04#\x02\x02\x04\x12\x06\xfb\x01\x02\xfa\x01\x18\n\r\n\x05\x04#\
    \x02\x02\x05\x12\x04\xfb\x01\x02\x08\n\r\n\x05\x04#\x02\x02\x01\x12\x04\
    \xfb\x01\t\r\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xfb\x01\x10\x11\n\x0c\n\
    \x04\x04#\x02\x03\x12\x04\xfc\x01\x02\x13\n\x0f\n\x05\x04#\x02\x03\x04\
    \x12\x06\xfc\x01\x02\xfb\x01\x12\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xfc\
    \x01\x02\x08\n\r\n\x05\x04#\x02\x03\x01\x12\x04\xfc\x01\t\x0e\n\r\n\x05\
    \x04#\x02\x03\x03\x12\x04\xfc\x01\x11\x12\n\x0c\n\x02\x04$\x12\x06\xff\
    \x01\0\x81\x02\x01\n\x0b\n\x03\x04$\x01\x12\x04\xff\x01\x08\x1b\n\x0c\n\
    \x04\x04$\x02\0\x12\x04\x80\x02\x02\x14\n\x0f\n\x05\x04$\x02\0\x04\x12\
    \x06\x80\x02\x02\xff\x01\x1d\n\r\n\x05\x04$\x02\0\x06\x12\x04\x80\x02\
    \x02\x08\n\r\n\x05\x04$\x02\0\x01\x12\x04\x80\x02\t\x0f\n\r\n\x05\x04$\
    \x02\0\x03\x12\x04\x80\x02\x12\x13\n\x0c\n\x02\x04%\x12\x06\x83\x02\0\
    \x88\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\x83\x02\x08\x1c\n\x0c\n\x04\
    \x04%\x02\0\x12\x04\x84\x02\x02\x17\n\x0f\n\x05\x04%\x02\0\x04\x12\x06\
    \x84\x02\x02\x83\x02\x1e\n\r\n\x05\x04%\x02\0\x05\x12\x04\x84\x02\x02\
    \x08\n\r\n\x05\x04%\x02\0\x01\x12\x04\x84\x02\t\x12\n\r\n\x05\x04%\x02\0\
    \x03\x12\x04\x84\x02\x15\x16\n\x0c\n\x04\x04%\x02\x01\x12\x04\x85\x02\
    \x02\x18\n\x0f\n\x05\x04%\x02\x01\x04\x12\x06\x85\x02\x02\x84\x02\x17\n\
    \r\n\x05\x04%\x02\x01\x06\x12\x04\x85\x02\x02\n\n\r\n\x05\x04%\x02\x01\
    \x01\x12\x04\x85\x02\x0b\x13\n\r\n\x05\x04%\x02\x01\x03\x12\x04\x85\x02\
    \x16\x17\n\x0c\n\x04\x04%\x02\x02\x12\x04\x86\x02\x02\x12\n\x0f\n\x05\
    \x04%\x02\x02\x04\x12\x06\x86\x02\x02\x85\x02\x18\n\r\n\x05\x04%\x02\x02\
    \x05\x12\x04\x86\x02\x02\x08\n\r\n\x05\x04%\x02\x02\x01\x12\x04\x86\x02\
    \t\r\n\r\n\x05\x04%\x02\x02\x03\x12\x04\x86\x02\x10\x11\n\x0c\n\x04\x04%\
    \x02\x03\x12\x04\x87\x02\x02\x13\n\x0f\n\x05\x04%\x02\x03\x04\x12\x06\
    \x87\x02\x02\x86\x02\x12\n\r\n\x05\x04%\x02\x03\x05\x12\x04\x87\x02\x02\
    \x08\n\r\n\x05\x04%\x02\x03\x01\x12\x04\x87\x02\t\x0e\n\r\n\x05\x04%\x02\
    \x03\x03\x12\x04\x87\x02\x11\x12\n\x0c\n\x02\x04&\x12\x06\x8a\x02\0\x8c\
    \x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\x8a\x02\x08\x1d\n\x0c\n\x04\x04&\
    \x02\0\x12\x04\x8b\x02\x02\x14\n\x0f\n\x05\x04&\x02\0\x04\x12\x06\x8b\
    \x02\x02\x8a\x02\x1f\n\r\n\x05\x04&\x02\0\x06\x12\x04\x8b\x02\x02\x08\n\
    \r\n\x05\x04&\x02\0\x01\x12\x04\x8b\x02\t\x0f\n\r\n\x05\x04&\x02\0\x03\
    \x12\x04\x8b\x02\x12\x13\n\x0c\n\x02\x04'\x12\x06\x8e\x02\0\x94\x02\x01\
    \n\x0b\n\x03\x04'\x01\x12\x04\x8e\x02\x08\x1a\n\x0c\n\x04\x04'\x02\0\x12\
    \x04\x8f\x02\x02\x17\n\x0f\n\x05\x04'\x02\0\x04\x12\x06\x8f\x02\x02\x8e\
    \x02\x1c\n\r\n\x05\x04'\x02\0\x05\x12\x04\x8f\x02\x02\x08\n\r\n\x05\x04'\
    \x02\0\x01\x12\x04\x8f\x02\t\x12\n\r\n\x05\x04'\x02\0\x03\x12\x04\x8f\
    \x02\x15\x16\n\x0c\n\x04\x04'\x02\x01\x12\x04\x90\x02\x02\x13\n\x0f\n\
    \x05\x04'\x02\x01\x04\x12\x06\x90\x02\x02\x8f\x02\x17\n\r\n\x05\x04'\x02\
    \x01\x05\x12\x04\x90\x02\x02\x08\n\r\n\x05\x04'\x02\x01\x01\x12\x04\x90\
    \x02\t\x0e\n\r\n\x05\x04'\x02\x01\x03\x12\x04\x90\x02\x11\x12\n\x0c\n\
    \x04\x04'\x02\x02\x12\x04\x91\x02\x02\x18\n\x0f\n\x05\x04'\x02\x02\x04\
    \x12\x06\x91\x02\x02\x90\x02\x13\n\r\n\x05\x04'\x02\x02\x06\x12\x04\x91\
    \x02\x02\n\n\r\n\x05\x04'\x02\x02\x01\x12\x04\x91\x02\x0b\x13\n\r\n\x05\
    \x04'\x02\x02\x03\x12\x04\x91\x02\x16\x17\n\x0c\n\x04\x04'\x02\x03\x12\
    \x04\x92\x02\x02\x12\n\x0f\n\x05\x04'\x02\x03\x04\x12\x06\x92\x02\x02\
    \x91\x02\x18\n\r\n\x05\x04'\x02\x03\x05\x12\x04\x92\x02\x02\x08\n\r\n\
    \x05\x04'\x02\x03\x01\x12\x04\x92\x02\t\r\n\r\n\x05\x04'\x02\x03\x03\x12\
    \x04\x92\x02\x10\x11\n\x0c\n\x04\x04'\x02\x04\x12\x04\x93\x02\x02!\n\r\n\
    \x05\x04'\x02\x04\x04\x12\x04\x93\x02\x02\n\n\r\n\x05\x04'\x02\x04\x05\
    \x12\x04\x93\x02\x0b\x11\n\r\n\x05\x04'\x02\x04\x01\x12\x04\x93\x02\x12\
    \x1c\n\r\n\x05\x04'\x02\x04\x03\x12\x04\x93\x02\x1f\x20\n\x0c\n\x02\x04(\
    \x12\x06\x96\x02\0\x99\x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\x96\x02\x08\
    \x1b\n\x0c\n\x04\x04(\x02\0\x12\x04\x97\x02\x02\x14\n\x0f\n\x05\x04(\x02\
    \0\x04\x12\x06\x97\x02\x02\x96\x02\x1d\n\r\n\x05\x04(\x02\0\x06\x12\x04\
    \x97\x02\x02\x08\n\r\n\x05\x04(\x02\0\x01\x12\x04\x97\x02\t\x0f\n\r\n\
    \x05\x04(\x02\0\x03\x12\x04\x97\x02\x12\x13\n\x0c\n\x04\x04(\x02\x01\x12\
    \x04\x98\x02\x02\x16\n\x0f\n\x05\x04(\x02\x01\x04\x12\x06\x98\x02\x02\
    \x97\x02\x14\n\r\n\x05\x04(\x02\x01\x06\x12\x04\x98\x02\x02\x0b\n\r\n\
    \x05\x04(\x02\x01\x01\x12\x04\x98\x02\x0c\x11\n\r\n\x05\x04(\x02\x01\x03\
    \x12\x04\x98\x02\x14\x15\n\x0c\n\x02\x04)\x12\x06\x9b\x02\0\xa0\x02\x01\
    \n\x0b\n\x03\x04)\x01\x12\x04\x9b\x02\x08\x18\n\x0c\n\x04\x04)\x02\0\x12\
    \x04\x9c\x02\x02\x17\n\x0f\n\x05\x04)\x02\0\x04\x12\x06\x9c\x02\x02\x9b\
    \x02\x1a\n\r\n\x05\x04)\x02\0\x05\x12\x04\x9c\x02\x02\x08\n\r\n\x05\x04)\
    \x02\0\x01\x12\x04\x9c\x02\t\x12\n\r\n\x05\x04)\x02\0\x03\x12\x04\x9c\
    \x02\x15\x16\n\x0c\n\x04\x04)\x02\x01\x12\x04\x9d\x02\x02\x13\n\x0f\n\
    \x05\x04)\x02\x01\x04\x12\x06\x9d\x02\x02\x9c\x02\x17\n\r\n\x05\x04)\x02\
    \x01\x05\x12\x04\x9d\x02\x02\x08\n\r\n\x05\x04)\x02\x01\x01\x12\x04\x9d\
    \x02\t\x0e\n\r\n\x05\x04)\x02\x01\x03\x12\x04\x9d\x02\x11\x12\n\x0c\n\
    \x04\x04)\x02\x02\x12\x04\x9e\x02\x02\x18\n\x0f\n\x05\x04)\x02\x02\x04\
    \x12\x06\x9e\x02\x02\x9d\x02\x13\n\r\n\x05\x04)\x02\x02\x06\x12\x04\x9e\
    \x02\x02\n\n\r\n\x05\x04)\x02\x02\x01\x12\x04\x9e\x02\x0b\x13\n\r\n\x05\
    \x04)\x02\x02\x03\x12\x04\x9e\x02\x16\x17\n\x0c\n\x04\x04)\x02\x03\x12\
    \x04\x9f\x02\x02\x12\n\x0f\n\x05\x04)\x02\x03\x04\x12\x06\x9f\x02\x02\
    \x9e\x02\x18\n\r\n\x05\x04)\x02\x03\x05\x12\x04\x9f\x02\x02\x08\n\r\n\
    \x05\x04)\x02\x03\x01\x12\x04\x9f\x02\t\r\n\r\n\x05\x04)\x02\x03\x03\x12\
    \x04\x9f\x02\x10\x11\n\x0c\n\x02\x04*\x12\x06\xa2\x02\0\xa4\x02\x01\n\
    \x0b\n\x03\x04*\x01\x12\x04\xa2\x02\x08\x19\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\xa3\x02\x02\x14\n\x0f\n\x05\x04*\x02\0\x04\x12\x06\xa3\x02\x02\xa2\
    \x02\x1b\n\r\n\x05\x04*\x02\0\x06\x12\x04\xa3\x02\x02\x08\n\r\n\x05\x04*\
    \x02\0\x01\x12\x04\xa3\x02\t\x0f\n\r\n\x05\x04*\x02\0\x03\x12\x04\xa3\
    \x02\x12\x13\n\x1c\n\x02\x04+\x12\x06\xa7\x02\0\xaa\x02\x01\x1a\x0eSync\
    \x20Meta\x20RPC\n\n\x0b\n\x03\x04+\x01\x12\x04\xa7\x02\x08\x15\n\x0c\n\
    \x04\x04+\x02\0\x12\x04\xa8\x02\x02\x13\n\x0f\n\x05\x04+\x02\0\x04\x12\
    \x06\xa8\x02\x02\xa7\x02\x16\n\r\n\x05\x04+\x02\0\x05\x12\x04\xa8\x02\
    \x02\x08\n\r\n\x05\x04+\x02\0\x01\x12\x04\xa8\x02\t\x0e\n\r\n\x05\x04+\
    \x02\0\x03\x12\x04\xa8\x02\x11\x12\n\x0c\n\x04\x04+\x02\x01\x12\x04\xa9\
    \x02\x02\x14\n\x0f\n\x05\x04+\x02\x01\x04\x12\x06\xa9\x02\x02\xa8\x02\
    \x13\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xa9\x02\x02\x07\n\r\n\x05\x04+\
    \x02\x01\x01\x12\x04\xa9\x02\x08\x0f\n\r\n\x05\x04+\x02\x01\x03\x12\x04\
    \xa9\x02\x12\x13\n\x0c\n\x02\x04,\x12\x06\xac\x02\0\xae\x02\x01\n\x0b\n\
    \x03\x04,\x01\x12\x04\xac\x02\x08\x1a\n\x0c\n\x04\x04,\x02\0\x12\x04\xad\
    \x02\x02&\n\r\n\x05\x04,\x02\0\x04\x12\x04\xad\x02\x02\n\n\r\n\x05\x04,\
    \x02\0\x06\x12\x04\xad\x02\x0b\x18\n\r\n\x05\x04,\x02\0\x01\x12\x04\xad\
    \x02\x19!\n\r\n\x05\x04,\x02\0\x03\x12\x04\xad\x02$%\n\x0c\n\x02\x04-\
    \x12\x06\xb0\x02\0\xb3\x02\x01\n\x0b\n\x03\x04-\x01\x12\x04\xb0\x02\x08\
    \x1b\n\x0c\n\x04\x04-\x02\0\x12\x04\xb1\x02\x02\x14\n\x0f\n\x05\x04-\x02\
    \0\x04\x12\x06\xb1\x02\x02\xb0\x02\x1c\n\r\n\x05\x04-\x02\0\x06\x12\x04\
    \xb1\x02\x02\x08\n\r\n\x05\x04-\x02\0\x01\x12\x04\xb1\x02\t\x0f\n\r\n\
    \x05\x04-\x02\0\x03\x12\x04\xb1\x02\x12\x13\n\x0c\n\x04\x04-\x02\x01\x12\
    \x04\xb2\x02\x02&\n\r\n\x05\x04-\x02\x01\x04\x12\x04\xb2\x02\x02\n\n\r\n\
    \x05\x04-\x02\x01\x06\x12\x04\xb2\x02\x0b\x18\n\r\n\x05\x04-\x02\x01\x01\
    \x12\x04\xb2\x02\x19!\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xb2\x02$%\n\x0c\
    \n\x02\x04.\x12\x06\xb5\x02\0\xb8\x02\x01\n\x0b\n\x03\x04.\x01\x12\x04\
    \xb5\x02\x08\x1e\n\x0c\n\x04\x04.\x02\0\x12\x04\xb6\x02\x02\x1b\n\x0f\n\
    \x05\x04.\x02\0\x04\x12\x06\xb6\x02\x02\xb5\x02\x20\n\r\n\x05\x04.\x02\0\
    \x05\x12\x04\xb6\x02\x02\x08\n\r\n\x05\x04.\x02\0\x01\x12\x04\xb6\x02\t\
    \x16\n\r\n\x05\x04.\x02\0\x03\x12\x04\xb6\x02\x19\x1a\n\x0c\n\x04\x04.\
    \x02\x01\x12\x04\xb7\x02\x02\x18\n\x0f\n\x05\x04.\x02\x01\x04\x12\x06\
    \xb7\x02\x02\xb6\x02\x1b\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xb7\x02\x02\
    \x08\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xb7\x02\t\x13\n\r\n\x05\x04.\x02\
    \x01\x03\x12\x04\xb7\x02\x16\x17\n\x0c\n\x02\x04/\x12\x06\xba\x02\0\xbd\
    \x02\x01\n\x0b\n\x03\x04/\x01\x12\x04\xba\x02\x08\x1f\n\x0c\n\x04\x04/\
    \x02\0\x12\x04\xbb\x02\x02\x14\n\x0f\n\x05\x04/\x02\0\x04\x12\x06\xbb\
    \x02\x02\xba\x02!\n\r\n\x05\x04/\x02\0\x06\x12\x04\xbb\x02\x02\x08\n\r\n\
    \x05\x04/\x02\0\x01\x12\x04\xbb\x02\t\x0f\n\r\n\x05\x04/\x02\0\x03\x12\
    \x04\xbb\x02\x12\x13\n\x0c\n\x04\x04/\x02\x01\x12\x04\xbc\x02\x02\x15\n\
    \x0f\n\x05\x04/\x02\x01\x04\x12\x06\xbc\x02\x02\xbb\x02\x14\n\r\n\x05\
    \x04/\x02\x01\x06\x12\x04\xbc\x02\x02\x0b\n\r\n\x05\x04/\x02\x01\x01\x12\
    \x04\xbc\x02\x0c\x10\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xbc\x02\x13\x14\
    \n\x0c\n\x02\x040\x12\x06\xbf\x02\0\xc2\x02\x01\n\x0b\n\x03\x040\x01\x12\
    \x04\xbf\x02\x08\x1f\n\x0c\n\x04\x040\x02\0\x12\x04\xc0\x02\x02\x1b\n\
    \x0f\n\x05\x040\x02\0\x04\x12\x06\xc0\x02\x02\xbf\x02!\n\r\n\x05\x040\
    \x02\0\x05\x12\x04\xc0\x02\x02\x08\n\r\n\x05\x040\x02\0\x01\x12\x04\xc0\
    \x02\t\x16\n\r\n\x05\x040\x02\0\x03\x12\x04\xc0\x02\x19\x1a\n\x0c\n\x04\
    \x040\x02\x01\x12\x04\xc1\x02\x02\x18\n\x0f\n\x05\x040\x02\x01\x04\x12\
    \x06\xc1\x02\x02\xc0\x02\x1b\n\r\n\x05\x040\x02\x01\x05\x12\x04\xc1\x02\
    \x02\x08\n\r\n\x05\x040\x02\x01\x01\x12\x04\xc1\x02\t\x13\n\r\n\x05\x040\
    \x02\x01\x03\x12\x04\xc1\x02\x16\x17\n\x0c\n\x02\x041\x12\x06\xc4\x02\0\
    \xc7\x02\x01\n\x0b\n\x03\x041\x01\x12\x04\xc4\x02\x08\x20\n\x0c\n\x04\
    \x041\x02\0\x12\x04\xc5\x02\x02\x14\n\x0f\n\x05\x041\x02\0\x04\x12\x06\
    \xc5\x02\x02\xc4\x02\"\n\r\n\x05\x041\x02\0\x06\x12\x04\xc5\x02\x02\x08\
    \n\r\n\x05\x041\x02\0\x01\x12\x04\xc5\x02\t\x0f\n\r\n\x05\x041\x02\0\x03\
    \x12\x04\xc5\x02\x12\x13\n\x0c\n\x04\x041\x02\x01\x12\x04\xc6\x02\x02\
    \x15\n\x0f\n\x05\x041\x02\x01\x04\x12\x06\xc6\x02\x02\xc5\x02\x14\n\r\n\
    \x05\x041\x02\x01\x06\x12\x04\xc6\x02\x02\x0b\n\r\n\x05\x041\x02\x01\x01\
    \x12\x04\xc6\x02\x0c\x10\n\r\n\x05\x041\x02\x01\x03\x12\x04\xc6\x02\x13\
    \x14\n\x0c\n\x02\x042\x12\x06\xc9\x02\0\xcb\x02\x01\n\x0b\n\x03\x042\x01\
    \x12\x04\xc9\x02\x08\x20\n\x0c\n\x04\x042\x02\0\x12\x04\xca\x02\x02\x18\
    \n\x0f\n\x05\x042\x02\0\x04\x12\x06\xca\x02\x02\xc9\x02\"\n\r\n\x05\x042\
    \x02\0\x05\x12\x04\xca\x02\x02\x08\n\r\n\x05\x042\x02\0\x01\x12\x04\xca\
    \x02\t\x13\n\r\n\x05\x042\x02\0\x03\x12\x04\xca\x02\x16\x17\n\x0c\n\x02\
    \x043\x12\x06\xcd\x02\0\xd0\x02\x01\n\x0b\n\x03\x043\x01\x12\x04\xcd\x02\
    \x08!\n\x0c\n\x04\x043\x02\0\x12\x04\xce\x02\x02\x14\n\x0f\n\x05\x043\
    \x02\0\x04\x12\x06\xce\x02\x02\xcd\x02#\n\r\n\x05\x043\x02\0\x06\x12\x04\
    \xce\x02\x02\x08\n\r\n\x05\x043\x02\0\x01\x12\x04\xce\x02\t\x0f\n\r\n\
    \x05\x043\x02\0\x03\x12\x04\xce\x02\x12\x13\n\x0c\n\x04\x043\x02\x01\x12\
    \x04\xcf\x02\x02$\n\r\n\x05\x043\x02\x01\x04\x12\x04\xcf\x02\x02\n\n\r\n\
    \x05\x043\x02\x01\x05\x12\x04\xcf\x02\x0b\x11\n\r\n\x05\x043\x02\x01\x01\
    \x12\x04\xcf\x02\x12\x1f\n\r\n\x05\x043\x02\x01\x03\x12\x04\xcf\x02\"#\n\
    \x0c\n\x02\x044\x12\x06\xd2\x02\0\xd5\x02\x01\n\x0b\n\x03\x044\x01\x12\
    \x04\xd2\x02\x08#\n\x0c\n\x04\x044\x02\0\x12\x04\xd3\x02\x02\x1b\n\x0f\n\
    \x05\x044\x02\0\x04\x12\x06\xd3\x02\x02\xd2\x02%\n\r\n\x05\x044\x02\0\
    \x05\x12\x04\xd3\x02\x02\x08\n\r\n\x05\x044\x02\0\x01\x12\x04\xd3\x02\t\
    \x16\n\r\n\x05\x044\x02\0\x03\x12\x04\xd3\x02\x19\x1a\n\x0c\n\x04\x044\
    \x02\x01\x12\x04\xd4\x02\x02\x18\n\x0f\n\x05\x044\x02\x01\x04\x12\x06\
    \xd4\x02\x02\xd3\x02\x1b\n\r\n\x05\x044\x02\x01\x05\x12\x04\xd4\x02\x02\
    \x08\n\r\n\x05\x044\x02\x01\x01\x12\x04\xd4\x02\t\x13\n\r\n\x05\x044\x02\
    \x01\x03\x12\x04\xd4\x02\x16\x17\n\x0c\n\x02\x045\x12\x06\xd7\x02\0\xda\
    \x02\x01\n\x0b\n\x03\x045\x01\x12\x04\xd7\x02\x08$\n\x0c\n\x04\x045\x02\
    \0\x12\x04\xd8\x02\x02\x14\n\x0f\n\x05\x045\x02\0\x04\x12\x06\xd8\x02\
    \x02\xd7\x02&\n\r\n\x05\x045\x02\0\x06\x12\x04\xd8\x02\x02\x08\n\r\n\x05\
    \x045\x02\0\x01\x12\x04\xd8\x02\t\x0f\n\r\n\x05\x045\x02\0\x03\x12\x04\
    \xd8\x02\x12\x13\n\x0c\n\x04\x045\x02\x01\x12\x04\xd9\x02\x02\x15\n\x0f\
    \n\x05\x045\x02\x01\x04\x12\x06\xd9\x02\x02\xd8\x02\x14\n\r\n\x05\x045\
    \x02\x01\x06\x12\x04\xd9\x02\x02\x0b\n\r\n\x05\x045\x02\x01\x01\x12\x04\
    \xd9\x02\x0c\x10\n\r\n\x05\x045\x02\x01\x03\x12\x04\xd9\x02\x13\x14\n\
    \x0c\n\x02\x046\x12\x06\xdc\x02\0\xdd\x02\x01\n\x0b\n\x03\x046\x01\x12\
    \x04\xdc\x02\x08\x1a\n\x0c\n\x02\x047\x12\x06\xdf\x02\0\xe1\x02\x01\n\
    \x0b\n\x03\x047\x01\x12\x04\xdf\x02\x08\x1b\n\x0c\n\x04\x047\x02\0\x12\
    \x04\xe0\x02\x02\x14\n\x0f\n\x05\x047\x02\0\x04\x12\x06\xe0\x02\x02\xdf\
    \x02\x1d\n\r\n\x05\x047\x02\0\x06\x12\x04\xe0\x02\x02\x08\n\r\n\x05\x047\
    \x02\0\x01\x12\x04\xe0\x02\t\x0f\n\r\n\x05\x047\x02\0\x03\x12\x04\xe0\
    \x02\x12\x13\n\x0c\n\x02\x048\x12\x06\xe3\x02\0\xe6\x02\x01\n\x0b\n\x03\
    \x048\x01\x12\x04\xe3\x02\x08\x0f\n\x0c\n\x04\x048\x02\0\x12\x04\xe4\x02\
    \x02\x11\n\x0f\n\x05\x048\x02\0\x04\x12\x06\xe4\x02\x02\xe3\x02\x11\n\r\
    \n\x05\x048\x02\0\x05\x12\x04\xe4\x02\x02\x07\n\r\n\x05\x048\x02\0\x01\
    \x12\x04\xe4\x02\x08\x0c\n\r\n\x05\x048\x02\0\x03\x12\x04\xe4\x02\x0f\
    \x10\n\x0c\n\x04\x048\x02\x01\x12\x04\xe5\x02\x02\x12\n\x0f\n\x05\x048\
    \x02\x01\x04\x12\x06\xe5\x02\x02\xe4\x02\x11\n\r\n\x05\x048\x02\x01\x05\
    \x12\x04\xe5\x02\x02\x07\n\r\n\x05\x048\x02\x01\x01\x12\x04\xe5\x02\x08\
    \r\n\r\n\x05\x048\x02\x01\x03\x12\x04\xe5\x02\x10\x11\n\x0c\n\x02\x049\
    \x12\x06\xe8\x02\0\xeb\x02\x01\n\x0b\n\x03\x049\x01\x12\x04\xe8\x02\x08\
    \x19\n\x0c\n\x04\x049\x02\0\x12\x04\xe9\x02\x02\x17\n\x0f\n\x05\x049\x02\
    \0\x04\x12\x06\xe9\x02\x02\xe8\x02\x1b\n\r\n\x05\x049\x02\0\x05\x12\x04\
    \xe9\x02\x02\x08\n\r\n\x05\x049\x02\0\x01\x12\x04\xe9\x02\t\x12\n\r\n\
    \x05\x049\x02\0\x03\x12\x04\xe9\x02\x15\x16\n\x0c\n\x04\x049\x02\x01\x12\
    \x04\xea\x02\x02\x12\n\x0f\n\x05\x049\x02\x01\x04\x12\x06\xea\x02\x02\
    \xe9\x02\x17\n\r\n\x05\x049\x02\x01\x05\x12\x04\xea\x02\x02\x07\n\r\n\
    \x05\x049\x02\x01\x01\x12\x04\xea\x02\x08\r\n\r\n\x05\x049\x02\x01\x03\
    \x12\x04\xea\x02\x10\x11\n\x0c\n\x02\x04:\x12\x06\xed\x02\0\xf0\x02\x01\
    \n\x0b\n\x03\x04:\x01\x12\x04\xed\x02\x08\x1a\n\x0c\n\x04\x04:\x02\0\x12\
    \x04\xee\x02\x02\x14\n\x0f\n\x05\x04:\x02\0\x04\x12\x06\xee\x02\x02\xed\
    \x02\x1c\n\r\n\x05\x04:\x02\0\x06\x12\x04\xee\x02\x02\x08\n\r\n\x05\x04:\
    \x02\0\x01\x12\x04\xee\x02\t\x0f\n\r\n\x05\x04:\x02\0\x03\x12\x04\xee\
    \x02\x12\x13\n\x0c\n\x04\x04:\x02\x01\x12\x04\xef\x02\x02\x14\n\x0f\n\
    \x05\x04:\x02\x01\x04\x12\x06\xef\x02\x02\xee\x02\x14\n\r\n\x05\x04:\x02\
    \x01\x06\x12\x04\xef\x02\x02\t\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xef\
    \x02\n\x0f\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xef\x02\x12\x13\n\x0c\n\
    \x02\x06\0\x12\x06\xf2\x02\0\xa5\x03\x01\n\x0b\n\x03\x06\0\x01\x12\x04\
    \xf2\x02\x08\x16\n\x0c\n\x04\x06\0\x02\0\x12\x04\xf4\x02\x02H\n\r\n\x05\
    \x06\0\x02\0\x01\x12\x04\xf4\x02\x06\x15\n\r\n\x05\x06\0\x02\0\x02\x12\
    \x04\xf4\x02\x16(\n\r\n\x05\x06\0\x02\0\x03\x12\x04\xf4\x023F\n\x0c\n\
    \x04\x06\0\x02\x01\x12\x04\xf6\x02\x02J\n\r\n\x05\x06\0\x02\x01\x01\x12\
    \x04\xf6\x02\x06\x13\n\r\n\x05\x06\0\x02\x01\x02\x12\x04\xf6\x02\x14(\n\
    \r\n\x05\x06\0\x02\x01\x03\x12\x04\xf6\x023H\n\x0c\n\x04\x06\0\x02\x02\
    \x12\x04\xf8\x02\x02G\n\r\n\x05\x06\0\x02\x02\x01\x12\x04\xf8\x02\x06\
    \x12\n\r\n\x05\x06\0\x02\x02\x02\x12\x04\xf8\x02\x13&\n\r\n\x05\x06\0\
    \x02\x02\x03\x12\x04\xf8\x021E\n\x0c\n\x04\x06\0\x02\x03\x12\x04\xfa\x02\
    \x02P\n\r\n\x05\x06\0\x02\x03\x01\x12\x04\xfa\x02\x06\x15\n\r\n\x05\x06\
    \0\x02\x03\x02\x12\x04\xfa\x02\x16,\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\
    \xfa\x027N\n\x0c\n\x04\x06\0\x02\x04\x12\x04\xfc\x02\x02Q\n\r\n\x05\x06\
    \0\x02\x04\x01\x12\x04\xfc\x02\x06\x18\n\r\n\x05\x06\0\x02\x04\x02\x12\
    \x04\xfc\x02\x19.\n\r\n\x05\x06\0\x02\x04\x03\x12\x04\xfc\x029O\n\x0c\n\
    \x04\x06\0\x02\x05\x12\x04\xfe\x02\x02S\n\r\n\x05\x06\0\x02\x05\x01\x12\
    \x04\xfe\x02\x06\x16\n\r\n\x05\x06\0\x02\x05\x02\x12\x04\xfe\x02\x17.\n\
    \r\n\x05\x06\0\x02\x05\x03\x12\x04\xfe\x029Q\n\x0c\n\x04\x06\0\x02\x06\
    \x12\x04\x80\x03\x02Y\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\x80\x03\x06\
    \x18\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x80\x03\x192\n\r\n\x05\x06\0\
    \x02\x06\x03\x12\x04\x80\x03=W\n\x0c\n\x04\x06\0\x02\x07\x12\x04\x82\x03\
    \x02K\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\x82\x03\x06\x16\n\r\n\x05\x06\
    \0\x02\x07\x02\x12\x04\x82\x03\x17*\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\
    \x82\x035I\n\x0c\n\x04\x06\0\x02\x08\x12\x04\x84\x03\x02M\n\r\n\x05\x06\
    \0\x02\x08\x01\x12\x04\x84\x03\x06\x14\n\r\n\x05\x06\0\x02\x08\x02\x12\
    \x04\x84\x03\x15*\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\x84\x035K\n\x0c\n\
    \x04\x06\0\x02\t\x12\x04\x86\x03\x02S\n\r\n\x05\x06\0\x02\t\x01\x12\x04\
    \x86\x03\x06\x16\n\r\n\x05\x06\0\x02\t\x02\x12\x04\x86\x03\x17.\n\r\n\
    \x05\x06\0\x02\t\x03\x12\x04\x86\x039Q\n\x0c\n\x04\x06\0\x02\n\x12\x04\
    \x88\x03\x02E\n\r\n\x05\x06\0\x02\n\x01\x12\x04\x88\x03\x06\x14\n\r\n\
    \x05\x06\0\x02\n\x02\x12\x04\x88\x03\x15&\n\r\n\x05\x06\0\x02\n\x03\x12\
    \x04\x88\x031C\n\x0c\n\x04\x06\0\x02\x0b\x12\x04\x8a\x03\x02G\n\r\n\x05\
    \x06\0\x02\x0b\x01\x12\x04\x8a\x03\x06\x12\n\r\n\x05\x06\0\x02\x0b\x02\
    \x12\x04\x8a\x03\x13&\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\x8a\x031E\n\
    \x0c\n\x04\x06\0\x02\x0c\x12\x04\x8c\x03\x02M\n\r\n\x05\x06\0\x02\x0c\
    \x01\x12\x04\x8c\x03\x06\x14\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\x8c\x03\
    \x15*\n\r\n\x05\x06\0\x02\x0c\x03\x12\x04\x8c\x035K\n\x0c\n\x04\x06\0\
    \x02\r\x12\x04\x8e\x03\x02G\n\r\n\x05\x06\0\x02\r\x01\x12\x04\x8e\x03\
    \x06\x12\n\r\n\x05\x06\0\x02\r\x02\x12\x04\x8e\x03\x13&\n\r\n\x05\x06\0\
    \x02\r\x03\x12\x04\x8e\x031E\n\x0c\n\x04\x06\0\x02\x0e\x12\x04\x90\x03\
    \x02D\n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\x90\x03\x06\x11\n\r\n\x05\x06\
    \0\x02\x0e\x02\x12\x04\x90\x03\x12$\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\
    \x90\x03/B\n\x0c\n\x04\x06\0\x02\x0f\x12\x04\x92\x03\x02J\n\r\n\x05\x06\
    \0\x02\x0f\x01\x12\x04\x92\x03\x06\x13\n\r\n\x05\x06\0\x02\x0f\x02\x12\
    \x04\x92\x03\x14(\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\x92\x033H\n\x0c\n\
    \x04\x06\0\x02\x10\x12\x04\x94\x03\x02D\n\r\n\x05\x06\0\x02\x10\x01\x12\
    \x04\x94\x03\x06\x11\n\r\n\x05\x06\0\x02\x10\x02\x12\x04\x94\x03\x12$\n\
    \r\n\x05\x06\0\x02\x10\x03\x12\x04\x94\x03/B\n\x0c\n\x04\x06\0\x02\x11\
    \x12\x04\x96\x03\x02>\n\r\n\x05\x06\0\x02\x11\x01\x12\x04\x96\x03\x06\
    \x0f\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\x96\x03\x10\x20\n\r\n\x05\x06\0\
    \x02\x11\x03\x12\x04\x96\x03+<\n\x0c\n\x04\x06\0\x02\x12\x12\x04\x98\x03\
    \x02D\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\x98\x03\x06\x11\n\r\n\x05\x06\
    \0\x02\x12\x02\x12\x04\x98\x03\x12$\n\r\n\x05\x06\0\x02\x12\x03\x12\x04\
    \x98\x03/B\n\x0c\n\x04\x06\0\x02\x13\x12\x04\x9a\x03\x02K\n\r\n\x05\x06\
    \0\x02\x13\x01\x12\x04\x9a\x03\x06\x10\n\r\n\x05\x06\0\x02\x13\x02\x12\
    \x04\x9a\x03\x11'\n\r\n\x05\x06\0\x02\x13\x03\x12\x04\x9a\x032I\n\x0c\n\
    \x04\x06\0\x02\x14\x12\x04\x9c\x03\x02N\n\r\n\x05\x06\0\x02\x14\x01\x12\
    \x04\x9c\x03\x06\x11\n\r\n\x05\x06\0\x02\x14\x02\x12\x04\x9c\x03\x12)\n\
    \r\n\x05\x06\0\x02\x14\x03\x12\x04\x9c\x034L\n\x0c\n\x04\x06\0\x02\x15\
    \x12\x04\x9e\x03\x02Q\n\r\n\x05\x06\0\x02\x15\x01\x12\x04\x9e\x03\x06\
    \x12\n\r\n\x05\x06\0\x02\x15\x02\x12\x04\x9e\x03\x13+\n\r\n\x05\x06\0\
    \x02\x15\x03\x12\x04\x9e\x036O\n\x0c\n\x04\x06\0\x02\x16\x12\x04\xa0\x03\
    \x02Z\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\xa0\x03\x06\x15\n\r\n\x05\x06\
    \0\x02\x16\x02\x12\x04\xa0\x03\x161\n\r\n\x05\x06\0\x02\x16\x03\x12\x04\
    \xa0\x03<X\n\x0c\n\x04\x06\0\x02\x17\x12\x04\xa2\x03\x02D\n\r\n\x05\x06\
    \0\x02\x17\x01\x12\x04\xa2\x03\x06\x11\n\r\n\x05\x06\0\x02\x17\x02\x12\
    \x04\xa2\x03\x12$\n\r\n\x05\x06\0\x02\x17\x03\x12\x04\xa2\x03/B\n\x0c\n\
    \x04\x06\0\x02\x18\x12\x04\xa4\x03\x02?\n\r\n\x05\x06\0\x02\x18\x01\x12\
    \x04\xa4\x03\x06\x0e\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\xa4\x03\x0f\x20\
    \n\r\n\x05\x06\0\x02\x18\x03\x12\x04\xa4\x03+=b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(59);
            messages.push(Header::generated_message_descriptor_data());
            messages.push(MetaDesc::generated_message_descriptor_data());
            messages.push(PropertyMeta::generated_message_descriptor_data());
            messages.push(GraphMeta::generated_message_descriptor_data());
            messages.push(VertexMeta::generated_message_descriptor_data());
            messages.push(EdgeMeta::generated_message_descriptor_data());
            messages.push(IndexMeta::generated_message_descriptor_data());
            messages.push(CreateGraphRequest::generated_message_descriptor_data());
            messages.push(CreateGraphResponse::generated_message_descriptor_data());
            messages.push(DropGraphMetaRequest::generated_message_descriptor_data());
            messages.push(DropGraphMetaResponse::generated_message_descriptor_data());
            messages.push(GetGraphMetaRequest::generated_message_descriptor_data());
            messages.push(GetGraphMetaResponse::generated_message_descriptor_data());
            messages.push(GetAllGraphMetaRequest::generated_message_descriptor_data());
            messages.push(GetAllGraphMetaResponse::generated_message_descriptor_data());
            messages.push(CreatePropertyRequest::generated_message_descriptor_data());
            messages.push(CreatePropertyResponse::generated_message_descriptor_data());
            messages.push(DropPropertyMetaRequest::generated_message_descriptor_data());
            messages.push(DropPropertyMetaResponse::generated_message_descriptor_data());
            messages.push(UpdatePropertyMetaRequest::generated_message_descriptor_data());
            messages.push(UpdatePropertyMetaResponse::generated_message_descriptor_data());
            messages.push(CreateVertexRequest::generated_message_descriptor_data());
            messages.push(CreateVertexResponse::generated_message_descriptor_data());
            messages.push(DropVertexMetaRequest::generated_message_descriptor_data());
            messages.push(DropVertexMetaResponse::generated_message_descriptor_data());
            messages.push(UpdateVertexMetaRequest::generated_message_descriptor_data());
            messages.push(UpdateVertexMetaResponse::generated_message_descriptor_data());
            messages.push(CreateEdgeRequest::generated_message_descriptor_data());
            messages.push(CreateEdgeResponse::generated_message_descriptor_data());
            messages.push(DropEdgeMetaRequest::generated_message_descriptor_data());
            messages.push(DropEdgeMetaResponse::generated_message_descriptor_data());
            messages.push(UpdateEdgeMetaRequest::generated_message_descriptor_data());
            messages.push(UpdateEdgeMetaResponse::generated_message_descriptor_data());
            messages.push(UpdateConfigRequest::generated_message_descriptor_data());
            messages.push(UpdateConfigResponse::generated_message_descriptor_data());
            messages.push(UpdateAliasRequest::generated_message_descriptor_data());
            messages.push(UpdateAliasResponse::generated_message_descriptor_data());
            messages.push(UpdateCommentRequest::generated_message_descriptor_data());
            messages.push(UpdateCommentResponse::generated_message_descriptor_data());
            messages.push(CreateIndexRequest::generated_message_descriptor_data());
            messages.push(CreateIndexResponse::generated_message_descriptor_data());
            messages.push(DropIndexRequest::generated_message_descriptor_data());
            messages.push(DropIndexResponse::generated_message_descriptor_data());
            messages.push(VersionRecord::generated_message_descriptor_data());
            messages.push(DiffVersionRequest::generated_message_descriptor_data());
            messages.push(DiffVersionResponse::generated_message_descriptor_data());
            messages.push(DoSnapshotGraphRequest::generated_message_descriptor_data());
            messages.push(DoSnapshotGraphResponse::generated_message_descriptor_data());
            messages.push(GetSnapshotGraphRequest::generated_message_descriptor_data());
            messages.push(GetSnapshotGraphResponse::generated_message_descriptor_data());
            messages.push(ListSnapshotGraphRequest::generated_message_descriptor_data());
            messages.push(ListSnapshotGraphResponse::generated_message_descriptor_data());
            messages.push(RestoreSnapshotGraphRequest::generated_message_descriptor_data());
            messages.push(RestoreSnapshotGraphResponse::generated_message_descriptor_data());
            messages.push(HealthCheckRequest::generated_message_descriptor_data());
            messages.push(HealthCheckResponse::generated_message_descriptor_data());
            messages.push(IDRange::generated_message_descriptor_data());
            messages.push(AllocateIDRequest::generated_message_descriptor_data());
            messages.push(AllocateIDResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(DataType::generated_enum_descriptor_data());
            enums.push(MetaType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
