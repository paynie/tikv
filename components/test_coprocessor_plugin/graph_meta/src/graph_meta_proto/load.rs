// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `load.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.DataSource)
pub struct DataSource {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DataSource.source_type)
    pub source_type: ::protobuf::EnumOrUnknown<DataSourceType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.DataSource.extract)
    pub extract: bool,
    // message oneof groups
    pub oneof_source: ::std::option::Option<data_source::Oneof_source>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.DataSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataSource {
    fn default() -> &'a DataSource {
        <DataSource as ::protobuf::Message>::default_instance()
    }
}

impl DataSource {
    pub fn new() -> DataSource {
        ::std::default::Default::default()
    }

    // .com.tencent.easygraph.proto.TdwSource tdw_source = 4;

    pub fn tdw_source(&self) -> &TdwSource {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::TdwSource(ref v)) => v,
            _ => <TdwSource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tdw_source(&mut self) {
        self.oneof_source = ::std::option::Option::None;
    }

    pub fn has_tdw_source(&self) -> bool {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::TdwSource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tdw_source(&mut self, v: TdwSource) {
        self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::TdwSource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tdw_source(&mut self) -> &mut TdwSource {
        if let ::std::option::Option::Some(data_source::Oneof_source::TdwSource(_)) = self.oneof_source {
        } else {
            self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::TdwSource(TdwSource::new()));
        }
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::TdwSource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tdw_source(&mut self) -> TdwSource {
        if self.has_tdw_source() {
            match self.oneof_source.take() {
                ::std::option::Option::Some(data_source::Oneof_source::TdwSource(v)) => v,
                _ => panic!(),
            }
        } else {
            TdwSource::new()
        }
    }

    // .com.tencent.easygraph.proto.CsvSource csv_source = 5;

    pub fn csv_source(&self) -> &CsvSource {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::CsvSource(ref v)) => v,
            _ => <CsvSource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_csv_source(&mut self) {
        self.oneof_source = ::std::option::Option::None;
    }

    pub fn has_csv_source(&self) -> bool {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::CsvSource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_csv_source(&mut self, v: CsvSource) {
        self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::CsvSource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_csv_source(&mut self) -> &mut CsvSource {
        if let ::std::option::Option::Some(data_source::Oneof_source::CsvSource(_)) = self.oneof_source {
        } else {
            self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::CsvSource(CsvSource::new()));
        }
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::CsvSource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_csv_source(&mut self) -> CsvSource {
        if self.has_csv_source() {
            match self.oneof_source.take() {
                ::std::option::Option::Some(data_source::Oneof_source::CsvSource(v)) => v,
                _ => panic!(),
            }
        } else {
            CsvSource::new()
        }
    }

    // .com.tencent.easygraph.proto.HiveSource hive_source = 6;

    pub fn hive_source(&self) -> &HiveSource {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::HiveSource(ref v)) => v,
            _ => <HiveSource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hive_source(&mut self) {
        self.oneof_source = ::std::option::Option::None;
    }

    pub fn has_hive_source(&self) -> bool {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::HiveSource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hive_source(&mut self, v: HiveSource) {
        self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::HiveSource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hive_source(&mut self) -> &mut HiveSource {
        if let ::std::option::Option::Some(data_source::Oneof_source::HiveSource(_)) = self.oneof_source {
        } else {
            self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::HiveSource(HiveSource::new()));
        }
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::HiveSource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hive_source(&mut self) -> HiveSource {
        if self.has_hive_source() {
            match self.oneof_source.take() {
                ::std::option::Option::Some(data_source::Oneof_source::HiveSource(v)) => v,
                _ => panic!(),
            }
        } else {
            HiveSource::new()
        }
    }

    // .com.tencent.easygraph.proto.JdbcSource jdbc_source = 7;

    pub fn jdbc_source(&self) -> &JdbcSource {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::JdbcSource(ref v)) => v,
            _ => <JdbcSource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_jdbc_source(&mut self) {
        self.oneof_source = ::std::option::Option::None;
    }

    pub fn has_jdbc_source(&self) -> bool {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::JdbcSource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_jdbc_source(&mut self, v: JdbcSource) {
        self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::JdbcSource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_jdbc_source(&mut self) -> &mut JdbcSource {
        if let ::std::option::Option::Some(data_source::Oneof_source::JdbcSource(_)) = self.oneof_source {
        } else {
            self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::JdbcSource(JdbcSource::new()));
        }
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::JdbcSource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_jdbc_source(&mut self) -> JdbcSource {
        if self.has_jdbc_source() {
            match self.oneof_source.take() {
                ::std::option::Option::Some(data_source::Oneof_source::JdbcSource(v)) => v,
                _ => panic!(),
            }
        } else {
            JdbcSource::new()
        }
    }

    // .com.tencent.easygraph.proto.JsonSource json_source = 8;

    pub fn json_source(&self) -> &JsonSource {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::JsonSource(ref v)) => v,
            _ => <JsonSource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_json_source(&mut self) {
        self.oneof_source = ::std::option::Option::None;
    }

    pub fn has_json_source(&self) -> bool {
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::JsonSource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_json_source(&mut self, v: JsonSource) {
        self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::JsonSource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_json_source(&mut self) -> &mut JsonSource {
        if let ::std::option::Option::Some(data_source::Oneof_source::JsonSource(_)) = self.oneof_source {
        } else {
            self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::JsonSource(JsonSource::new()));
        }
        match self.oneof_source {
            ::std::option::Option::Some(data_source::Oneof_source::JsonSource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_json_source(&mut self) -> JsonSource {
        if self.has_json_source() {
            match self.oneof_source.take() {
                ::std::option::Option::Some(data_source::Oneof_source::JsonSource(v)) => v,
                _ => panic!(),
            }
        } else {
            JsonSource::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_type",
            |m: &DataSource| { &m.source_type },
            |m: &mut DataSource| { &mut m.source_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TdwSource>(
            "tdw_source",
            DataSource::has_tdw_source,
            DataSource::tdw_source,
            DataSource::mut_tdw_source,
            DataSource::set_tdw_source,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CsvSource>(
            "csv_source",
            DataSource::has_csv_source,
            DataSource::csv_source,
            DataSource::mut_csv_source,
            DataSource::set_csv_source,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HiveSource>(
            "hive_source",
            DataSource::has_hive_source,
            DataSource::hive_source,
            DataSource::mut_hive_source,
            DataSource::set_hive_source,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, JdbcSource>(
            "jdbc_source",
            DataSource::has_jdbc_source,
            DataSource::jdbc_source,
            DataSource::mut_jdbc_source,
            DataSource::set_jdbc_source,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, JsonSource>(
            "json_source",
            DataSource::has_json_source,
            DataSource::json_source,
            DataSource::mut_json_source,
            DataSource::set_json_source,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extract",
            |m: &DataSource| { &m.extract },
            |m: &mut DataSource| { &mut m.extract },
        ));
        oneofs.push(data_source::Oneof_source::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataSource>(
            "DataSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataSource {
    const NAME: &'static str = "DataSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_type = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::TdwSource(is.read_message()?));
                },
                42 => {
                    self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::CsvSource(is.read_message()?));
                },
                50 => {
                    self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::HiveSource(is.read_message()?));
                },
                58 => {
                    self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::JdbcSource(is.read_message()?));
                },
                66 => {
                    self.oneof_source = ::std::option::Option::Some(data_source::Oneof_source::JsonSource(is.read_message()?));
                },
                72 => {
                    self.extract = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.source_type != ::protobuf::EnumOrUnknown::new(DataSourceType::TDW) {
            my_size += ::protobuf::rt::int32_size(1, self.source_type.value());
        }
        if self.extract != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.oneof_source {
            match v {
                &data_source::Oneof_source::TdwSource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Oneof_source::CsvSource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Oneof_source::HiveSource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Oneof_source::JdbcSource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source::Oneof_source::JsonSource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.source_type != ::protobuf::EnumOrUnknown::new(DataSourceType::TDW) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.source_type))?;
        }
        if self.extract != false {
            os.write_bool(9, self.extract)?;
        }
        if let ::std::option::Option::Some(ref v) = self.oneof_source {
            match v {
                &data_source::Oneof_source::TdwSource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &data_source::Oneof_source::CsvSource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &data_source::Oneof_source::HiveSource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &data_source::Oneof_source::JdbcSource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &data_source::Oneof_source::JsonSource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataSource {
        DataSource::new()
    }

    fn clear(&mut self) {
        self.source_type = ::protobuf::EnumOrUnknown::new(DataSourceType::TDW);
        self.oneof_source = ::std::option::Option::None;
        self.oneof_source = ::std::option::Option::None;
        self.oneof_source = ::std::option::Option::None;
        self.oneof_source = ::std::option::Option::None;
        self.oneof_source = ::std::option::Option::None;
        self.extract = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataSource {
        static instance: DataSource = DataSource {
            source_type: ::protobuf::EnumOrUnknown::from_i32(0),
            extract: false,
            oneof_source: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DataSource`
pub mod data_source {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:com.tencent.easygraph.proto.DataSource.oneof_source)
    pub enum Oneof_source {
        // @@protoc_insertion_point(oneof_field:com.tencent.easygraph.proto.DataSource.tdw_source)
        TdwSource(super::TdwSource),
        // @@protoc_insertion_point(oneof_field:com.tencent.easygraph.proto.DataSource.csv_source)
        CsvSource(super::CsvSource),
        // @@protoc_insertion_point(oneof_field:com.tencent.easygraph.proto.DataSource.hive_source)
        HiveSource(super::HiveSource),
        // @@protoc_insertion_point(oneof_field:com.tencent.easygraph.proto.DataSource.jdbc_source)
        JdbcSource(super::JdbcSource),
        // @@protoc_insertion_point(oneof_field:com.tencent.easygraph.proto.DataSource.json_source)
        JsonSource(super::JsonSource),
    }

    impl ::protobuf::Oneof for Oneof_source {
    }

    impl ::protobuf::OneofFull for Oneof_source {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DataSource as ::protobuf::MessageFull>::descriptor().oneof_by_name("oneof_source").unwrap()).clone()
        }
    }

    impl Oneof_source {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Oneof_source>("oneof_source")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.JdbcSource)
pub struct JdbcSource {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.JdbcSource.mapping)
    pub mapping: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.JdbcSource.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.JdbcSource.user)
    pub user: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.JdbcSource.password)
    pub password: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.JdbcSource.driver)
    pub driver: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.JdbcSource.sql)
    pub sql: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.JdbcSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JdbcSource {
    fn default() -> &'a JdbcSource {
        <JdbcSource as ::protobuf::Message>::default_instance()
    }
}

impl JdbcSource {
    pub fn new() -> JdbcSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "mapping",
            |m: &JdbcSource| { &m.mapping },
            |m: &mut JdbcSource| { &mut m.mapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &JdbcSource| { &m.url },
            |m: &mut JdbcSource| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user",
            |m: &JdbcSource| { &m.user },
            |m: &mut JdbcSource| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &JdbcSource| { &m.password },
            |m: &mut JdbcSource| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "driver",
            |m: &JdbcSource| { &m.driver },
            |m: &mut JdbcSource| { &mut m.driver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sql",
            |m: &JdbcSource| { &m.sql },
            |m: &mut JdbcSource| { &mut m.sql },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JdbcSource>(
            "JdbcSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JdbcSource {
    const NAME: &'static str = "JdbcSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.mapping.insert(key, value);
                },
                18 => {
                    self.url = is.read_string()?;
                },
                26 => {
                    self.user = is.read_string()?;
                },
                34 => {
                    self.password = is.read_string()?;
                },
                42 => {
                    self.driver = is.read_string()?;
                },
                50 => {
                    self.sql = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.mapping {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.user);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.password);
        }
        if !self.driver.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.driver);
        }
        if !self.sql.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.sql);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.mapping {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if !self.user.is_empty() {
            os.write_string(3, &self.user)?;
        }
        if !self.password.is_empty() {
            os.write_string(4, &self.password)?;
        }
        if !self.driver.is_empty() {
            os.write_string(5, &self.driver)?;
        }
        if !self.sql.is_empty() {
            os.write_string(6, &self.sql)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JdbcSource {
        JdbcSource::new()
    }

    fn clear(&mut self) {
        self.mapping.clear();
        self.url.clear();
        self.user.clear();
        self.password.clear();
        self.driver.clear();
        self.sql.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JdbcSource {
        static instance: ::protobuf::rt::Lazy<JdbcSource> = ::protobuf::rt::Lazy::new();
        instance.get(JdbcSource::new)
    }
}

impl ::protobuf::MessageFull for JdbcSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JdbcSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JdbcSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JdbcSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.TdwSource)
pub struct TdwSource {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TdwSource.tdw_column)
    pub tdw_column: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TdwSource.meta_column)
    pub meta_column: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TdwSource.url)
    pub url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.TdwSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TdwSource {
    fn default() -> &'a TdwSource {
        <TdwSource as ::protobuf::Message>::default_instance()
    }
}

impl TdwSource {
    pub fn new() -> TdwSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tdw_column",
            |m: &TdwSource| { &m.tdw_column },
            |m: &mut TdwSource| { &mut m.tdw_column },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "meta_column",
            |m: &TdwSource| { &m.meta_column },
            |m: &mut TdwSource| { &mut m.meta_column },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &TdwSource| { &m.url },
            |m: &mut TdwSource| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TdwSource>(
            "TdwSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TdwSource {
    const NAME: &'static str = "TdwSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tdw_column.push(is.read_string()?);
                },
                18 => {
                    self.meta_column.push(is.read_string()?);
                },
                26 => {
                    self.url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tdw_column {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.meta_column {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tdw_column {
            os.write_string(1, &v)?;
        };
        for v in &self.meta_column {
            os.write_string(2, &v)?;
        };
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TdwSource {
        TdwSource::new()
    }

    fn clear(&mut self) {
        self.tdw_column.clear();
        self.meta_column.clear();
        self.url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TdwSource {
        static instance: TdwSource = TdwSource {
            tdw_column: ::std::vec::Vec::new(),
            meta_column: ::std::vec::Vec::new(),
            url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TdwSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TdwSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TdwSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TdwSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.HiveSource)
pub struct HiveSource {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.HiveSource.mapping)
    pub mapping: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.HiveSource.sql)
    pub sql: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.HiveSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HiveSource {
    fn default() -> &'a HiveSource {
        <HiveSource as ::protobuf::Message>::default_instance()
    }
}

impl HiveSource {
    pub fn new() -> HiveSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "mapping",
            |m: &HiveSource| { &m.mapping },
            |m: &mut HiveSource| { &mut m.mapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sql",
            |m: &HiveSource| { &m.sql },
            |m: &mut HiveSource| { &mut m.sql },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HiveSource>(
            "HiveSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HiveSource {
    const NAME: &'static str = "HiveSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.mapping.insert(key, value);
                },
                18 => {
                    self.sql = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.mapping {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.sql.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sql);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.mapping {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.sql.is_empty() {
            os.write_string(2, &self.sql)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HiveSource {
        HiveSource::new()
    }

    fn clear(&mut self) {
        self.mapping.clear();
        self.sql.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HiveSource {
        static instance: ::protobuf::rt::Lazy<HiveSource> = ::protobuf::rt::Lazy::new();
        instance.get(HiveSource::new)
    }
}

impl ::protobuf::MessageFull for HiveSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HiveSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HiveSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HiveSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.JsonSource)
pub struct JsonSource {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.JsonSource.mapping)
    pub mapping: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.JsonSource.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.JsonSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a JsonSource {
    fn default() -> &'a JsonSource {
        <JsonSource as ::protobuf::Message>::default_instance()
    }
}

impl JsonSource {
    pub fn new() -> JsonSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "mapping",
            |m: &JsonSource| { &m.mapping },
            |m: &mut JsonSource| { &mut m.mapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &JsonSource| { &m.path },
            |m: &mut JsonSource| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JsonSource>(
            "JsonSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for JsonSource {
    const NAME: &'static str = "JsonSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.mapping.insert(key, value);
                },
                18 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.mapping {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.mapping {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> JsonSource {
        JsonSource::new()
    }

    fn clear(&mut self) {
        self.mapping.clear();
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static JsonSource {
        static instance: ::protobuf::rt::Lazy<JsonSource> = ::protobuf::rt::Lazy::new();
        instance.get(JsonSource::new)
    }
}

impl ::protobuf::MessageFull for JsonSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("JsonSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for JsonSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JsonSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.CsvSource)
pub struct CsvSource {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CsvSource.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CsvSource.header)
    pub header: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.CsvSource.delimiter)
    pub delimiter: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.CsvSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CsvSource {
    fn default() -> &'a CsvSource {
        <CsvSource as ::protobuf::Message>::default_instance()
    }
}

impl CsvSource {
    pub fn new() -> CsvSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &CsvSource| { &m.path },
            |m: &mut CsvSource| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "header",
            |m: &CsvSource| { &m.header },
            |m: &mut CsvSource| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delimiter",
            |m: &CsvSource| { &m.delimiter },
            |m: &mut CsvSource| { &mut m.delimiter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CsvSource>(
            "CsvSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CsvSource {
    const NAME: &'static str = "CsvSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.header.push(is.read_string()?);
                },
                26 => {
                    self.delimiter = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        for value in &self.header {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.delimiter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.delimiter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        for v in &self.header {
            os.write_string(2, &v)?;
        };
        if !self.delimiter.is_empty() {
            os.write_string(3, &self.delimiter)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CsvSource {
        CsvSource::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.header.clear();
        self.delimiter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CsvSource {
        static instance: CsvSource = CsvSource {
            path: ::std::string::String::new(),
            header: ::std::vec::Vec::new(),
            delimiter: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CsvSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CsvSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CsvSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CsvSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.TaskConfig)
pub struct TaskConfig {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TaskConfig.type)
    pub type_: ::protobuf::EnumOrUnknown<ElementType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TaskConfig.graph)
    pub graph: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TaskConfig.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TaskConfig.data_source)
    pub data_source: ::protobuf::MessageField<DataSource>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TaskConfig.splits)
    pub splits: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TaskConfig.hdfs_tmp_path)
    pub hdfs_tmp_path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.TaskConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskConfig {
    fn default() -> &'a TaskConfig {
        <TaskConfig as ::protobuf::Message>::default_instance()
    }
}

impl TaskConfig {
    pub fn new() -> TaskConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TaskConfig| { &m.type_ },
            |m: &mut TaskConfig| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "graph",
            |m: &TaskConfig| { &m.graph },
            |m: &mut TaskConfig| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &TaskConfig| { &m.label },
            |m: &mut TaskConfig| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DataSource>(
            "data_source",
            |m: &TaskConfig| { &m.data_source },
            |m: &mut TaskConfig| { &mut m.data_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "splits",
            |m: &TaskConfig| { &m.splits },
            |m: &mut TaskConfig| { &mut m.splits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hdfs_tmp_path",
            |m: &TaskConfig| { &m.hdfs_tmp_path },
            |m: &mut TaskConfig| { &mut m.hdfs_tmp_path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskConfig>(
            "TaskConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskConfig {
    const NAME: &'static str = "TaskConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.graph = is.read_string()?;
                },
                26 => {
                    self.label = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data_source)?;
                },
                40 => {
                    self.splits = is.read_int32()?;
                },
                50 => {
                    self.hdfs_tmp_path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(ElementType::VERTEX) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.graph.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.graph);
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.label);
        }
        if let Some(v) = self.data_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.splits != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.splits);
        }
        if !self.hdfs_tmp_path.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.hdfs_tmp_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(ElementType::VERTEX) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.graph.is_empty() {
            os.write_string(2, &self.graph)?;
        }
        if !self.label.is_empty() {
            os.write_string(3, &self.label)?;
        }
        if let Some(v) = self.data_source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.splits != 0 {
            os.write_int32(5, self.splits)?;
        }
        if !self.hdfs_tmp_path.is_empty() {
            os.write_string(6, &self.hdfs_tmp_path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskConfig {
        TaskConfig::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(ElementType::VERTEX);
        self.graph.clear();
        self.label.clear();
        self.data_source.clear();
        self.splits = 0;
        self.hdfs_tmp_path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskConfig {
        static instance: TaskConfig = TaskConfig {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            graph: ::std::string::String::new(),
            label: ::std::string::String::new(),
            data_source: ::protobuf::MessageField::none(),
            splits: 0,
            hdfs_tmp_path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.TiKVConfig)
pub struct TiKVConfig {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TiKVConfig.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.TiKVConfig.split_wait_time)
    pub split_wait_time: i32,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.TiKVConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TiKVConfig {
    fn default() -> &'a TiKVConfig {
        <TiKVConfig as ::protobuf::Message>::default_instance()
    }
}

impl TiKVConfig {
    pub fn new() -> TiKVConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &TiKVConfig| { &m.address },
            |m: &mut TiKVConfig| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "split_wait_time",
            |m: &TiKVConfig| { &m.split_wait_time },
            |m: &mut TiKVConfig| { &mut m.split_wait_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TiKVConfig>(
            "TiKVConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TiKVConfig {
    const NAME: &'static str = "TiKVConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                16 => {
                    self.split_wait_time = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.split_wait_time != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.split_wait_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.split_wait_time != 0 {
            os.write_int32(2, self.split_wait_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TiKVConfig {
        TiKVConfig::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.split_wait_time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TiKVConfig {
        static instance: TiKVConfig = TiKVConfig {
            address: ::std::string::String::new(),
            split_wait_time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TiKVConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TiKVConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TiKVConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TiKVConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.LoaderConfig)
pub struct LoaderConfig {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoaderConfig.task_type)
    pub task_type: ::protobuf::EnumOrUnknown<TaskType>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoaderConfig.tasks)
    pub tasks: ::std::vec::Vec<TaskConfig>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoaderConfig.tikv)
    pub tikv: ::protobuf::MessageField<TiKVConfig>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoaderConfig.easygraph)
    pub easygraph: ::protobuf::MessageField<super::graph_rpc::EasyGraphConfig>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoaderConfig.batchSize)
    pub batchSize: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoaderConfig.parallelism)
    pub parallelism: i32,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoaderConfig.spark_mode)
    pub spark_mode: ::protobuf::EnumOrUnknown<SparkMode>,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.LoaderConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoaderConfig {
    fn default() -> &'a LoaderConfig {
        <LoaderConfig as ::protobuf::Message>::default_instance()
    }
}

impl LoaderConfig {
    pub fn new() -> LoaderConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_type",
            |m: &LoaderConfig| { &m.task_type },
            |m: &mut LoaderConfig| { &mut m.task_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &LoaderConfig| { &m.tasks },
            |m: &mut LoaderConfig| { &mut m.tasks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TiKVConfig>(
            "tikv",
            |m: &LoaderConfig| { &m.tikv },
            |m: &mut LoaderConfig| { &mut m.tikv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::graph_rpc::EasyGraphConfig>(
            "easygraph",
            |m: &LoaderConfig| { &m.easygraph },
            |m: &mut LoaderConfig| { &mut m.easygraph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "batchSize",
            |m: &LoaderConfig| { &m.batchSize },
            |m: &mut LoaderConfig| { &mut m.batchSize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parallelism",
            |m: &LoaderConfig| { &m.parallelism },
            |m: &mut LoaderConfig| { &mut m.parallelism },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spark_mode",
            |m: &LoaderConfig| { &m.spark_mode },
            |m: &mut LoaderConfig| { &mut m.spark_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoaderConfig>(
            "LoaderConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoaderConfig {
    const NAME: &'static str = "LoaderConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.task_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tikv)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.easygraph)?;
                },
                48 => {
                    self.batchSize = is.read_int32()?;
                },
                56 => {
                    self.parallelism = is.read_int32()?;
                },
                64 => {
                    self.spark_mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.task_type != ::protobuf::EnumOrUnknown::new(TaskType::LOCAL_ONLINE) {
            my_size += ::protobuf::rt::int32_size(1, self.task_type.value());
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tikv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.easygraph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.batchSize != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.batchSize);
        }
        if self.parallelism != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.parallelism);
        }
        if self.spark_mode != ::protobuf::EnumOrUnknown::new(SparkMode::YARN) {
            my_size += ::protobuf::rt::int32_size(8, self.spark_mode.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.task_type != ::protobuf::EnumOrUnknown::new(TaskType::LOCAL_ONLINE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.task_type))?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.tikv.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.easygraph.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.batchSize != 0 {
            os.write_int32(6, self.batchSize)?;
        }
        if self.parallelism != 0 {
            os.write_int32(7, self.parallelism)?;
        }
        if self.spark_mode != ::protobuf::EnumOrUnknown::new(SparkMode::YARN) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.spark_mode))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoaderConfig {
        LoaderConfig::new()
    }

    fn clear(&mut self) {
        self.task_type = ::protobuf::EnumOrUnknown::new(TaskType::LOCAL_ONLINE);
        self.tasks.clear();
        self.tikv.clear();
        self.easygraph.clear();
        self.batchSize = 0;
        self.parallelism = 0;
        self.spark_mode = ::protobuf::EnumOrUnknown::new(SparkMode::YARN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoaderConfig {
        static instance: LoaderConfig = LoaderConfig {
            task_type: ::protobuf::EnumOrUnknown::from_i32(0),
            tasks: ::std::vec::Vec::new(),
            tikv: ::protobuf::MessageField::none(),
            easygraph: ::protobuf::MessageField::none(),
            batchSize: 0,
            parallelism: 0,
            spark_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoaderConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoaderConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoaderConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoaderConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:com.tencent.easygraph.proto.LoadResponse)
pub struct LoadResponse {
    // message fields
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoadResponse.status)
    pub status: ::protobuf::EnumOrUnknown<load_response::Status>,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoadResponse.job_id)
    pub job_id: ::std::string::String,
    // @@protoc_insertion_point(field:com.tencent.easygraph.proto.LoadResponse.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:com.tencent.easygraph.proto.LoadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadResponse {
    fn default() -> &'a LoadResponse {
        <LoadResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoadResponse {
    pub fn new() -> LoadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &LoadResponse| { &m.status },
            |m: &mut LoadResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "job_id",
            |m: &LoadResponse| { &m.job_id },
            |m: &mut LoadResponse| { &mut m.job_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &LoadResponse| { &m.message },
            |m: &mut LoadResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadResponse>(
            "LoadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadResponse {
    const NAME: &'static str = "LoadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.job_id = is.read_string()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status != ::protobuf::EnumOrUnknown::new(load_response::Status::OK) {
            my_size += ::protobuf::rt::int32_size(1, self.status.value());
        }
        if !self.job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.job_id);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status != ::protobuf::EnumOrUnknown::new(load_response::Status::OK) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.job_id.is_empty() {
            os.write_string(2, &self.job_id)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadResponse {
        LoadResponse::new()
    }

    fn clear(&mut self) {
        self.status = ::protobuf::EnumOrUnknown::new(load_response::Status::OK);
        self.job_id.clear();
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadResponse {
        static instance: LoadResponse = LoadResponse {
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            job_id: ::std::string::String::new(),
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoadResponse`
pub mod load_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:com.tencent.easygraph.proto.LoadResponse.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.LoadResponse.Status.OK)
        OK = 0,
        // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.LoadResponse.Status.FAIL)
        FAIL = 1,
        // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.LoadResponse.Status.RUNNING)
        RUNNING = 2,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::OK),
                1 => ::std::option::Option::Some(Status::FAIL),
                2 => ::std::option::Option::Some(Status::RUNNING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::OK,
            Status::FAIL,
            Status::RUNNING,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("LoadResponse.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::OK
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("LoadResponse.Status")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:com.tencent.easygraph.proto.DataSourceType)
pub enum DataSourceType {
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataSourceType.TDW)
    TDW = 0,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataSourceType.CSV)
    CSV = 1,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataSourceType.HIVE)
    HIVE = 2,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataSourceType.JDBC)
    JDBC = 3,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.DataSourceType.JSON)
    JSON = 4,
}

impl ::protobuf::Enum for DataSourceType {
    const NAME: &'static str = "DataSourceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataSourceType> {
        match value {
            0 => ::std::option::Option::Some(DataSourceType::TDW),
            1 => ::std::option::Option::Some(DataSourceType::CSV),
            2 => ::std::option::Option::Some(DataSourceType::HIVE),
            3 => ::std::option::Option::Some(DataSourceType::JDBC),
            4 => ::std::option::Option::Some(DataSourceType::JSON),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DataSourceType] = &[
        DataSourceType::TDW,
        DataSourceType::CSV,
        DataSourceType::HIVE,
        DataSourceType::JDBC,
        DataSourceType::JSON,
    ];
}

impl ::protobuf::EnumFull for DataSourceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DataSourceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DataSourceType {
    fn default() -> Self {
        DataSourceType::TDW
    }
}

impl DataSourceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataSourceType>("DataSourceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:com.tencent.easygraph.proto.ElementType)
pub enum ElementType {
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.ElementType.VERTEX)
    VERTEX = 0,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.ElementType.EDGE)
    EDGE = 1,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.ElementType.EMBEDDED_EDGE)
    EMBEDDED_EDGE = 3,
}

impl ::protobuf::Enum for ElementType {
    const NAME: &'static str = "ElementType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ElementType> {
        match value {
            0 => ::std::option::Option::Some(ElementType::VERTEX),
            1 => ::std::option::Option::Some(ElementType::EDGE),
            3 => ::std::option::Option::Some(ElementType::EMBEDDED_EDGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ElementType] = &[
        ElementType::VERTEX,
        ElementType::EDGE,
        ElementType::EMBEDDED_EDGE,
    ];
}

impl ::protobuf::EnumFull for ElementType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ElementType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ElementType::VERTEX => 0,
            ElementType::EDGE => 1,
            ElementType::EMBEDDED_EDGE => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ElementType {
    fn default() -> Self {
        ElementType::VERTEX
    }
}

impl ElementType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ElementType>("ElementType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:com.tencent.easygraph.proto.TaskType)
pub enum TaskType {
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.TaskType.LOCAL_ONLINE)
    LOCAL_ONLINE = 0,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.TaskType.SPARK_ONLINE)
    SPARK_ONLINE = 1,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.TaskType.SPARK_OFFLINE)
    SPARK_OFFLINE = 2,
}

impl ::protobuf::Enum for TaskType {
    const NAME: &'static str = "TaskType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskType> {
        match value {
            0 => ::std::option::Option::Some(TaskType::LOCAL_ONLINE),
            1 => ::std::option::Option::Some(TaskType::SPARK_ONLINE),
            2 => ::std::option::Option::Some(TaskType::SPARK_OFFLINE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TaskType] = &[
        TaskType::LOCAL_ONLINE,
        TaskType::SPARK_ONLINE,
        TaskType::SPARK_OFFLINE,
    ];
}

impl ::protobuf::EnumFull for TaskType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TaskType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TaskType {
    fn default() -> Self {
        TaskType::LOCAL_ONLINE
    }
}

impl TaskType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TaskType>("TaskType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:com.tencent.easygraph.proto.SparkMode)
pub enum SparkMode {
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.SparkMode.YARN)
    YARN = 0,
    // @@protoc_insertion_point(enum_value:com.tencent.easygraph.proto.SparkMode.LOCAL)
    LOCAL = 1,
}

impl ::protobuf::Enum for SparkMode {
    const NAME: &'static str = "SparkMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SparkMode> {
        match value {
            0 => ::std::option::Option::Some(SparkMode::YARN),
            1 => ::std::option::Option::Some(SparkMode::LOCAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SparkMode] = &[
        SparkMode::YARN,
        SparkMode::LOCAL,
    ];
}

impl ::protobuf::EnumFull for SparkMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SparkMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SparkMode {
    fn default() -> Self {
        SparkMode::YARN
    }
}

impl SparkMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SparkMode>("SparkMode")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nload.proto\x12\x1bcom.tencent.easygraph.proto\x1a\x19google/protobuf\
    /any.proto\x1a\x0fgraph_rpc.proto\"\xfa\x03\n\nDataSource\x12L\n\x0bsour\
    ce_type\x18\x01\x20\x01(\x0e2+.com.tencent.easygraph.proto.DataSourceTyp\
    eR\nsourceType\x12G\n\ntdw_source\x18\x04\x20\x01(\x0b2&.com.tencent.eas\
    ygraph.proto.TdwSourceH\0R\ttdwSource\x12G\n\ncsv_source\x18\x05\x20\x01\
    (\x0b2&.com.tencent.easygraph.proto.CsvSourceH\0R\tcsvSource\x12J\n\x0bh\
    ive_source\x18\x06\x20\x01(\x0b2'.com.tencent.easygraph.proto.HiveSource\
    H\0R\nhiveSource\x12J\n\x0bjdbc_source\x18\x07\x20\x01(\x0b2'.com.tencen\
    t.easygraph.proto.JdbcSourceH\0R\njdbcSource\x12J\n\x0bjson_source\x18\
    \x08\x20\x01(\x0b2'.com.tencent.easygraph.proto.JsonSourceH\0R\njsonSour\
    ce\x12\x18\n\x07extract\x18\t\x20\x01(\x08R\x07extractB\x0e\n\x0coneof_s\
    ource\"\x84\x02\n\nJdbcSource\x12N\n\x07mapping\x18\x01\x20\x03(\x0b24.c\
    om.tencent.easygraph.proto.JdbcSource.MappingEntryR\x07mapping\x12\x10\n\
    \x03url\x18\x02\x20\x01(\tR\x03url\x12\x12\n\x04user\x18\x03\x20\x01(\tR\
    \x04user\x12\x1a\n\x08password\x18\x04\x20\x01(\tR\x08password\x12\x16\n\
    \x06driver\x18\x05\x20\x01(\tR\x06driver\x12\x10\n\x03sql\x18\x06\x20\
    \x01(\tR\x03sql\x1a:\n\x0cMappingEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"]\
    \n\tTdwSource\x12\x1d\n\ntdw_column\x18\x01\x20\x03(\tR\ttdwColumn\x12\
    \x1f\n\x0bmeta_column\x18\x02\x20\x03(\tR\nmetaColumn\x12\x10\n\x03url\
    \x18\x03\x20\x01(\tR\x03url\"\xaa\x01\n\nHiveSource\x12N\n\x07mapping\
    \x18\x01\x20\x03(\x0b24.com.tencent.easygraph.proto.HiveSource.MappingEn\
    tryR\x07mapping\x12\x10\n\x03sql\x18\x02\x20\x01(\tR\x03sql\x1a:\n\x0cMa\
    ppingEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xac\x01\n\nJsonSource\x12N\n\
    \x07mapping\x18\x01\x20\x03(\x0b24.com.tencent.easygraph.proto.JsonSourc\
    e.MappingEntryR\x07mapping\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\
    \x1a:\n\x0cMappingEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"U\n\tCsvSource\
    \x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x16\n\x06header\x18\
    \x02\x20\x03(\tR\x06header\x12\x1c\n\tdelimiter\x18\x03\x20\x01(\tR\tdel\
    imiter\"\xfc\x01\n\nTaskConfig\x12<\n\x04type\x18\x01\x20\x01(\x0e2(.com\
    .tencent.easygraph.proto.ElementTypeR\x04type\x12\x14\n\x05graph\x18\x02\
    \x20\x01(\tR\x05graph\x12\x14\n\x05label\x18\x03\x20\x01(\tR\x05label\
    \x12H\n\x0bdata_source\x18\x04\x20\x01(\x0b2'.com.tencent.easygraph.prot\
    o.DataSourceR\ndataSource\x12\x16\n\x06splits\x18\x05\x20\x01(\x05R\x06s\
    plits\x12\"\n\rhdfs_tmp_path\x18\x06\x20\x01(\tR\x0bhdfsTmpPath\"N\n\nTi\
    KVConfig\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12&\n\x0fs\
    plit_wait_time\x18\x02\x20\x01(\x05R\rsplitWaitTime\"\xaa\x03\n\x0cLoade\
    rConfig\x12B\n\ttask_type\x18\x01\x20\x01(\x0e2%.com.tencent.easygraph.p\
    roto.TaskTypeR\x08taskType\x12=\n\x05tasks\x18\x02\x20\x03(\x0b2'.com.te\
    ncent.easygraph.proto.TaskConfigR\x05tasks\x12;\n\x04tikv\x18\x04\x20\
    \x01(\x0b2'.com.tencent.easygraph.proto.TiKVConfigR\x04tikv\x12S\n\teasy\
    graph\x18\x05\x20\x01(\x0b25.com.tencent.easygraph.graphrpc.proto.EasyGr\
    aphConfigR\teasygraph\x12\x1c\n\tbatchSize\x18\x06\x20\x01(\x05R\tbatchS\
    ize\x12\x20\n\x0bparallelism\x18\x07\x20\x01(\x05R\x0bparallelism\x12E\n\
    \nspark_mode\x18\x08\x20\x01(\x0e2&.com.tencent.easygraph.proto.SparkMod\
    eR\tsparkMode\"\xb2\x01\n\x0cLoadResponse\x12H\n\x06status\x18\x01\x20\
    \x01(\x0e20.com.tencent.easygraph.proto.LoadResponse.StatusR\x06status\
    \x12\x15\n\x06job_id\x18\x02\x20\x01(\tR\x05jobId\x12\x18\n\x07message\
    \x18\x03\x20\x01(\tR\x07message\"'\n\x06Status\x12\x06\n\x02OK\x10\0\x12\
    \x08\n\x04FAIL\x10\x01\x12\x0b\n\x07RUNNING\x10\x02*@\n\x0eDataSourceTyp\
    e\x12\x07\n\x03TDW\x10\0\x12\x07\n\x03CSV\x10\x01\x12\x08\n\x04HIVE\x10\
    \x02\x12\x08\n\x04JDBC\x10\x03\x12\x08\n\x04JSON\x10\x04*6\n\x0bElementT\
    ype\x12\n\n\x06VERTEX\x10\0\x12\x08\n\x04EDGE\x10\x01\x12\x11\n\rEMBEDDE\
    D_EDGE\x10\x03*A\n\x08TaskType\x12\x10\n\x0cLOCAL_ONLINE\x10\0\x12\x10\n\
    \x0cSPARK_ONLINE\x10\x01\x12\x11\n\rSPARK_OFFLINE\x10\x02*\x20\n\tSparkM\
    ode\x12\x08\n\x04YARN\x10\0\x12\t\n\x05LOCAL\x10\x01B\x02P\x01J\xd8\x1e\
    \n\x06\x12\x04\0\0m\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x02\0$\n\t\n\x02\x03\0\x12\x03\x03\0#\n\t\n\x02\x03\x01\x12\x03\
    \x04\0\x19\n\x08\n\x01\x08\x12\x03\x06\0\"\n\t\n\x02\x08\n\x12\x03\x06\0\
    \"\n\n\n\x02\x05\0\x12\x04\x08\0\x0e\x01\n\n\n\x03\x05\0\x01\x12\x03\x08\
    \x05\x13\n\x0b\n\x04\x05\0\x02\0\x12\x03\t\x02\n\n\x0c\n\x05\x05\0\x02\0\
    \x01\x12\x03\t\x02\x05\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\t\x08\t\n\x0b\
    \n\x04\x05\0\x02\x01\x12\x03\n\x02\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\
    \x03\n\x02\x05\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\n\x08\t\n\x0b\n\x04\
    \x05\0\x02\x02\x12\x03\x0b\x02\x0b\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\
    \x0b\x02\x06\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x0b\t\n\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03\x0c\x02\x0b\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\
    \x0c\x02\x06\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x0c\t\n\n\x0b\n\x04\
    \x05\0\x02\x04\x12\x03\r\x02\x0b\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\r\
    \x02\x06\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\r\t\n\n\n\n\x02\x04\0\x12\
    \x04\x10\0\x1a\x01\n\n\n\x03\x04\0\x01\x12\x03\x10\x08\x12\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\x11\x02!\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x11\x02\
    \x10\x14\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x11\x02\x10\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03\x11\x11\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x11\
    \x1f\x20\n\x0c\n\x04\x04\0\x08\0\x12\x04\x12\x02\x18\x03\n\x0c\n\x05\x04\
    \0\x08\0\x01\x12\x03\x12\x08\x14\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x13\
    \x04\x1d\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x13\x04\r\n\x0c\n\x05\x04\
    \0\x02\x01\x01\x12\x03\x13\x0e\x18\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\
    \x13\x1b\x1c\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x14\x04\x1d\n\x0c\n\x05\
    \x04\0\x02\x02\x06\x12\x03\x14\x04\r\n\x0c\n\x05\x04\0\x02\x02\x01\x12\
    \x03\x14\x0e\x18\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x14\x1b\x1c\n\x0b\
    \n\x04\x04\0\x02\x03\x12\x03\x15\x04\x1f\n\x0c\n\x05\x04\0\x02\x03\x06\
    \x12\x03\x15\x04\x0e\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x15\x0f\x1a\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x15\x1d\x1e\n\x0b\n\x04\x04\0\x02\
    \x04\x12\x03\x16\x04\x1f\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\x16\x04\
    \x0e\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x16\x0f\x1a\n\x0c\n\x05\x04\0\
    \x02\x04\x03\x12\x03\x16\x1d\x1e\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x17\
    \x04\x1f\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03\x17\x04\x0e\n\x0c\n\x05\
    \x04\0\x02\x05\x01\x12\x03\x17\x0f\x1a\n\x0c\n\x05\x04\0\x02\x05\x03\x12\
    \x03\x17\x1d\x1e\n\x0b\n\x04\x04\0\x02\x06\x12\x03\x19\x02\x13\n\r\n\x05\
    \x04\0\x02\x06\x04\x12\x04\x19\x02\x18\x03\n\x0c\n\x05\x04\0\x02\x06\x05\
    \x12\x03\x19\x02\x06\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x19\x07\x0e\n\
    \x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x19\x11\x12\n\n\n\x02\x04\x01\x12\
    \x04\x1c\0#\x01\n\n\n\x03\x04\x01\x01\x12\x03\x1c\x08\x12\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03\x1d\x02\"\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x1d\
    \x02\x1c\x14\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\x1d\x02\x15\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03\x1d\x16\x1d\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x1d\x20!\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x1e\x02\x12\n\r\n\
    \x05\x04\x01\x02\x01\x04\x12\x04\x1e\x02\x1d\"\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03\x1e\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1e\
    \n\r\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1e\x10\x11\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03\x1f\x02\x12\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\
    \x1f\x02\x1e\x12\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x1f\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x1f\t\r\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03\x1f\x10\x11\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x20\x02\
    \x16\n\r\n\x05\x04\x01\x02\x03\x04\x12\x04\x20\x02\x1f\x12\n\x0c\n\x05\
    \x04\x01\x02\x03\x05\x12\x03\x20\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\
    \x12\x03\x20\t\x11\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\x20\x14\x15\n\
    \x0b\n\x04\x04\x01\x02\x04\x12\x03!\x02\x14\n\r\n\x05\x04\x01\x02\x04\
    \x04\x12\x04!\x02\x20\x16\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03!\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03!\t\x0f\n\x0c\n\x05\x04\x01\
    \x02\x04\x03\x12\x03!\x12\x13\n\x0b\n\x04\x04\x01\x02\x05\x12\x03\"\x02\
    \x11\n\r\n\x05\x04\x01\x02\x05\x04\x12\x04\"\x02!\x14\n\x0c\n\x05\x04\
    \x01\x02\x05\x05\x12\x03\"\x02\x08\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\
    \x03\"\t\x0c\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03\"\x0f\x10\n\n\n\x02\
    \x04\x02\x12\x04%\0)\x01\n\n\n\x03\x04\x02\x01\x12\x03%\x08\x11\n\x0b\n\
    \x04\x04\x02\x02\0\x12\x03&\x02!\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03&\
    \x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03&\x0b\x11\n\x0c\n\x05\x04\
    \x02\x02\0\x01\x12\x03&\x12\x1c\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03&\
    \x1f\x20\n\x0b\n\x04\x04\x02\x02\x01\x12\x03'\x02\"\n\x0c\n\x05\x04\x02\
    \x02\x01\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03'\x0b\
    \x11\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03'\x12\x1d\n\x0c\n\x05\x04\
    \x02\x02\x01\x03\x12\x03'\x20!\n\x0b\n\x04\x04\x02\x02\x02\x12\x03(\x02\
    \x11\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04(\x02'\"\n\x0c\n\x05\x04\x02\
    \x02\x02\x05\x12\x03(\x02\x08\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03(\t\
    \x0c\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03(\x0f\x10\n\n\n\x02\x04\x03\
    \x12\x04+\0.\x01\n\n\n\x03\x04\x03\x01\x12\x03+\x08\x12\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03,\x02\"\n\r\n\x05\x04\x03\x02\0\x04\x12\x04,\x02+\x14\
    \n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03,\x02\x15\n\x0c\n\x05\x04\x03\x02\
    \0\x01\x12\x03,\x16\x1d\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03,\x20!\n\
    \x0b\n\x04\x04\x03\x02\x01\x12\x03-\x02\x11\n\r\n\x05\x04\x03\x02\x01\
    \x04\x12\x04-\x02,\"\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03-\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03-\t\x0c\n\x0c\n\x05\x04\x03\x02\
    \x01\x03\x12\x03-\x0f\x10\n\n\n\x02\x04\x04\x12\x040\03\x01\n\n\n\x03\
    \x04\x04\x01\x12\x030\x08\x12\n\x0b\n\x04\x04\x04\x02\0\x12\x031\x02\"\n\
    \r\n\x05\x04\x04\x02\0\x04\x12\x041\x020\x14\n\x0c\n\x05\x04\x04\x02\0\
    \x06\x12\x031\x02\x15\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x031\x16\x1d\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x031\x20!\n\x0b\n\x04\x04\x04\x02\x01\
    \x12\x032\x02\x12\n\r\n\x05\x04\x04\x02\x01\x04\x12\x042\x021\"\n\x0c\n\
    \x05\x04\x04\x02\x01\x05\x12\x032\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\
    \x01\x12\x032\t\r\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x032\x10\x11\n\n\n\
    \x02\x04\x05\x12\x045\09\x01\n\n\n\x03\x04\x05\x01\x12\x035\x08\x11\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x036\x02\x12\n\r\n\x05\x04\x05\x02\0\x04\
    \x12\x046\x025\x13\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x036\x02\x08\n\x0c\
    \n\x05\x04\x05\x02\0\x01\x12\x036\t\r\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x036\x10\x11\n\x0b\n\x04\x04\x05\x02\x01\x12\x037\x02\x1d\n\x0c\n\x05\
    \x04\x05\x02\x01\x04\x12\x037\x02\n\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\
    \x037\x0b\x11\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x037\x12\x18\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x037\x1b\x1c\n\x0b\n\x04\x04\x05\x02\x02\
    \x12\x038\x02\x17\n\r\n\x05\x04\x05\x02\x02\x04\x12\x048\x027\x1d\n\x0c\
    \n\x05\x04\x05\x02\x02\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x038\t\x12\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x038\x15\x16\n\n\
    \n\x02\x05\x01\x12\x04;\0?\x01\n\n\n\x03\x05\x01\x01\x12\x03;\x05\x10\n\
    \x0b\n\x04\x05\x01\x02\0\x12\x03<\x02\r\n\x0c\n\x05\x05\x01\x02\0\x01\
    \x12\x03<\x02\x08\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03<\x0b\x0c\n\x0b\n\
    \x04\x05\x01\x02\x01\x12\x03=\x02\x0b\n\x0c\n\x05\x05\x01\x02\x01\x01\
    \x12\x03=\x02\x06\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03=\t\n\n\x0b\n\
    \x04\x05\x01\x02\x02\x12\x03>\x02\x14\n\x0c\n\x05\x05\x01\x02\x02\x01\
    \x12\x03>\x02\x0f\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03>\x12\x13\n\n\n\
    \x02\x05\x02\x12\x04A\0E\x01\n\n\n\x03\x05\x02\x01\x12\x03A\x05\r\n\x0b\
    \n\x04\x05\x02\x02\0\x12\x03B\x02\x13\n\x0c\n\x05\x05\x02\x02\0\x01\x12\
    \x03B\x02\x0e\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03B\x11\x12\n\x0b\n\x04\
    \x05\x02\x02\x01\x12\x03C\x02\x13\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\
    \x03C\x02\x0e\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03C\x11\x12\n\x0b\n\
    \x04\x05\x02\x02\x02\x12\x03D\x02\x14\n\x0c\n\x05\x05\x02\x02\x02\x01\
    \x12\x03D\x02\x0f\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03D\x12\x13\n\n\n\
    \x02\x05\x03\x12\x04G\0J\x01\n\n\n\x03\x05\x03\x01\x12\x03G\x05\x0e\n\
    \x0b\n\x04\x05\x03\x02\0\x12\x03H\x02\x0b\n\x0c\n\x05\x05\x03\x02\0\x01\
    \x12\x03H\x02\x06\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03H\t\n\n\x0b\n\x04\
    \x05\x03\x02\x01\x12\x03I\x02\x0c\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\
    \x03I\x02\x07\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x03I\n\x0b\n\n\n\x02\
    \x04\x06\x12\x04L\0S\x01\n\n\n\x03\x04\x06\x01\x12\x03L\x08\x12\n\x0b\n\
    \x04\x04\x06\x02\0\x12\x03M\x02\x17\n\r\n\x05\x04\x06\x02\0\x04\x12\x04M\
    \x02L\x14\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03M\x02\r\n\x0c\n\x05\x04\
    \x06\x02\0\x01\x12\x03M\x0e\x12\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03M\
    \x15\x16\n\x0b\n\x04\x04\x06\x02\x01\x12\x03N\x02\x13\n\r\n\x05\x04\x06\
    \x02\x01\x04\x12\x04N\x02M\x17\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03N\
    \x02\x08\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03N\t\x0e\n\x0c\n\x05\x04\
    \x06\x02\x01\x03\x12\x03N\x11\x12\n\x0b\n\x04\x04\x06\x02\x02\x12\x03O\
    \x02\x13\n\r\n\x05\x04\x06\x02\x02\x04\x12\x04O\x02N\x13\n\x0c\n\x05\x04\
    \x06\x02\x02\x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\
    \x03O\t\x0e\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03O\x11\x12\n\x0b\n\x04\
    \x04\x06\x02\x03\x12\x03P\x02\x1d\n\r\n\x05\x04\x06\x02\x03\x04\x12\x04P\
    \x02O\x13\n\x0c\n\x05\x04\x06\x02\x03\x06\x12\x03P\x02\x0c\n\x0c\n\x05\
    \x04\x06\x02\x03\x01\x12\x03P\r\x18\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\
    \x03P\x1b\x1c\n\x0b\n\x04\x04\x06\x02\x04\x12\x03Q\x02\x13\n\r\n\x05\x04\
    \x06\x02\x04\x04\x12\x04Q\x02P\x1d\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\
    \x03Q\x02\x07\n\x0c\n\x05\x04\x06\x02\x04\x01\x12\x03Q\x08\x0e\n\x0c\n\
    \x05\x04\x06\x02\x04\x03\x12\x03Q\x11\x12\n\x0b\n\x04\x04\x06\x02\x05\
    \x12\x03R\x02\x1b\n\r\n\x05\x04\x06\x02\x05\x04\x12\x04R\x02Q\x13\n\x0c\
    \n\x05\x04\x06\x02\x05\x05\x12\x03R\x02\x08\n\x0c\n\x05\x04\x06\x02\x05\
    \x01\x12\x03R\t\x16\n\x0c\n\x05\x04\x06\x02\x05\x03\x12\x03R\x19\x1a\n\n\
    \n\x02\x04\x07\x12\x04U\0X\x01\n\n\n\x03\x04\x07\x01\x12\x03U\x08\x12\n\
    \x0b\n\x04\x04\x07\x02\0\x12\x03V\x02\x15\n\r\n\x05\x04\x07\x02\0\x04\
    \x12\x04V\x02U\x14\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03V\x02\x08\n\x0c\
    \n\x05\x04\x07\x02\0\x01\x12\x03V\t\x10\n\x0c\n\x05\x04\x07\x02\0\x03\
    \x12\x03V\x13\x14\n\x0b\n\x04\x04\x07\x02\x01\x12\x03W\x02\x1c\n\r\n\x05\
    \x04\x07\x02\x01\x04\x12\x04W\x02V\x15\n\x0c\n\x05\x04\x07\x02\x01\x05\
    \x12\x03W\x02\x07\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03W\x08\x17\n\x0c\
    \n\x05\x04\x07\x02\x01\x03\x12\x03W\x1a\x1b\n\n\n\x02\x04\x08\x12\x04Z\0\
    b\x01\n\n\n\x03\x04\x08\x01\x12\x03Z\x08\x14\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03[\x02\x19\n\r\n\x05\x04\x08\x02\0\x04\x12\x04[\x02Z\x16\n\x0c\n\
    \x05\x04\x08\x02\0\x06\x12\x03[\x02\n\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03[\x0b\x14\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03[\x17\x18\n\x0b\n\x04\
    \x04\x08\x02\x01\x12\x03\\\x02\x20\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\
    \x03\\\x02\n\n\x0c\n\x05\x04\x08\x02\x01\x06\x12\x03\\\x0b\x15\n\x0c\n\
    \x05\x04\x08\x02\x01\x01\x12\x03\\\x16\x1b\n\x0c\n\x05\x04\x08\x02\x01\
    \x03\x12\x03\\\x1e\x1f\n\x0b\n\x04\x04\x08\x02\x02\x12\x03]\x02\x16\n\r\
    \n\x05\x04\x08\x02\x02\x04\x12\x04]\x02\\\x20\n\x0c\n\x05\x04\x08\x02\
    \x02\x06\x12\x03]\x02\x0c\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03]\r\x11\
    \n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03]\x14\x15\n\x0b\n\x04\x04\x08\
    \x02\x03\x12\x03^\x02E\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04^\x02]\x16\n\
    \x0c\n\x05\x04\x08\x02\x03\x06\x12\x03^\x026\n\x0c\n\x05\x04\x08\x02\x03\
    \x01\x12\x03^7@\n\x0c\n\x05\x04\x08\x02\x03\x03\x12\x03^CD\n\x0b\n\x04\
    \x04\x08\x02\x04\x12\x03_\x02\x16\n\r\n\x05\x04\x08\x02\x04\x04\x12\x04_\
    \x02^E\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\x03_\x02\x07\n\x0c\n\x05\x04\
    \x08\x02\x04\x01\x12\x03_\x08\x11\n\x0c\n\x05\x04\x08\x02\x04\x03\x12\
    \x03_\x14\x15\n\x0b\n\x04\x04\x08\x02\x05\x12\x03`\x02\x18\n\r\n\x05\x04\
    \x08\x02\x05\x04\x12\x04`\x02_\x16\n\x0c\n\x05\x04\x08\x02\x05\x05\x12\
    \x03`\x02\x07\n\x0c\n\x05\x04\x08\x02\x05\x01\x12\x03`\x08\x13\n\x0c\n\
    \x05\x04\x08\x02\x05\x03\x12\x03`\x16\x17\n\x0b\n\x04\x04\x08\x02\x06\
    \x12\x03a\x02\x1b\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04a\x02`\x18\n\x0c\
    \n\x05\x04\x08\x02\x06\x06\x12\x03a\x02\x0b\n\x0c\n\x05\x04\x08\x02\x06\
    \x01\x12\x03a\x0c\x16\n\x0c\n\x05\x04\x08\x02\x06\x03\x12\x03a\x19\x1a\n\
    \n\n\x02\x04\t\x12\x04d\0m\x01\n\n\n\x03\x04\t\x01\x12\x03d\x08\x14\n\
    \x0c\n\x04\x04\t\x04\0\x12\x04e\x02i\x03\n\x0c\n\x05\x04\t\x04\0\x01\x12\
    \x03e\x07\r\n\r\n\x06\x04\t\x04\0\x02\0\x12\x03f\x04\x0b\n\x0e\n\x07\x04\
    \t\x04\0\x02\0\x01\x12\x03f\x04\x06\n\x0e\n\x07\x04\t\x04\0\x02\0\x02\
    \x12\x03f\t\n\n\r\n\x06\x04\t\x04\0\x02\x01\x12\x03g\x04\r\n\x0e\n\x07\
    \x04\t\x04\0\x02\x01\x01\x12\x03g\x04\x08\n\x0e\n\x07\x04\t\x04\0\x02\
    \x01\x02\x12\x03g\x0b\x0c\n\r\n\x06\x04\t\x04\0\x02\x02\x12\x03h\x04\x10\
    \n\x0e\n\x07\x04\t\x04\0\x02\x02\x01\x12\x03h\x04\x0b\n\x0e\n\x07\x04\t\
    \x04\0\x02\x02\x02\x12\x03h\x0e\x0f\n\x0b\n\x04\x04\t\x02\0\x12\x03j\x02\
    \x14\n\r\n\x05\x04\t\x02\0\x04\x12\x04j\x02i\x03\n\x0c\n\x05\x04\t\x02\0\
    \x06\x12\x03j\x02\x08\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03j\t\x0f\n\x0c\n\
    \x05\x04\t\x02\0\x03\x12\x03j\x12\x13\n\x0b\n\x04\x04\t\x02\x01\x12\x03k\
    \x02\x14\n\r\n\x05\x04\t\x02\x01\x04\x12\x04k\x02j\x14\n\x0c\n\x05\x04\t\
    \x02\x01\x05\x12\x03k\x02\x08\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03k\t\
    \x0f\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03k\x12\x13\n\x0b\n\x04\x04\t\
    \x02\x02\x12\x03l\x02\x15\n\r\n\x05\x04\t\x02\x02\x04\x12\x04l\x02k\x14\
    \n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03l\x02\x08\n\x0c\n\x05\x04\t\x02\
    \x02\x01\x12\x03l\t\x10\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03l\x13\x14b\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(super::graph_rpc::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(DataSource::generated_message_descriptor_data());
            messages.push(JdbcSource::generated_message_descriptor_data());
            messages.push(TdwSource::generated_message_descriptor_data());
            messages.push(HiveSource::generated_message_descriptor_data());
            messages.push(JsonSource::generated_message_descriptor_data());
            messages.push(CsvSource::generated_message_descriptor_data());
            messages.push(TaskConfig::generated_message_descriptor_data());
            messages.push(TiKVConfig::generated_message_descriptor_data());
            messages.push(LoaderConfig::generated_message_descriptor_data());
            messages.push(LoadResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(DataSourceType::generated_enum_descriptor_data());
            enums.push(ElementType::generated_enum_descriptor_data());
            enums.push(TaskType::generated_enum_descriptor_data());
            enums.push(SparkMode::generated_enum_descriptor_data());
            enums.push(load_response::Status::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
